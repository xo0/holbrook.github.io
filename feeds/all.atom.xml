<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>心内求法</title><link href="http://holbrook.github.io/" rel="alternate"></link><link href="http://holbrook.github.io/feeds/all.atom.xml" rel="self"></link><id>http://holbrook.github.io/</id><updated>2017-02-05T00:00:00+08:00</updated><entry><title>数据科学的知识体系</title><link href="http://holbrook.github.io/2017/02/05/index.html" rel="alternate"></link><published>2017-02-05T00:00:00+08:00</published><updated>2017-02-05T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2017-02-05:/2017/02/05/index.html</id><summary type="html">&lt;p&gt;数据科学是利用计算机的运算能力对数据进行处理，从数据中提取信息，进而形成“知识”。
数据科学已经在IT、金融、医学、自动驾驶等领域得到广泛使用。&lt;/p&gt;</summary><content type="html">&lt;p&gt;传统意义上的数据处理是用统计方法实现的，而概率论是统计的基础。
随着计算机处理能力的增强，一些需要大量运算的数据分析方法得到快速发展。
机器学习实际上是一个混合体，包括一些在计算机领域中发展的算法，也包括一些传统统计中已经存在，但受限于计算能力的统计方法。
另一方面，从数据中提炼知识是机器学习的主要目的，这与统计推断密切相关。
因此，从传统的概率和统计出发，更容易理解机器学习的内涵。&lt;/p&gt;
&lt;p&gt;数据科学必备的知识包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概率论&lt;/li&gt;
&lt;li&gt;计数&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;概率公理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件概率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;离散分布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连续分布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;联合分布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机变量的函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;期望&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方差与标准差&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;协方差与相关系数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;矩与矩生成函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中心极限定律&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数学与编程：“概率论”总结&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计基础&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计Go, Go, Go&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;数据描述&lt;/li&gt;
&lt;li&gt;参数估计&lt;/li&gt;
&lt;li&gt;区间估计&lt;/li&gt;
&lt;li&gt;假设检验&lt;/li&gt;
&lt;li&gt;线性回归&lt;/li&gt;
&lt;li&gt;ANOVA&lt;/li&gt;
&lt;li&gt;无参估计&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;贝叶斯方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多变量数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;线性代数基础&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PCA分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号与频谱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;机器学习&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;监督学习&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无监督学习&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;python&lt;/li&gt;
&lt;li&gt;numpy&lt;/li&gt;
&lt;li&gt;matplotlib&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>搭建一个“现代化”的web开发环境</title><link href="http://holbrook.github.io/2015/05/04/modern_web_dev_env.html" rel="alternate"></link><published>2015-05-04T00:00:00+08:00</published><updated>2015-05-04T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2015-05-04:/2015/05/04/modern_web_dev_env.html</id><summary type="html">&lt;p&gt;使用yoeman, bower, grunt等工具开发web。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;目标&lt;/h1&gt;
&lt;p&gt;将要开展的一个项目，使用Angularjs 和 Flask开发一个web界面，
作为saltstack和其他自行开发的python小工具的前端界面，
实现自己的“运维操作平台”。&lt;/p&gt;
&lt;p&gt;为了统一框架、工具和开发方式，在本文中描述了项目的一些约定。
这些约定具有通用性，应该是目前基于python的web开发技术中，
比较”主流“和”先进“的方式，所以也可以作为开发其他应用的参考。&lt;/p&gt;
&lt;h1&gt;工具和框架&lt;/h1&gt;
&lt;h2&gt;工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;版本管理
    基于&lt;a href="http://gogs.io/"&gt;gogs&lt;/a&gt; 的私有git&lt;/li&gt;
&lt;li&gt;问题管理、版本发布、资料共享
    &lt;a href="http://www.redmine.org/"&gt;redmine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;项目管理
    &lt;a href="http://www.redminebacklogs.net/"&gt;redmine的scrum插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nodejs包管理器
    &lt;a href="https://www.npmjs.com/"&gt;npm&lt;/a&gt;(node package manager)。&lt;/p&gt;
&lt;p&gt;本文中，npm仅作为安装yoeman, bower，grunt等的基础工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;js依赖管理: &lt;a href="http://bower.io/"&gt;bower&lt;/a&gt;
    npm可以安装js包，但是没有解决依赖的问题。而bower解决了js包的依赖管理。类似maven中的依赖管理功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端构建工具: &lt;a href="http://gruntjs.com/"&gt;grunt&lt;/a&gt;
    js开发中的项目构建工具，类似maven/ant/makefile，
    通过配置文件执行压缩,编译, 单元测试, 代码检查以及打包发布的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端脚手架工具
    &lt;a href=""&gt;yoeman&lt;/a&gt;。类似maven的archetypes。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python开发环境管理
    &lt;a href="http://virtualenv-chinese-docs.readthedocs.org/en/latest/"&gt;virtualenv&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;框架和插件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;样式库 &lt;a href="http://getbootstrap.com/"&gt;Bootstrap&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/nnnick/Chart.js/"&gt;chartjs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端框架：&lt;a href="https://angularjs.org/"&gt;AngularJS&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;后端框架：&lt;a href=""&gt;Flask&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Flask-SQLAlchemy&lt;/li&gt;
&lt;li&gt;Flask-RESTful&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;环境准备&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;本文中仅给出MacOS下的安装方法，其他系统可以阅读官方文档或参考资料。
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#安装npm&lt;/span&gt;
brew install npm

&lt;span class="c1"&gt;#全局安装工具&lt;/span&gt;
npm install -g yo grunt-cli grunt bower generator-angular

&lt;span class="c1"&gt;#安装virtualenv&lt;/span&gt;
sudo easy_install pip
sudo pip install virtualenv
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;搭建工程&lt;/h1&gt;
&lt;h2&gt;创建工程目录&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/web &lt;span class="se"&gt;\#&lt;/span&gt; 前端工程目录 mkdir -p
PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME &lt;span class="se"&gt;\#&lt;/span&gt; 后端工程目录 &lt;span class="se"&gt;\#&lt;/span&gt;+END
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;创建前端工程&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/web yo angular &lt;span class="se"&gt;\#&lt;/span&gt; 一些交互，按照自己的需要选择即可。 &lt;span class="se"&gt;\#&lt;/span&gt;...
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;配置前端工程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改IP地址&lt;/p&gt;
&lt;p&gt;将connect -&gt; hostname, 由'localhost' 改为 '0.0.0.0'&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改dist目录&lt;/p&gt;
&lt;p&gt;将appConfig -&gt; dist 有 'dist' 改为 '../app/APP_NAME/static'&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;virtualenv&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT
virtualenv venv
&lt;span class="nb"&gt;source&lt;/span&gt; venv/bin/activate
pip install flask
pip install sqlalchemy
pip install flask-sqlalchemy
...
pip freeze &amp;gt; app/requirements.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;构建Flask工程&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/common
mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/models
mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/static
mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/templates
mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/views

touch PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/common/__init__.py
touch PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/models/__init__.py
touch PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/views/__init__.py
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;配置git&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT
mv web/.gitattributes .
rm -f web/.gitignore
cat &amp;gt; .gitignore &lt;span class="s"&gt;&amp;lt;&amp;lt; EOF&lt;/span&gt;
&lt;span class="s"&gt;web/node_modules&lt;/span&gt;
&lt;span class="s"&gt;web/.tmp&lt;/span&gt;
&lt;span class="s"&gt;web/.sass-cache&lt;/span&gt;
&lt;span class="s"&gt;web/bower_components&lt;/span&gt;
&lt;span class="s"&gt;dist&lt;/span&gt;
&lt;span class="s"&gt;venv&lt;/span&gt;
&lt;span class="s"&gt;EOF&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;使用&lt;/h1&gt;
&lt;p&gt;以上是工程框架搭建的过程，对于开发人员，不需要要这么麻烦，只要从版本库中获取源代码后进行初始化即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone xxxx &lt;span class="nb"&gt;cd&lt;/span&gt; PROJ_ROOT
virtualenv venv
&lt;span class="nb"&gt;source&lt;/span&gt; venv/bin/activate
pip install -r app/requirements.txt
&lt;span class="nb"&gt;cd&lt;/span&gt; web
npm install
bower install
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;启动前端&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; PROJ_ROOT/web
grunt serve
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后通过http://0.0.0.0:9000可以访问前端界面。&lt;/p&gt;
&lt;h2&gt;启动后端&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app
python run.py
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;然后通过http://127.0.0.1:5000/ 访问后端应用。
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;知识准备&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;在开始开发之前，开发人员最好熟悉以下内容：

- Bootstrap入门: http://v3.bootcss.com/getting-started/
- Angularjs入门教程: http://www.ituring.com.cn/article/13471
- Flask系列教程 :http://www.oschina.net/translate/the-flask-mega-tutorial-part-i-hello-world
- SQLAlchemy教程:
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;NPM小结 chyingp http://www.cnblogs.com/chyingp/p/npm.html&lt;/li&gt;
&lt;li&gt;bower解决js的依赖管理 | 粉丝日志
    http://blog.fens.me/nodejs-bower-intro/&lt;/li&gt;
&lt;li&gt;getting started with Yeoman http://yeoman.io/learning/index.html&lt;/li&gt;
&lt;li&gt;Yeoman自动构建js项目 | 粉丝日志
    http://blog.fens.me/nodejs-yeoman-intro/&lt;/li&gt;
&lt;li&gt;grunt让Nodejs规范起来 | 粉丝日志
    http://blog.fens.me/nodejs-grunt-intro/&lt;/li&gt;
&lt;li&gt;Bootstrap入门 http://v3.bootcss.com/getting-started/&lt;/li&gt;
&lt;li&gt;AngularJS入门教程 http://www.ituring.com.cn/article/13471&lt;/li&gt;
&lt;li&gt;Flask系列教程
    http://www.oschina.net/translate/the-flask-mega-tutorial-part-i-hello-world&lt;/li&gt;
&lt;li&gt;使用 Flask 和 AngularJS 构建博客 - 1
    http://segmentfault.com/a/1190000000654088&lt;/li&gt;
&lt;li&gt;使用 Flask 和 AngularJS 构建博客 - 2
    http://segmentfault.com/a/1190000000665636&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;references:
- id: fenner2012a
  title: One-click science marketing
    author:
      - family: Fenner
        given: Martin
        container-title: Nature Materials
        volume: 11
        URL: 'http://dx.doi.org/10.1038/nmat3283'
        DOI: 10.1038/nmat3283
        issue: 4
        publisher: Nature Publishing Group
        page: 261-263
        type: article-journal
        issued:
        year: 2012
        month: 3&lt;/p&gt;
&lt;hr&gt;</content><category term="web"></category></entry><entry><title>在markdown中嵌入graphviz</title><link href="http://holbrook.github.io/2014/02/17/graphviz_in_markdown.html" rel="alternate"></link><published>2014-02-17T00:00:00+08:00</published><updated>2014-02-17T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-02-17:/2014/02/17/graphviz_in_markdown.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;在markdown中嵌入graphviz&lt;/h1&gt;
&lt;h2&gt;gravizo.com&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;![txt](http://g.gravizo.com/g?
  digraph G {
    aize =&amp;quot;4,4&amp;quot;;
    main [shape=box];
    main -&amp;gt; parse [weight=8];
    parse -&amp;gt; execute;
    main -&amp;gt; init [style=dotted];
    main -&amp;gt; cleanup;
    execute -&amp;gt; { make_string; printf}
    init -&amp;gt; make_string;
    edge [color=red];
    main -&amp;gt; printf [style=bold,label=&amp;quot;100 times&amp;quot;];
    make_string [label=&amp;quot;make a string&amp;quot;];
    node [shape=box,style=filled,color=&amp;quot;.7 .3 1.0&amp;quot;];
    execute -&amp;gt; compare;
  }
)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;abc&lt;/h2&gt;</content><category term="graph"></category><category term="markdown"></category></entry><entry><title>Graphviz概述</title><link href="http://holbrook.github.io/2014/02/17/graphviz_intro.html" rel="alternate"></link><published>2014-02-17T00:00:00+08:00</published><updated>2014-02-17T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-02-17:/2014/02/17/graphviz_intro.html</id><summary type="html">&lt;p&gt;Graphviz是一个强大的绘图工具，使用DOT语言描述图像。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Graphviz是什么&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://www.graphviz.org/"&gt;Graphviz&lt;/a&gt;是基于dot语言的绘图工具，可以画有向图、无向图、关系图、目录图、流程图等各种你知道的或不知道的图形。可以欣赏Graphviz的&lt;a href="http://www.graphviz.org/Gallery.php"&gt;Gallery&lt;/a&gt;，以及Yifan Hu的&lt;a href="http://www2.research.att.com/~yifanhu/GALLERY/GRAPHS/index1.html"&gt;gallery of large graphs&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Graphviz使用&lt;a href="http://zh.wikipedia.org/wiki/DOT%E8%AF%AD%E8%A8%80"&gt;DOT语言&lt;/a&gt;描述图形，并提供一组工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dot&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将生成的图形转换成多种输出格式，如PostScript，PDF，SVG，PNG，含注解的文本等等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;neato&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用于sprint model的生成（在Mac OS版本中称为energy minimized）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;twopi&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用于放射状图形的生成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;circo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用于圆形图形的生成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fdp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一个用于生成无向图的工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dotty&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个用于可视化与修改图形的图形用户界面程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lefty&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个可编程的控件，它可以显示DOT图形，并允许用户用鼠标在图上执行操作。Lefty可以作为MVC模型的使用图形的GUI程序中的视图部分。&lt;/p&gt;
&lt;p&gt;Graphviz使用&lt;a href="http://zh.wikipedia.org/wiki/DOT%E8%AF%AD%E8%A8%80"&gt;DOT语言&lt;/a&gt;描述图形，而不是依赖于鼠标绘图，这就提供了无限的可能，主要体现在两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动生成图形描述文件，从而自动生成图形&lt;/li&gt;
&lt;li&gt;更加Geek的写作方式，比如在Org-mode中嵌入图形代码，在导出时自动生成图形文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一些强大的工具依赖或支持Graphviz，比如&lt;a href="http://www.omnigroup.com/omnigraffle"&gt;OmniGraffle&lt;/a&gt;
和&lt;a href="http://plantuml.sourceforge.net/index.html"&gt;PlantUML&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;DOT语言简介&lt;/h1&gt;
&lt;p&gt;DOT语言使用离散数学中的Graph描述图形，包括三个基本元素：grahp,node,edge。下面是一个例子：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;example.dot&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;digraph G {
main -&amp;gt; parse -&amp;gt; execute[label=&amp;quot;edge label2&amp;quot;];
main -&amp;gt; init[label=&amp;quot;edge label1&amp;quot;];
main -&amp;gt; cleanup;
execute -&amp;gt; make_string;
execute -&amp;gt; printf;
init -&amp;gt; make_string;
main -&amp;gt; printf;
execute -&amp;gt; compare;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行命令&lt;code&gt;dot -Tpng example.dot -o example.png&lt;/code&gt;，就可以生成如下的图形：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/graphviz/example.png"&gt;&lt;/p&gt;
&lt;p&gt;DOT通过属性可以设置node和edge的样式，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;graph graphname {
     // label属性可以改变节点的显示名称
     a [label=&amp;quot;Foo&amp;quot;];     // 节点形状被改变了
     b [shape=box];     // a-b边和b-c边有相同的属性
     a -- b -- c [color=blue];
     b -- d [style=dotted, label=&amp;quot;无向图&amp;quot;];
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;生成的图形如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/graphviz/a.png"&gt;&lt;/p&gt;
&lt;p&gt;更多的属性设置可以参考&lt;a href="http://www.graphviz.org/content/attrs"&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;应用场景&lt;/h1&gt;
&lt;p&gt;Graphviz可以有很多玩法，常见的比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://gashero.iteye.com/blog/1748795"&gt;直接使用Graphviz绘图&lt;/a&gt;，以代替Visio等绘图工具&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/lanxuezaipiao/p/3450201.html"&gt;其他工具生成数据，Graphviz进行图表展示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;利用脚本&lt;a href="http://www.ibm.com/developerworks/cn/aix/library/au-aix-graphviz/index.html?ca=dat"&gt;动态生成图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;嵌入轻量级标记语言，如org-mode和markdown中&lt;/li&gt;
&lt;/ul&gt;</content><category term="graph"></category></entry><entry><title>Apache Camel的核心概念</title><link href="http://holbrook.github.io/2014/02/10/apache_camel.html" rel="alternate"></link><published>2014-02-10T00:00:00+08:00</published><updated>2014-02-10T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-02-10:/2014/02/10/apache_camel.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;Apache Camel的整体架构&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://camel.apache.org/"&gt;Apache Camel&lt;/a&gt;是一个消息处理引擎，实现了EIP(Enterprise Integration Patterns,企业整合模式)。&lt;/p&gt;
&lt;p&gt;Camel能够用来处理来自于不同源的事件和信息，定义规则进行消息的传递和转换等处理，以实现基于消息的应用整合。其整体架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/camel/camel-architecture.png"&gt;&lt;/p&gt;
&lt;h1&gt;Message 和 Exchange&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;org.apache.camel.Message&lt;/code&gt;接口是对“消息”的抽象。消息由head、body、attachment等部分组成。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/camel/message.png"&gt;&lt;/p&gt;
&lt;p&gt;Camel中提供了一个默认的实现：&lt;code&gt;org.apache.camel.impl.DefaultMessage&lt;/code&gt;，可以适应大部分的应用场景。&lt;/p&gt;
&lt;p&gt;不管是请求、响应，或者异常，都可以作为消息在上下文(CamelContext)的消息处理器(Processor)之间进行交换(Exchange)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.apache.camel.Exchange&lt;/code&gt;接口就是对“消息交换”的抽象。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/camel/exchange.png"&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exchange ID : 区分每次消息交换的标识&lt;/li&gt;
&lt;li&gt;MEP: （message exchange pattern，消息交换模式），分为单向(InOnly)和请求-应答(InOut)两种&lt;/li&gt;
&lt;li&gt;Exception: 用于记录消息交换时发生的异常&lt;/li&gt;
&lt;li&gt;In message: 上一个节点传入的消息&lt;/li&gt;
&lt;li&gt;Out message: 当MEP 是InOut时，需要传出的消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Camel提供了默认的&lt;code&gt;org.apache.camel.impl.DefaultExchange&lt;/code&gt;实现。&lt;/p&gt;
&lt;p&gt;Camel处理消息时，每个节点都在处理&lt;code&gt;Exchange&lt;/code&gt;。&lt;/p&gt;
&lt;h1&gt;Endpoint 和 Component&lt;/h1&gt;
&lt;p&gt;Endpoint(端点)，接收或发送消息的通道。通过&lt;a href="http://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6"&gt;URI&lt;/a&gt;连接消息源或目标。&lt;/p&gt;
&lt;p&gt;为了适应各种不同的URI协议，如http,ftp,JMS,smtp等，Camel中提供了多种Endpoint，也支持扩展自己的Endpoint。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/camel/endpoints.png"&gt;&lt;/p&gt;
&lt;p&gt;Component(不应该叫做组件，而应该是连接器connector)。&lt;code&gt;org.apache.camel.Component&lt;/code&gt;接口只定义了两个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;createConfiguration(String)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;createEndpoint(String)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，客户代码不会直接调用&lt;code&gt;createEndoint()&lt;/code&gt;方法，而是由&lt;code&gt;CamelContext&lt;/code&gt;对象进行调用。&lt;/p&gt;
&lt;p&gt;Camel中提供了大量的Component的实现：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/camel/components.png"&gt;&lt;/p&gt;
&lt;h1&gt;Processor&lt;/h1&gt;
&lt;p&gt;不管是消息路由(Message Routing)、消息转换(Message Transformation)还是消息过滤(Message Filter)，都是对消息的某种处理(Process)。&lt;/p&gt;
&lt;p&gt;Camel中，抽象出&lt;code&gt;org.apache.camel.Processor&lt;/code&gt;接口，表示对消息的处理。该接口只定义了一个方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    void process(Exchange exchange) throws Exception;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从接口定义可以看出，Camel中认为可以处理消息交换(Exchange)的类都是消息处理器(Processor)。&lt;/p&gt;
&lt;p&gt;基于Camle的应用可以开发自己的Processor实现，同时Camel提供了大量的内置Processor，以支持&lt;a href="http://camel.apache.org/enterprise-integration-patterns.html"&gt;EIP(Enterprise Integration Patterns)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/camel/processor.png"&gt;&lt;/p&gt;
&lt;h1&gt;CamelContext&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="images/camel/camel_context.jpg"&gt;&lt;/p&gt;
&lt;p&gt;CamelContext是对Camel运行时的抽象，提供了API用于管理Component、Endpoint、Processor等节点：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/camel/context.png"&gt;&lt;/p&gt;
&lt;p&gt;一般来说，使用Camel的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个CamelContext对象。&lt;/li&gt;
&lt;li&gt;向CamelContext对象中添加Endpoints或者是Components&lt;/li&gt;
&lt;li&gt;向CamelContext对象中添加路由(routes)规则&lt;/li&gt;
&lt;li&gt;调用CamelContext的start()方法启动Camel引擎&lt;/li&gt;
&lt;li&gt;通过Endpoint发送或接收消息&lt;/li&gt;
&lt;li&gt;调用CamelContext的stop()方法时&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;定义路由(Route)&lt;/h1&gt;
&lt;p&gt;每个消息处理流程是由一系列的&lt;code&gt;Processor&lt;/code&gt;连接而成的图(Graph)，每个图称为一个路由(Route)。&lt;/p&gt;
&lt;p&gt;在开始使用Camel之前，需要在CamelContext中定义一个或多个路由。Camel支持使用DSL或者Spring XML进行配置。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="nt"&gt;RouteBuilder&lt;/span&gt; &lt;span class="nt"&gt;builder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;new&lt;/span&gt; &lt;span class="nt"&gt;RouteBuilder&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;queue:a&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isEqualTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                        &lt;span class="s2"&gt;&amp;quot;queue:b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;queue:c&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;choice&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;when&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isEqualTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                        &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;queue:d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;when&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isEqualTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;cheese&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                        &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;queue:e&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;otherwise&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;queue:f&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

        &lt;span class="nt"&gt;CamelContext&lt;/span&gt; &lt;span class="nt"&gt;myCamelContext&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;new&lt;/span&gt; &lt;span class="nt"&gt;DefaultCamelContext&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="nt"&gt;myCamelContext&lt;/span&gt;&lt;span class="nc"&gt;.addRoutes&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;builder&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="nt"&gt;&amp;lt;beans&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.springframework.org/schema/beans&amp;quot;&lt;/span&gt;
       &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt;
       &lt;span class="na"&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
&lt;span class="s"&gt;       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd&lt;/span&gt;
&lt;span class="s"&gt;    &amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!-- this is an included XML file where we only the the routeContext --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;routeContext&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myCoolRoutes&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://camel.apache.org/schema/spring&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- we can have a route --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;route&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;cool&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;from&lt;/span&gt; &lt;span class="na"&gt;uri=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;direct:start&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;to&lt;/span&gt; &lt;span class="na"&gt;uri=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mock:result&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/route&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- and another route, you can have as many your like --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;route&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;from&lt;/span&gt; &lt;span class="na"&gt;uri=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;direct:bar&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;to&lt;/span&gt; &lt;span class="na"&gt;uri=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mock:bar&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/route&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/routeContext&amp;gt;&lt;/span&gt;

  &lt;span class="nt"&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;FUSE Mediation Router: 企业级Camel&lt;/h1&gt;
&lt;p&gt;FuseSource提供Camel的经测试、认证并提供支持的企业级版本，称作&lt;a href="http://fusesource.com/products/enterprise-camel/"&gt;FUSE Mediation Router&lt;/a&gt;。&lt;/p&gt;</content></entry><entry><title>命令行界面设计</title><link href="http://holbrook.github.io/2014/01/30/2014-01-30-cli_design.html" rel="alternate"></link><published>2014-01-30T00:00:00+08:00</published><updated>2014-01-30T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-01-30:/2014/01/30/2014-01-30-cli_design.html</id><summary type="html">&lt;p&gt;尽管8年后的1973年出现了图形界面程序，
16年后的1981年出现了图形界面的操作系统，
但是在此之后，至今三十几年过去了，图形界面(GUI)仍无法取代命令行界面(CLI)。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;命令行界面是否过时&lt;/h1&gt;
&lt;p&gt;答案是：不会的！&lt;/p&gt;
&lt;p&gt;1965年&lt;a href="http://en.wikipedia.org/wiki/OS/360_and_successors"&gt;OS/360&lt;/a&gt;的发布标志着与硬件分离的“通用”操作系统的出现。&lt;/p&gt;
&lt;p&gt;尽管8年后的1973年出现了&lt;a href="http://en.wikipedia.org/wiki/Xerox_Alto"&gt;图形界面程序&lt;/a&gt;，
16年后的1981年出现了&lt;a href="http://en.wikipedia.org/wiki/Xerox_Star"&gt;图形界面的操作系统&lt;/a&gt;，
但是在此之后，至今三十几年过去了，图形界面(GUI)仍无法取代命令行界面(CLI)。&lt;/p&gt;
&lt;p&gt;有什么理由可以说，图形界面终将取代命令行界面呢？&lt;/p&gt;
&lt;p&gt;不管是传统的linux“神器”，如find, grep, curl, netcat, xargs, rsync,
screen，awk, vi, emacs， 还是让人惊叹的新作，如maven, git,
salt，都有着强大的命令行界面。甚至你会有一种感觉：
为这些软件设计图形界面根本就是画蛇添足。&lt;/p&gt;
&lt;p&gt;命令行界面的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;效率高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鼠标操作是最简单，同时也是最笨拙的操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更专注&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鼠标操作容易分心&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速度快&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLI程序需要的资源少，启动和执行速度更快&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易远程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ssh、telnet的连接比vnc、remote desktop等更容易&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLI不仅可以给人使用，也适用于自动化脚本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zhuangbility&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;^o^&lt;/p&gt;
&lt;h1&gt;命令行界面的类型&lt;/h1&gt;
&lt;p&gt;按照复杂程度，命令行界面可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非交互式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一次性输入所有的参数，程序执行期间不需要用户的干预。这是最常见的命令行界面形式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于行的交互&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在执行过程中，需要用户输入一些内容，比如确认信息、路径参数等。&lt;/p&gt;
&lt;p&gt;由于用户交互会使程序难以用于自动化脚本，所以这种命令行界面并不多见，常用于基于命令行的安装程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本用户界面(TUI)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似于图形用户界面，没有明确的执行流程，完全由用户控制程序的执行步骤。比如vi和emacs。&lt;/p&gt;
&lt;h1&gt;CLI世界的潜规则&lt;/h1&gt;
&lt;p&gt;为了使你的CLI程序不会显得格格不入，在设计CLI程序时要遵守一些潜规则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;良好命名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容易理解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;名字要短&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容易记忆&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必备选项&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的命令行工具都应该提供=-v/--version=和=-h/--help=选项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持安静&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序的输出要"恰到好处"，让用户/其他程序明确知道必要的信息，又不过分“啰嗦”。过多的输出即会浪费系统资源和带宽，也会让用户感觉不舒服，更重要的是会使得其他程序的处理逻辑变得复杂。以下的原则有利于保持安静：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要输出无关的信息，比如版本号、作者名------除非用户要求&lt;/li&gt;
&lt;li&gt;对于很明确的结果，不需要再提醒用户。只应提示例外(exception)情况&lt;/li&gt;
&lt;li&gt;不需要告诉用户输出的是什么东西------用户会知道的&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如有必要，可以提供=-v/--verbose=和=-q/--quiet=选项，供用户选择&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;明确要求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在基于行的交互式CLI中，需要用户输入时要给出明确的提示，比如：&lt;/p&gt;
&lt;p&gt;=Do you really want to do this (y/n)?=&lt;/p&gt;
&lt;p&gt;=Enter a date (YYYY-MM-DD):=&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持管道&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序应该支持从管道或文件重定向中读取数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果文件名作为参数传递给程序，就读取文件的内容作为输入&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有提供这样的参数，就从标准输入中读取，一直到 CTRL+D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能单一&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UNIX哲学中重要的一条原则就是：每个程序只做一件事情，并把它做好。&lt;/p&gt;
&lt;p&gt;复杂的功能通过程序间的配合完成，而为了与其他的程序配合，要尽量支持管道和重定向。&lt;/p&gt;
&lt;p&gt;既然“只做一件事”，就要“做好一件事”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遵循惯例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UNIX中命令行参数会有一些惯例，比如=-=后面的单字母选项可以连用（如=ls -Al=),
=--=后面使用多字母选项等；此外，遵循已经被广泛使用的命令的参数，也会容易被接受。&lt;/p&gt;
&lt;h1&gt;CLI支持库&lt;/h1&gt;
&lt;p&gt;CLI是如此重要，以至于很多语言/平台都提供了开发CLI的支持库，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;python的optparse和argparse&lt;/p&gt;
&lt;p&gt;argparse更先进，旨在替代optparse，但是从python2.7开始才支持。如果希望在比较旧的linux上运行(通常支持python2.4)，最好还是使用optparse。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java的Apache Commons CLI&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Apache karaf的karaf-command-archetype&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;python的TUI支持库&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://urwid.org/index.html"&gt;Urwid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="CLI"></category></entry><entry><title>交易策略的基本检验</title><link href="http://holbrook.github.io/2014/01/05/verificating_a_trade_system.html" rel="alternate"></link><published>2014-01-05T00:00:00+08:00</published><updated>2014-01-05T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-01-05:/2014/01/05/verificating_a_trade_system.html</id><summary type="html">&lt;p&gt;交易策略在其生命周期中要经历过多次检验。这些检验通常需要经过统计分析。最基本的检验是不考虑交易成本、指令类型、突发事件、涨跌停和跳空、回波效应等外部因素的影响，只考虑操作信号自身的统计分析指标。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;前提和假设&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;信号发生时机&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常，交易系统无法实时获取分笔数据，而是获取某一个时间段的&lt;a href="/2013/12/18/quotation_model.html#menuIndex1"&gt;成交数据&lt;/a&gt;。每个时间段（比如5分钟，1天）作为一个成交周期。
   由于交易策略都是对成交数据进行事后分析，所以信号通常会滞后一个交易周期产生。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;成交价格&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本检验暂时不考虑”无法成交“（比如涨跌停）的情况，但是为了检验的严格性，需要采取”最不利“的价格作为成交价格。即如果是买入信号，取交易周期内的最高价作为成交价格；如果是卖出信号取交易周期内的最低价作为成交价格。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;样本量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了减小随机误差的影响，每个样本至少要包含30对买入/卖出的交易，即至少要涵盖30个交易周期。&lt;/p&gt;
&lt;h1&gt;机会的度量&lt;/h1&gt;
&lt;p&gt;交易策略最根本的指标就是获利的机会。统计学中，用&lt;a href="/2013/06/07/statistics_intro_4.html"&gt;概率和分布&lt;/a&gt;来度量机会。相应的，对交易策略的获利机会的度量需要确定以下几个指标：&lt;/p&gt;
&lt;table style="border-collapse: collapse;" border="2" frame="hsides" rules="groups" cellspacing="0" cellpadding="6"&gt;
&lt;thead&gt;
&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;总量&lt;/th&gt;&lt;th&gt;比率&lt;/th&gt;&lt;th&gt;分布&lt;/th&gt;&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;金额类&lt;/td&gt;
&lt;td&gt;净利，最大资本金损失程度&lt;/td&gt;
&lt;td&gt;平均盈利额/平均亏损额&lt;/td&gt;
&lt;td&gt;最大盈利/亏损额&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;次数类&lt;/td&gt;
&lt;td&gt;交易周期&lt;/td&gt;
&lt;td&gt;盈利（次数）比率&lt;/td&gt;
&lt;td&gt;盈利次数分布，最大连续盈利/亏损次数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;净利&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;净利 = 获利额 - 亏损额 - 交易成本（在基本分析中交易成本=0）&lt;/p&gt;
&lt;p&gt;净利考察一个交易策略是否为盈利的策略。净利为负的策略一定不可用。但净利的大小不是最重要的指标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平均盈利额/平均亏损额&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;平均盈利额应大于平均亏损额，否则说明该策略不可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;盈利（次数）比率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;盈利比率=盈利次数/交易周期数&lt;/p&gt;
&lt;p&gt;盈利比率也叫”信号成功率“，反映了策略所对应的投资理念：是依赖于偶然的巨额获利，还是依赖于多次小额获利。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;盈利次数分布&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以考察二项式分布、泊松(Poisson)分布或正态分布。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;盈利标准差&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;标准差越小，说明策略的稳定性越高，越不依赖于偶然的巨额获利。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最大盈利/亏损额&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果最大盈利与平均盈利差距过大，则应视为偶然现象，去除该盈利后重新分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果最大亏损与平均亏损差距过大，则要慎重制定风险控制策略，避免突发事件风险（分析时 &lt;strong&gt;不&lt;/strong&gt; 去除！）&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果最大盈利/亏损所占比重过大，则应怀疑策略的盈利能力和稳定性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最大连续盈利/亏损次数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;连续盈利/亏损会经常出现，这是因为策略是稳定的，但是市场会发生周期性的变化。
  最大连续盈利/亏损次数可以与市场的周期性进行比对。&lt;/p&gt;
&lt;p&gt;结合 &lt;strong&gt;当前&lt;/strong&gt; 盈利/亏损次数 和 &lt;strong&gt;最大&lt;/strong&gt; 盈利/亏损次数，可以决策某次交易的额度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大资本金损失程度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是指资本波峰、波谷间的差额。决定了需要准备的资本金。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交易周期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交易周期决定了交易的频繁程度。交易越频繁则交易成本越高。&lt;/p&gt;
&lt;h1&gt;样本的质量&lt;/h1&gt;
&lt;p&gt;对一个交易策略用不同的时间、不同的交易对象反复多次验证，并根据抽样分布（即各样本的统计量，如均值、中位数、标准差等的分布）的特征，剔除一些不合格的样本，重新对交易策略进行综合评价。&lt;/p&gt;
&lt;h1&gt;波长稳定性&lt;/h1&gt;
&lt;p&gt;理论上来说，在各波长下（日线，5分钟线等），信号成功率应该保持稳定。&lt;/p&gt;</content><category term="交易系统"></category></entry><entry><title>Java依赖注入规范：JSR330</title><link href="http://holbrook.github.io/2013/12/31/jsr330.html" rel="alternate"></link><published>2013-12-31T00:00:00+08:00</published><updated>2013-12-31T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-12-31:/2013/12/31/jsr330.html</id><summary type="html">&lt;p&gt;Java World似乎总会出现一些接口规范，这样做的好处是可以面向接口编程，可以在实现了该接口的产品/组件之间自由切换，避免被厂商绑架。 本文要介绍的JSR330:Dependency Injection for Java，Java依赖注入规范。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;依赖关系&lt;/h1&gt;
&lt;p&gt;在面向对象编程中，我们常常处理依赖。比如ClassA依赖ClassB，通常需要：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ClassA a = new ClassA();
ClassB b = new ClassB();

a.setB(b);
a.xxx();
……
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大量这样的依赖处理会导致高耦合度，并且由于通过硬编码组织对象和资源，代码不具有灵活性。&lt;/p&gt;
&lt;h1&gt;DI和IoC&lt;/h1&gt;
&lt;p&gt;一种更好的处理方式是 &lt;strong&gt;依赖注入&lt;/strong&gt; 。比如上面的例子中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过某种方式声明“ClassA &lt;strong&gt;依赖&lt;/strong&gt; ClassB”&lt;/li&gt;
&lt;li&gt;使用ClassA时，有某种机制自动创建ClassB并将其 &lt;strong&gt;注入&lt;/strong&gt; 到ClassA&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里面，“某种机制”需要一个容器来实现。这个容器叫做"IoC(Inversion of Control)容器"。
之所以叫做“控制反转”，是说不在对象中直接控制，而是由容器控制创建对象、为对象注入其他对象和资源等行为。&lt;/p&gt;
&lt;p&gt;IoC是一种思想，实际上我们遇到的大多数“容器”都有对其内容的控制功能。&lt;/p&gt;
&lt;p&gt;对于前一节的例子，IoC容器可能会有这样一个处理过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建ClassA&lt;/li&gt;
&lt;li&gt;分析ClassA的依赖项，得出其依赖ClassB&lt;/li&gt;
&lt;li&gt;创建ClassB&lt;/li&gt;
&lt;li&gt;将ClassB注入到ClassA&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之后，我们可以直接从容器中获取创建并组装好的ClassA对象，无需任何处理即可使用。&lt;/p&gt;
&lt;p&gt;关于DI和IoC，可以参考Martin Fowler的经典文章：&lt;a href="http://www.martinfowler.com/articles/injection.html"&gt;《Inversion of Control Containers and the Dependency Injection pattern》&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;依赖的描述&lt;/h1&gt;
&lt;p&gt;在DI和IoC的历史上，&lt;a href="http://spring.io/"&gt;Spring&lt;/a&gt;功不可没。可以说，Spring使得DI和IoC称为Java应用开发的主流方式。&lt;/p&gt;
&lt;p&gt;2004年3月，&lt;a href="https://spring.io/blog/2004/03/24/spring-framework-1-0-final-released"&gt;Spring 1.0&lt;/a&gt;
使用外部配置文件(xml)描述对象之间的依赖关系。&lt;/p&gt;
&lt;p&gt;2004年10月，JDK1.5开始支持注解(Annotations)语法。&lt;/p&gt;
&lt;p&gt;2007年3月， &lt;a href="https://code.google.com/p/google-guice/"&gt;Google Guice&lt;/a&gt; 1.0发布，使用annotations作为依赖描述的方式。&lt;/p&gt;
&lt;p&gt;2007年11月，&lt;a href="https://spring.io/blog/2007/11/19/spring-framework-2-5-released"&gt;Spring 2.5&lt;/a&gt;也开始支持annotation。&lt;/p&gt;
&lt;h1&gt;JSR330&lt;/h1&gt;
&lt;p&gt;随着各种IoC容器的出现，依赖的描述方式也五花八门。为了规范和统一，JCP(Java Community Process)于2009年10月发布了
&lt;a href="https://jcp.org/en/jsr/detail?id=330"&gt;JSR330&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;JSR330在javax.inject中规定了依赖注入的标准注解(Annotations)。包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Inject&lt;/code&gt; : 标记为“可注入”。可用于构造器(constructors), 方法(methods)或字段(fields)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Qualifier&lt;/code&gt; : 限定器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Scope&lt;/code&gt; : 标记作用域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Named&lt;/code&gt; : 基于 String 的限定器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Singleton&lt;/code&gt; : 标记为单例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JSR330只规定了依赖注入的描述，对于容器实现未作要求。目前 Spring 、Guice 、Eclipse e4等常用框架已经开始兼容该规范。
JSR-299（Contexts and Dependency Injection for Java EE platform，参考实现 Weld ）在依赖注入上也使用该规范。&lt;/p&gt;
&lt;p&gt;比如，定义两个接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;interface MessageRenderer {
    public void render();

    public void setMessageProvider(MessageProvider provider);

    public MessageProvider getMessageProvider();
}

interface MessageProvider {
    public String getMessage();
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很明显，一个MessageRenderer依赖一个MessageProvider。&lt;/p&gt;
&lt;p&gt;在实现类中，可以使用依赖注入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;StandardOutMessageRenderer&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;MessageRenderer&lt;/span&gt; {

    &lt;span class="nv"&gt;@Inject&lt;/span&gt;
    &lt;span class="nv"&gt;@Named&lt;/span&gt;(&lt;span class="s"&gt;&amp;quot;messageProvider&amp;quot;&lt;/span&gt;)
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;MessageProvider&lt;/span&gt; &lt;span class="n"&gt;messageProvider&lt;/span&gt; = &lt;span class="n"&gt;null&lt;/span&gt;;

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="n"&gt;render&lt;/span&gt;() {
        &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;messageProvider&lt;/span&gt; == &lt;span class="n"&gt;null&lt;/span&gt;) {
            &lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;RuntimeException&lt;/span&gt;(
                    &lt;span class="s"&gt;&amp;quot;You must set the property messageProvider of class:&amp;quot;&lt;/span&gt;
                            + &lt;span class="n"&gt;StandardOutMessageRenderer&lt;/span&gt;.&lt;span class="k"&gt;class&lt;/span&gt;.&lt;span class="n"&gt;getName&lt;/span&gt;());
        }

        &lt;span class="n"&gt;System&lt;/span&gt;.&lt;span class="n"&gt;out&lt;/span&gt;.&lt;span class="n"&gt;println&lt;/span&gt;(&lt;span class="n"&gt;messageProvider&lt;/span&gt;.&lt;span class="n"&gt;getMessage&lt;/span&gt;());
        }

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="n"&gt;setMessageProvider&lt;/span&gt;(&lt;span class="n"&gt;MessageProvider&lt;/span&gt; &lt;span class="n"&gt;provider&lt;/span&gt;) {
        &lt;span class="n"&gt;this&lt;/span&gt;.&lt;span class="n"&gt;messageProvider&lt;/span&gt; = &lt;span class="n"&gt;provider&lt;/span&gt;;
        }

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;MessageProvider&lt;/span&gt; &lt;span class="n"&gt;getMessageProvider&lt;/span&gt;() {
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;.&lt;span class="n"&gt;messageProvider&lt;/span&gt;;
        }

}


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ConfigurableMessageProvider&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;MessageProvider&lt;/span&gt; {

        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; = &lt;span class="s"&gt;&amp;quot;Default message&amp;quot;&lt;/span&gt;;

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;ConfigurableMessageProvider&lt;/span&gt;() {
        }

        &lt;span class="nv"&gt;@Inject&lt;/span&gt;
        &lt;span class="nv"&gt;@Named&lt;/span&gt;(&lt;span class="s"&gt;&amp;quot;message&amp;quot;&lt;/span&gt;)
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;ConfigurableMessageProvider&lt;/span&gt;(&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;) {
                &lt;span class="n"&gt;this&lt;/span&gt;.&lt;span class="n"&gt;message&lt;/span&gt; = &lt;span class="n"&gt;message&lt;/span&gt;;
        }

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="n"&gt;setMessage&lt;/span&gt;(&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;) {
                &lt;span class="n"&gt;this&lt;/span&gt;.&lt;span class="n"&gt;message&lt;/span&gt; = &lt;span class="n"&gt;message&lt;/span&gt;;
        }

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;getMessage&lt;/span&gt;() {
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;;
        }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，ConfigurableMessageProvider的构造函数中依赖一个&lt;code&gt;String&lt;/code&gt;类型的参数。&lt;/p&gt;
&lt;h1&gt;spring实现&lt;/h1&gt;
&lt;p&gt;Spring 3.0开始支持JSR330。下面的例子中，使用spring的classpath scanning功能
(&lt;a href="http://www.infoq.com/articles/spring-2.5-part-1"&gt;从spring2.5开始支持&lt;/a&gt;)，
会自动组装bean。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;beans&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.springframework.org/schema/beans&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;xmlns:context=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.springframework.org/schema/context&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&lt;/span&gt;
&lt;span class="s"&gt;                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

    &lt;span class="nt"&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class="na"&gt;base-package=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;demo&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;message&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;java.lang.String&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;constructor-arg&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;You are running JSR330!&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;static&lt;/span&gt; &lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;String&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt; &lt;span class="nt"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;GenericXmlApplicationContext&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;GenericXmlApplicationContext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;classpath:jsr330.xml&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;refresh&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MessageRenderer&lt;/span&gt; &lt;span class="n"&gt;renderer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBean&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;messageRenderer&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;MessageRenderer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;renderer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;render&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="Java"></category></entry><entry><title>CEP中的时间推理(Temporal)</title><link href="http://holbrook.github.io/2013/12/21/2013-12-21-Temporal_of_CEP.html" rel="alternate"></link><published>2013-12-21T00:00:00+08:00</published><updated>2013-12-21T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-12-21:/2013/12/21/2013-12-21-Temporal_of_CEP.html</id><summary type="html">&lt;p&gt;时间推理(Temporal)是CEP中特有的条件判断(LHS)。本文介绍13种时间推理运算符及其DRL表示&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="/2012/11/06/about_cep.html"&gt;CEP&lt;/a&gt;中的&lt;a href="/2013/12/21/event_in_CEP.html"&gt;事件(Event)&lt;/a&gt;具有两个与时间相关的属性。一个是timestamp，标记事件发生的时间；另一个是duration，标记事件持续的时间间隔。&lt;/p&gt;
&lt;p&gt;由这两个时间属性，还可以计算出事件结束的事件。&lt;/p&gt;
&lt;p&gt;时间推理(Temporal)是CEP中特有的条件判断(&lt;a href="/2012/12/06/rule_language.html#menuIndex3"&gt;LHS&lt;/a&gt;)，其判断的要素正是基于事件的上述时间属性。&lt;/p&gt;
&lt;p&gt;Allen在《An Interval-based Representation of Temporal Knowledge》中描述了13种时间推理的运算符。&lt;/p&gt;
&lt;p&gt;下面用DRL语言介绍这13种运算符。其中，运算符的参数格式均为&lt;code&gt;[#d][#h][#m][#s][#[ms]]&lt;/code&gt;。比如&lt;code&gt;3m30s&lt;/code&gt;、&lt;code&gt;4m&lt;/code&gt;等。&lt;/p&gt;
&lt;h1&gt;After 和 Before(之前和之后)&lt;/h1&gt;
&lt;p&gt;&lt;img alt="After 和 Before" src="images/rule-engine/temporal-after_and_before.png"&gt;&lt;/p&gt;
&lt;p&gt;```
  // x∈[a,b]时，满足以下条件
  //A发生在B之前
  $eventA : EventA( this before[a,b] $eventB )
  //B发生在A之后
  $eventB : EventB( this after[a,b] $eventA )&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有给出参数，则a=1ms, b=+∞&lt;/li&gt;
&lt;li&gt;如果只给出一个参数a,则b=+∞&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Coincides（同时发生）&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Coincides" src="images/rule-engine/temporal-coincides.png"&gt;&lt;/p&gt;
&lt;p&gt;```
  // x∈[0,a]，且y∈[0,b]时，满足以下条件
  $eventA : EventA( this coincides[a,b] $eventB )
  $eventB : EventB( this coincides[a,b] $eventA )&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果只给出一个参数a,则b=a&lt;/li&gt;
&lt;li&gt;如果不给出参数，则a=0,b=0&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;During 和 Includes（包含）&lt;/h1&gt;
&lt;p&gt;&lt;img alt="During 和 Includes" src="images/rule-engine/temporal-during.png"&gt;&lt;/p&gt;
&lt;p&gt;```
  // x∈[a,b]，且y∈[c,d]时，满足以下条件
  //A在B期间发生
  $eventA : EventA( this during[a,b,c,d] $eventB )
  //B包含A
  $eventB : EventB( this includes[a,b,c,d] $eventA )&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果只给出二个参数a,b,则c=a,d=b&lt;/li&gt;
&lt;li&gt;如果只给出一个参数b,则a=0,c=0,d=b&lt;/li&gt;
&lt;li&gt;如果不给出参数，则a=0,b=+∞, c=0,d=+∞&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Finishes 和 Finished by（同时结束）&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Finishes 和 Finished by" src="images/rule-engine/temporal-finishes.png"&gt;&lt;/p&gt;
&lt;p&gt;```
  // x∈[0,a]时，满足以下条件
  //A在B之后开始，和B同时结束
  $eventA : EventA( this finishes[a] $eventB )
  //B在A之前开始，和B同时结束
  $eventB : EventB( this finishedby[a] $eventA )&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不给出参数，则a=0&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Meets 和 Met by（相邻）&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Meets 和 Met by" src="images/rule-engine/temporal-after_and_before.png"&gt;&lt;/p&gt;
&lt;p&gt;```
  // x∈[0,a]时，满足以下条件
  //A结束时B开始
  $eventA : EventA( this meets[a] $eventB )
  //A结束时B开始
  $eventB : EventB( this metby[a] $eventA )&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有给出参数，则a=0&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Overlaps 和 Overlappd by（相交）&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Overlaps 和 Overlappd by" src="images/rule-engine/temporal-overlaps.png"&gt;&lt;/p&gt;
&lt;p&gt;```
  // x∈[a,b]时，满足以下条件
  //A在B之前开始，在B之后结束
  $eventA : EventA( this overlaps[a,b] $eventB )
  //B在A之后开始，在A之前结束
  $eventB : EventB( this overlappedby[a,b] $eventA )&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果只给出一个参数b,则a=0&lt;/li&gt;
&lt;li&gt;如果不给出参数，则a=0,b=0&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Starts 和 Started by（同时开始）&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Starts 和 Started by" src="images/rule-engine/temporal-starts.png"&gt;&lt;/p&gt;
&lt;p&gt;```
  // x∈[0,a]时，满足以下条件
  //A和B同时开始，A先结束
  $eventA : EventA( this starts[a] $eventB )
  //B和A同时开始，B后结束
  $eventB : EventB( this startedby[a] $eventA )&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不给出参数，则a=+∞&lt;/li&gt;
&lt;/ul&gt;</content><category term="CEP"></category></entry><entry><title>Drools规则引擎API概述</title><link href="http://holbrook.github.io/2013/12/20/drools_API.html" rel="alternate"></link><published>2013-12-20T00:00:00+08:00</published><updated>2013-12-20T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-12-20:/2013/12/20/drools_API.html</id><summary type="html">&lt;p&gt;规则引擎中，将知识表达为规则（rules），要分析的情况定义为事实（facts）。二者在内存中的存储分别称为Production Memory和Working Memory。在外围，还会有一个执行引擎（Execution Engine）。
与此对应，规则引擎API也分成三个部分。在Drools中，分别叫做Knowledge API，Fact API和Execution API。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="/2012/03/20/rule_engine_1.html"&gt;如前所述&lt;/a&gt;，
规则引擎中，将知识表达为规则（rules），要分析的情况定义为事实（facts）。二者在内存中的存储分别称为Production Memory和Working Memory。在外围，还会有一个执行引擎（Execution Engine）。&lt;/p&gt;
&lt;p&gt;与此对应，规则引擎API也分成三个部分。在Drools中，分别叫做Knowledge API，Fact API和Execution API。&lt;/p&gt;
&lt;h1&gt;Knowledge API&lt;/h1&gt;
&lt;p&gt;Drools将知识库(KnowledgeBase)作为&lt;a href="/2012/12/07/jsr94.html"&gt;JSR94&lt;/a&gt;中的规则执行集(RuleExecutionSet)。知识库中的知识以包(KnowledgePackage)为单位组合而成。每个包中聚合多个规则(Rule)。&lt;/p&gt;
&lt;p&gt;通常，一个包中的内容会在一个或多个资源(Resource)中保存。资源的类型可以有很多种,如.drl 文件、.dslr 文件或 xls 文件等。&lt;/p&gt;
&lt;p&gt;规则包还可以从规则流(rule flow) 文件中获取。&lt;/p&gt;
&lt;p&gt;&lt;img alt="KnowledgeBase" src="images/rule-engine/KnowledgeBase.png"&gt;&lt;/p&gt;
&lt;p&gt;与此对应，Drools定义了一组Knowledge API来操作知识库。&lt;/p&gt;
&lt;p&gt;&lt;img alt="KnowledgeBase" src="images/rule-engine/KnowledgeAPI.png"&gt;&lt;/p&gt;
&lt;p&gt;构建知识库的一般过程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过ResourceFactory获取资源。可以从Classpath、URL、File、ByteArray、Reader等输入源中获取&lt;/li&gt;
&lt;li&gt;构建KnowledgeBuilder，将资源添加到KnowledgeBuilder中。KnowledgeBuilder通常由KnowledgeBuilderFactory创建&lt;/li&gt;
&lt;li&gt;从KnowledgeBuilder中获取规则包&lt;/li&gt;
&lt;li&gt;创建KnowledgeBase，可以通过KnowledgeBaseConfiguration定义KnowledgeBase的一些属性，默认的配置位于drools-core-VERSION.jar 包下 META-INF/drools.default.rulebase.conf 文件中&lt;/li&gt;
&lt;li&gt;将规则包添加到KnowledgeBase&lt;/li&gt;
&lt;li&gt;为KnowledgeBase添加KnowledgeBaseEventListener，可以监控KnowledgeBase中的事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;p&gt;{% highlight java %}&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;KnowledgeBase&lt;/span&gt; &lt;span class="nt"&gt;buildKBase&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;Resource&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ResourceFactory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newClassPathResource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello.drl&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Demo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;KnowledgeBuilder&lt;/span&gt; &lt;span class="n"&gt;kbuilder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;KnowledgeBuilderFactory&lt;/span&gt;
            &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newKnowledgeBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;kbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ResourceType&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DRL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;validate&lt;/span&gt;
    &lt;span class="n"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hasErrors&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;规则中存在错误,错误消息如下:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;KnowledgeBuilderErrors&lt;/span&gt; &lt;span class="n"&gt;kbuidlerErrors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getErrors&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kbuidlerErrors&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hasNext&lt;/span&gt;&lt;span class="p"&gt;();)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;

    &lt;span class="nt"&gt;Collection&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;KnowledgePackage&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;kpackages&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;kbuilder&lt;/span&gt;&lt;span class="nc"&gt;.getKnowledgePackages&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="nt"&gt;KnowledgeBaseConfiguration&lt;/span&gt; &lt;span class="nt"&gt;kbConf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
            &lt;span class="nt"&gt;KnowledgeBaseFactory&lt;/span&gt;&lt;span class="nc"&gt;.newKnowledgeBaseConfiguration&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="nt"&gt;kbConf&lt;/span&gt;&lt;span class="nc"&gt;.setProperty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;org.drools.sequential&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;KnowledgeBase&lt;/span&gt; &lt;span class="nt"&gt;kbase&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;KnowledgeBaseFactory&lt;/span&gt;&lt;span class="nc"&gt;.newKnowledgeBase&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="nt"&gt;KnowledgeBase&lt;/span&gt; &lt;span class="nt"&gt;kbase&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
            &lt;span class="nt"&gt;KnowledgeBaseFactory&lt;/span&gt;&lt;span class="nc"&gt;.newKnowledgeBase&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;kbConf&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="nt"&gt;kbase&lt;/span&gt;&lt;span class="nc"&gt;.addKnowledgePackages&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;kpackages&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="nt"&gt;return&lt;/span&gt; &lt;span class="nt"&gt;kbase&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;Fact API&lt;/h1&gt;
&lt;p&gt;要操作Working Memory，首先要建立规则引擎的一个会话。Drools中的有状态会话和无状态会话分别为StatefulKnowledgeSession和StatelessKnowledgeSession，都可以由KnowledgeBase建立。&lt;/p&gt;
&lt;p&gt;通过会话可以进行操作Fact对象，执行规则等交互，例如：&lt;/p&gt;
&lt;p&gt;{% highlight java %}&lt;/p&gt;
&lt;p&gt;KnowledgeBase kbase = buildKBase();&lt;/p&gt;
&lt;p&gt;StatefulKnowledgeSession statefulKSession=kbase.newStatefulKnowledgeSession();
statefulKSession.setGlobal("globalTest", new Object());&lt;/p&gt;
&lt;p&gt;statefulKSession.insert(new Object());
statefulKSession.fireAllRules();
statefulKSession.dispose();&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;StatefulKnowledgeSession中，insert()方法、fireAllRules()方法和 dispose()方法是分开执行的，这个过程中可以进行一定的控制，
而StatelessKnowledgeSession不同，在无状态会话中，上述三个方法被合并为execute()方法，不能分开调用。如果要插入多个Fact对象，只能使用集合，比如：&lt;/p&gt;
&lt;p&gt;{% highlight java %}
StatelessKnowledgeSession statelessKSession=kbase.newStatelessKnowledgeSession();
ArrayList list=new ArrayList();
list.add(new Object());
list.add(new Object());
statelessKSession.execute(list);&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;这样的特点决定了，无状态会话适合推演和分析，需要事先知道所有的事实(Fact)；而有状态会话可以随时增加事实并进行批评，适合实际应用。&lt;/p&gt;
&lt;p&gt;无状态会话中还可以使用execute(Command cmd)方法。比如，如果要在无状态会话中插入一个List，可以用CommandFactory生成一个关于List的Command:&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight java %}
statelessKSession.execute(CommandFactory.newInsert(list));&lt;/p&gt;
&lt;p&gt;同样，无状态会话中如果要设置global，也需要使用Command:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
ArrayList&lt;Command&gt; list=new ArrayList&lt;Command&gt;();&lt;/p&gt;
&lt;p&gt;list.add(CommandFactory.newInsert(new Object()));
list.add(CommandFactory.newInsert(new Object()));&lt;/p&gt;
&lt;p&gt;list.add(CommandFactory.newSetGlobal("key1", new Object()));
list.add(CommandFactory.newSetGlobal("key2", new Object()));&lt;/p&gt;
&lt;p _="%" endhighlight&gt;statelessKSession.execute(CommandFactory.newBatchExecution(list)) ;&lt;/p&gt;
&lt;h1&gt;Execution API&lt;/h1&gt;
&lt;p&gt;插入到WorkingMemory中的对象，并不是克隆，而是对原对象的引用。这就意味着引擎中可以改变外部的对象，这是引擎与外部数据交互的一个通道。&lt;/p&gt;
&lt;p&gt;此外，insert()方法还会返回一个FactHandler，作为引擎中该Fact对象的一个句柄。&lt;/p&gt;
&lt;p&gt;最后，session上可以注册AgendaEventListener、ProcessEventListener和WorkingMemoryEventListener，这也是常用的交互方式。
比如WorkingMemoryEventListener可以监听Fact对象变化的事件：&lt;/p&gt;
&lt;p&gt;{% highlight java %}
public interface WorkingMemoryEventListener
    extends
    EventListener {
    void objectInserted(ObjectInsertedEvent event);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void objectUpdated(ObjectUpdatedEvent event);

void objectRetracted(ObjectRetractedEvent event);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;</content><category term="规则引擎"></category></entry><entry><title>使用Oracle Berkeley DB持久化股票行情数据</title><link href="http://holbrook.github.io/2013/12/19/2013-12-19-Berkeley_DB.html" rel="alternate"></link><published>2013-12-19T00:00:00+08:00</published><updated>2013-12-19T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-12-19:/2013/12/19/2013-12-19-Berkeley_DB.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;关系数据库，数据文件 还是 NoSQL&lt;/h1&gt;
&lt;p&gt;股票行情数据具有如下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据量大&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于分析来说，至少需要5分钟数据。如果每天交易时间为4小时，每年250个交易日，则一支股票一年的行情数据量为60/5&lt;em&gt;4&lt;/em&gt;250= 12k。20年则为240k。如果是1分钟数据，则20年的数据量为240k*5 = 1.2M。&lt;/p&gt;
&lt;p&gt;所以，如果用于分析，行情数据将是百万量级。如果记录3000只股票/指数的数据，数据量会非常大。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据很少变化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于都是历史数据，行情数据很少需要修改。主要的操作是查询和增加。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据结构简单&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主要考虑&lt;a href="/2013/12/18/quotation_model.html#menuIndex2"&gt;成交数据&lt;/a&gt;，是一种简单的一维结构。价格数据只在发生交易信号时有一定的参考意义，不需要保留所有的历史记录。&lt;/p&gt;
&lt;p&gt;由于行情数据的这些特点，通常不适合使用关系数据库。传统上一般采用数据文件进行存储。&lt;/p&gt;
&lt;p&gt;但是用数据文件需要自己处理写入锁，随机读写，序列化等问题，比较麻烦。于是&lt;a href="/2013/12/18/nosql_list.html#menuIndex1"&gt;NoSQL&lt;/a&gt;成了比较好的一种选择。&lt;/p&gt;
&lt;p&gt;对于单机的分析软件，&lt;a href="/2013/12/18/nosql_list.html#menuIndex2"&gt;NoSQL选型要素&lt;/a&gt;为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key/value儲存&lt;/li&gt;
&lt;li&gt;支持持久化&lt;/li&gt;
&lt;li&gt;支持嵌入式&lt;/li&gt;
&lt;li&gt;接口方便&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Oracle Berkeley DB&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://www.oracle.com/technetwork/cn/products/berkeleydb/overview/index.html"&gt;Berkeley DB&lt;/a&gt;是满足上述4点要求的比较好的一款产品。Berkeley DB分为BDB、BDB Java版和BDB XML版。其总体架构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Berkeley DB" src="images/trade-system/berkeley-db.png"&gt;&lt;/p&gt;
&lt;p&gt;BDB的三个版本的功能不完全相同。&lt;/p&gt;
&lt;p&gt;我选择BDB Java版，不支持SQL API和XQuery API，可以使用底层的键/值API、Java 直接持久层 (DPL) API和Java 集合 API。三种API的应用场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 Java 类是用来代表应用中的域对象(domain objects),也就是说,该模式是相对 稳定的,建议用直接持久层。&lt;/li&gt;
&lt;li&gt;当在Berkeley DB和Berkeley DB Java 版之间移植应用程序时,或当实现自己的 动态模式(举例来说,一个 LDAP 服务器),那么建议用基础 API。您也可能喜欢使用这 个基础API如果您有极少数域类(domain class)。&lt;/li&gt;
&lt;li&gt;集合API有利于和外部组件交互,因为它遵从Java集合框架标准。继而,和基础API 以及直接持久层结合后会很有用。您可能会喜欢这个 API,因为它提供了熟悉的 Java 集 合接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在行情数据的持久化中，可以选用直接持久层（DPL）。直接持久层API 可以持久化以及还原相互关联的 Java 对象，但是比ORM更加简单高效。&lt;/p&gt;
&lt;h1&gt;实现过程&lt;/h1&gt;
&lt;h2&gt;获取开发包&lt;/h2&gt;
&lt;p&gt;可以从&lt;a href="http://www.oracle.com/technetwork/cn/products/berkeleydb/downloads/index.html"&gt;这里&lt;/a&gt;下载需要的jar包，也可以使用maven：&lt;/p&gt;
&lt;p&gt;{% highlight xml %}&lt;/p&gt;
&lt;p&gt;&lt;dependency&gt;
      &lt;groupId&gt;com.sleepycat&lt;/groupId&gt;
      &lt;artifactId&gt;je&lt;/artifactId&gt;
      &lt;version&gt;5.0.73&lt;/version&gt;
&lt;/dependency&gt;&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;如果要使用最新版（目前的最新版是5.0.97），需要引入oracle的maven库：&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight xml %}
&lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;oracleReleases&lt;/id&gt;
      &lt;name&gt;Oracle Released Java Packages&lt;/name&gt;
      &lt;url&gt;http://download.oracle.com/maven&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;&lt;/p&gt;
&lt;h2&gt;定义持久化模型&lt;/h2&gt;
&lt;h3&gt;实体和值对象&lt;/h3&gt;
&lt;p&gt;Berkeley DB支持DDD(领域驱动设计)中的实体和值对象的持久化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实体：拥有长期不变的标识符,可以被跟踪的对象。&lt;/li&gt;
&lt;li&gt;值对象：没有标识符，主要关注其属性的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在BDB中，分别使用 &lt;strong&gt;@Entity&lt;/strong&gt; 和 &lt;strong&gt;@Persistent&lt;/strong&gt; 来声明实体和值对象。
声明了 &lt;strong&gt;@Persistent&lt;/strong&gt; 的对象可以直接作为 &lt;strong&gt;@Entity&lt;/strong&gt; 对象中的属性使用。&lt;/p&gt;
&lt;p&gt;任何Java类一旦增加了持久化声明，其所有字段（任何作用域）都会被持久化。需要持久化的类需要缺省的无参数构造函数。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;{% highlight java %}&lt;/p&gt;
&lt;p&gt;@Entity
public class Transaction {
    ……
    public OHLC ohlc;
    ……
}&lt;/p&gt;
&lt;p&gt;@Persistent
public class OHLC {
    public float open,high,low,close;
}&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h3&gt;主键和“次键”声明&lt;/h3&gt;
&lt;p&gt;每个实体类(@Entity)可以定义一个主键(PrimaryKey)和多个次键(SecondaryKey)，从而可以按照主键或次键进行索引。例如：&lt;/p&gt;
&lt;p&gt;{% highlight java %}&lt;/p&gt;
&lt;p&gt;@Entity
public class Security implements Instrument{
    @PrimaryKey
    private String code;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;@SecondaryKey(relate=Relationship.ONE_TO_ONE)
private String name;
……
&lt;/pre&gt;&lt;/div&gt;


&lt;p _="%" endhighlight&gt;}&lt;/p&gt;
&lt;h3&gt;关联关系&lt;/h3&gt;
&lt;p&gt;关联关系也是通过次键(SecondaryKey)声明的。需要同时指定多重性（relate）和关联到的实体（relatedEntity）。
relate可以是ONE_TO_ONE,ONE_TO_MANY,MANY_TO_ONE或MANY_TO_MANY(在com.sleepycat.persist.model.Relationship中定义)。&lt;/p&gt;
&lt;p&gt;需要注意的是，次键的属性类型需要是relatedEntity指定的对端实体的主键类型，而不能直接使用对端实体。&lt;/p&gt;
&lt;p&gt;如果relate是ONE_TO_MANY或MANY_TO_MANY，可以使用集合类型。比如（不属于股票行情数据模型，而是BDB官方例子）：&lt;/p&gt;
&lt;p&gt;{% highlight java %}&lt;/p&gt;
&lt;p&gt;@Entity
class Employer {
    @PrimaryKey(sequence="ID")
    long id;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;@SecondaryKey(relate=ONE_TO_ONE) String name;
……
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;@Entity
class Person {
    @PrimaryKey
    String ssn;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;@SecondaryKey(relate=MANY_TO_ONE, relatedEntity=Person.class)
String parentSsn;

@SecondaryKey(relate=ONE_TO_MANY)
Set&amp;lt;String&amp;gt; emailAddresses = new HashSet&amp;lt;String&amp;gt;();

@SecondaryKey(relate=MANY_TO_MANY, relatedEntity=Employer.class, onRelatedEntityDelete=NULLIFY)
Set&amp;lt;Long&amp;gt; employerIds = new HashSet&amp;lt;Long&amp;gt;();
……
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h2&gt;使用DPL API&lt;/h2&gt;
&lt;h3&gt;设计Accessor(TODO)&lt;/h3&gt;
&lt;p&gt;类似于DAO，BDB中通常将对实体的访问封装到Accessor中。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;EntityStore&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CRUD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问关联对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过索引可以得到关联的对象，无论是单个关联对象还是集合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关联到单个对象&lt;/li&gt;
&lt;li&gt;关联到集合&lt;/li&gt;
&lt;/ul&gt;
&lt;p _="%" endhighlight&gt;{% highlight java %}
EntityCursor&lt;Person&gt; employees = dao.personByEmployerIds.subIndex(gizmoInc.id).entities();
try {
    for (Person employee : employees) {
System.out.println(employee.ssn + ' ' + employee.name); }
} finally {
    employees.close();
}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等值连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 EntityJoin 类可以进行等值连 接(equality join)操作。&lt;/p&gt;
&lt;p&gt;比如，以下代码查询所有Bob的孩子中为gizmo公司工作的 员工:&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight java %}
EntityJoin&lt;String,Person&gt; join = new EntityJoin(dao.personBySsn);
join.addCondition(dao.personByParentSsn, "111-11-1111"); join.addCondition(dao.personByEmployerIds, gizmoInc.id);
ForwardCursor&lt;Person&gt; results = join.entities(); try {
for (Person person : results) { System.out.println(person.ssn + ' ' + person.name);
}
} finally {
    results.close();
}&lt;/p&gt;
&lt;h3&gt;建立连接&lt;/h3&gt;
&lt;h3&gt;事务支持&lt;/h3&gt;
&lt;p _="%" endhighlight&gt;{% highlight java %}
Transaction txn = env.beginTransaction(null, null); dao.employerById.put(txn, gizmoInc); dao.employerById.put(txn, gadgetInc);
txn.commit();&lt;/p&gt;
&lt;h3&gt;模型变化&lt;/h3&gt;
&lt;p&gt;对于增加实体或值对象的属性，改变属性类型等变化，一般不需要对BDB进行额外的处理，而是会自动适应。&lt;/p&gt;
&lt;p&gt;对于一些特殊的、无法自动适应的变化，比如重命名字段或优化单个的类(如:使用通用类型,模块复用等改变),可以使用Mutations。&lt;/p&gt;
&lt;p&gt;Mutations 操作是延迟的:只在存取数据时自动改变,故避免了软件升级时大型数据库转换导致的长时间停机。
复杂的类优化可能涉及到多个类,使用 ConversionStore 进行。因而,无论持久化类作出何种 改变,直接持久层都始终提供可靠数据存取。&lt;/p&gt;
&lt;h3&gt;性能选项&lt;/h3&gt;
&lt;p&gt;Berkeley DB在API的很多地方提供了性能调优的选项。常见的包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DatabaseConfig参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p _="%" endhighlight&gt;通过DatabaseConfig参数可以用来调整Berkeley DB引擎的性能。
  比如,可指定内部B树节点的大小来调整性能,通过如下方式来指定:
{% highlight java %}
    DatabaseConfig config = store.getPrimaryConfig(Employer.class);
    config.setNodeMaxEntries(64);
    store.setPrimaryConfig(config);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CRUD操作参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如, “脏读”可通过LockMode参数实现:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Employer employer = employerByName.get(null, &amp;quot;Gizmo Inc&amp;quot;, LockMode.READ_UNCOMMITTED);
&lt;/pre&gt;&lt;/div&gt;</content><category term="交易系统"></category></entry><entry><title>交易策略与规则引擎</title><link href="http://holbrook.github.io/2013/12/19/2013-12-19-trading_strategy.html" rel="alternate"></link><published>2013-12-19T00:00:00+08:00</published><updated>2013-12-19T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-12-19:/2013/12/19/2013-12-19-trading_strategy.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;交易策略的要点&lt;/h1&gt;
&lt;p&gt;&lt;a href="/2013/12/16/trade_system.html"&gt;前面&lt;/a&gt;提到，交易策略是系统化交易的核心。但是要注意的是，风险管理比交易策略要重要10倍。&lt;/p&gt;
&lt;p&gt;交易策略的一些要点整理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交易策略是一套完整的交易规则体系&lt;/li&gt;
&lt;li&gt;这些规则对投资决策的各个环节做出明确规定&lt;/li&gt;
&lt;li&gt;这些规则必须客观、唯一&lt;/li&gt;
&lt;li&gt;所谓完整，至少要包括入场和出场两个规则——完成一个完整的交易周期，入场和出场信号必须确定会发生&lt;/li&gt;
&lt;li&gt;出场策略比入场策略要重要10倍&lt;/li&gt;
&lt;li&gt;越简单的策略越可靠&lt;/li&gt;
&lt;li&gt;要有错误处理机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;交易策略的种类&lt;/h1&gt;
&lt;p&gt;所谓&lt;a href="/2012/03/20/rule_engine_1.html"&gt;规则，规定了一组确定的条件和此条件所产生的结果&lt;/a&gt;。根据条件的类别不同，可以把交易策略分成以下几种：&lt;/p&gt;
&lt;h2&gt;基于技术指标&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;例1&lt;/li&gt;
&lt;li&gt;规则定义&lt;ul&gt;
&lt;li&gt;入场规则：短期均线上穿长期均线&lt;/li&gt;
&lt;li&gt;出场规则：短期均线下穿长期均线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价&lt;/p&gt;
&lt;p&gt;简单但完整的交易策略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;规则定义&lt;ul&gt;
&lt;li&gt;入场规则：RSI&amp;lt;10&lt;/li&gt;
&lt;li&gt;出场规则：RSI&amp;gt;90&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价&lt;/p&gt;
&lt;p&gt;有严重的设计缺陷。因为RSI可能长期不能趋近于某一极值，从而得不到对应的操作信号，长期无法完成完整的买卖周期。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;基于统计分析&lt;/h2&gt;
&lt;p&gt;此类策略要研究市场数据的统计分布特征，需要较强的数学功底&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;例1&lt;/li&gt;
&lt;li&gt;规则定义&lt;ul&gt;
&lt;li&gt;入场规则：跳空高开若干&lt;/li&gt;
&lt;li&gt;出场规则：利润达到x值或收盘价，或者损失达到y止损&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价&lt;/p&gt;
&lt;p&gt;其思想是捕捉跳空开盘对后市的影响&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;规则定义&lt;ul&gt;
&lt;li&gt;入场规则：突破跳空&lt;/li&gt;
&lt;li&gt;出场规则：衰竭跳空&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价
     两个问题：1）跳空不一定会出现，从而导致交易周期不完整；2）过于主观随意&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;规则定义&lt;ul&gt;
&lt;li&gt;入场规则：迪马克波动系数终点&lt;/li&gt;
&lt;li&gt;出场规则：反向迪马克波动系数终点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价&lt;/p&gt;
&lt;p&gt;交易周期不完整&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;基于图形分析&lt;/h2&gt;
&lt;p&gt;这类是最传统、最常见的交易策略&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;例1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规则定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入场规则：维克多突破&lt;/li&gt;
&lt;li&gt;出场规则：反向维克多突破&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价&lt;/p&gt;
&lt;p&gt;简单但完整&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规则定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入场规则：罗斯钩式突破&lt;/li&gt;
&lt;li&gt;出场规则：反向罗斯钩式突破&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价&lt;/p&gt;
&lt;p&gt;完整&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规则定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入场规则：卡尔汉数突破&lt;/li&gt;
&lt;li&gt;出场规则：反向卡尔汉数突破&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例4&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规则定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入场规则：W型反转&lt;/li&gt;
&lt;li&gt;出场规则：M型反转&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价&lt;/p&gt;
&lt;p&gt;不一定会发生，交易周期不完整&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规则定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入场规则：晨星式&lt;/li&gt;
&lt;li&gt;出场规则：昏星式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价&lt;/p&gt;
&lt;p&gt;不一定会发生，交易周期不完整&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;基于数学理论&lt;/h2&gt;
&lt;p&gt;需要较强的金融投资理论背景&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;例1：飞镖系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规则定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入场规则：飞镖击中的股票&lt;/li&gt;
&lt;li&gt;出场规则：持有至规定期限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价&lt;/p&gt;
&lt;p&gt;其收益战胜了华尔街股票分析家，验证了投资学术界的随机行走理论&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例2：以满月为买入信号，以新月为卖出信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是一个以金融占星术理论为基础的交易系统。该方法以月球引力场的变化来解释地球生态系统的周期性变比。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;例3：硬币法——以随机选择过程为基础&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（略）&lt;/p&gt;
&lt;h2&gt;基于基本分析&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;P/E小于某一值时买入，P/E大于某一值时卖出&lt;/li&gt;
&lt;li&gt;收益增长率大于某一值时买入，收益增长率小于某一值时卖出&lt;/li&gt;
&lt;li&gt;每年某月买入白糖合约，若干月后平仓（季节波动）&lt;/li&gt;
&lt;li&gt;新建住房开工率持续上升若干月买入铜合约，若干月后平仓（因果关系）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;基于心理分析&lt;/h2&gt;
&lt;p&gt;例： 传言开始是进场，传言证实后出场&lt;/p&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;p&gt;基于人工智能、神经网络、混沌理论（Chaos)等&lt;/p&gt;
&lt;h1&gt;用规则引擎驱动交易策略&lt;/h1&gt;
&lt;p&gt;尽管要求交易策略要尽可能简单，但是交易信号产生的条件可能五花八门。为了使交易系统具备更好的适应性，还是应该使用&lt;a href="/2012/03/20/rule_engine_1.html"&gt;规则引擎&lt;/a&gt;来驱动。这就需要将交易策略规则化。&lt;/p&gt;
&lt;p&gt;一般来说，交易策略的规则化需要经过确定规则（定性）、确定参数（定量）以及用规则语言描述（实现）三个步骤。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;策略定性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将交易策略表示为条件与交易信号。对于最简单的交易策略，可能只有入场信号和出场信号。但也会有一些稍复杂的情况需要处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于期货交易，入场信号可以区分为“做多”和“做空”，出场信号均为“平仓”&lt;/li&gt;
&lt;li&gt;有些交易策略的入场、出场信号可能会划分出不同的风险级别——风险越高的信号，产生的时间越早，可能的获利越大，但判断失误的风险也更大&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完善的交易系统，对于(正确入场,正确出场)、(正确入场,错误出场)、(错误入场,正确出场)、(错误入场,错误出场)  等情况都要考虑到，针对这些情况都要及时给出交易信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确定参数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将策略中可变的部分定义为参数。这些参数可以在引擎中进行设置，以调整策略的具体行为。&lt;/p&gt;
&lt;p&gt;参数可能要经过实际检验，才能得出最优的参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交易信号都是由某些数据触发，&lt;a href="#menuIndex1"&gt;如前&lt;/a&gt;所述，这些数据可能是行情、指标、基本面等。&lt;/p&gt;
&lt;p&gt;不管是哪种数据，从规则引擎的角度，都需要定义为&lt;a href="/2013/12/21/event_in_CEP.html"&gt;事件(Event)&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规则匹配的结果就是产生某种&lt;a href="/2012/12/06/rule_language.html#menuIndex4"&gt;操作&lt;/a&gt;。
  考虑到交易策略要与后续的&lt;a href=""&gt;资金管理&lt;/a&gt;等策略结合，这里将操作也定义为事件，作为资金管理策略的输入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述规则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用前面定义好的参数、事件和操作，用&lt;a href="http://thinkinside.tk/2012/12/06/rule_language.html"&gt;规则描述语言&lt;/a&gt;将定性的策略描述为定量的规则。&lt;/p&gt;
&lt;h1&gt;实例&lt;/h1&gt;
&lt;p&gt;以“简单算术平均线”策略为例，其实现过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;规则定性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规则1：当短期平均线向上穿越长期平均线时，买入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规则2：当短期平均线向下穿越长期平均线时，卖出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确定参数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个策略中，可以作为参数的变量包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选用哪种价格，比如开盘价、收盘价、最高价、最低价等&lt;/li&gt;
&lt;li&gt;短期和长期均线的长度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为简单起见，这里只把均线的长度作为参数。&lt;/p&gt;
&lt;p&gt;可以在DRL的global部分用全局变量定义规则的参数。这些参数将用于事件属性或规则条件中，用于调整策略的具体行为。如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;global java.lang.Integer SHORT_LENGTH;
  global java.lang.Integer LONG_LENGTH;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;global参数可以使用在规则引擎会话中，使用&lt;a href="/2013/12/20/drools_API.html#menuIndex1"&gt;KnowledgeSession&lt;/a&gt;的&lt;code&gt;setGlobal()&lt;/code&gt;方法进行设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义一个“均线事件”(MAEvent):&lt;/p&gt;
&lt;p&gt;```
  public class MAEvent {&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public Date datetime;
public long duration;

public int length;
public double average;
public double price;



public String toString(){
  return &amp;quot;&amp;quot;+this.getDatetime().toLocaleString()+&amp;quot;:MA&amp;quot;+this.length+&amp;quot;=&amp;quot;+average+&amp;quot;\t(&amp;quot;+price+&amp;quot;)&amp;quot;;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}
  ```&lt;/p&gt;
&lt;p&gt;并在规则文件中进行声明：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import my.package.MAEvent
  ……
  declare MAEvent
    @role(event)
    @timestamp( datetime )
    @duration( duration )
  end&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里使用一个“操作信号事件”(SingalEvent)作为操作，符合条件时将该事件&lt;a href="/2012/12/06/rule_language.html#menuIndex4"&gt;insert&lt;/a&gt;到规则引擎：&lt;/p&gt;
&lt;p&gt;```
  public class SignalEvent extends AbstractEvent{&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public enum SignalType{LONG,SHORT}

public Date datetime;
public long duration;


public SignalType type;
public String strategyName;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}
  ```&lt;/p&gt;
&lt;p&gt;在规则文件中声明：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;declare SignalEvent
    @role(event)
    @timestamp(datetime)
    @duration(duration)
  end&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述规则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;```
  rule "LONG SIGNAL"
      when
          $MA5_1:MAEvent(length==SHORT_LENGTH);
          $MA5_0:MAEvent(length==SHORT_LENGTH,this meets[1d] $MA5_1);
          $MA20_1:MAEvent(length==LONG_LENGTH,this coincides $MA5_1,average&amp;gt;=$MA5_1.average);
          $MA20_0:MAEvent(length==LONG_LENGTH,this meets[1d] $MA20_1,this coincides $MA5_0,
            average&amp;lt;=$MA5_0.average
          );&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;  then&lt;/span&gt;

&lt;span class="x"&gt;    SignalEvent e = new SignalEvent();&lt;/span&gt;
&lt;span class="x"&gt;    e.datetime = &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;MA5_1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;datetime&lt;/span&gt;&lt;span class="x"&gt;;&lt;/span&gt;
&lt;span class="x"&gt;    e.strategyName = &amp;quot;简单移动平均线策略&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;    e.type = SignalEvent.SignalType.LONG;&lt;/span&gt;
&lt;span class="x"&gt;    e.price = &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;MA5_1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;price&lt;/span&gt;&lt;span class="x"&gt;;&lt;/span&gt;
&lt;span class="x"&gt;      insert(e);&lt;/span&gt;

&lt;span class="x"&gt;  System.out.println(e);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;end&lt;/p&gt;
&lt;p&gt;rule "SHORT SIGNAL"
      when
          $MA5_1:MAEvent(length==SHORT_LENGTH);
          $MA5_0:MAEvent(length==SHORT_LENGTH,this meets[1d] $MA5_1);
          $MA20_1:MAEvent(length==LONG_LENGTH,this coincides $MA5_1,average&amp;lt;=$MA5_1.average);
          $MA20_0:MAEvent(length==LONG_LENGTH,this meets[1d] $MA20_1, this coincides $MA5_0,
            average&amp;gt;=$MA5_0.average
          );&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;  then&lt;/span&gt;
&lt;span class="x"&gt;      SignalEvent e = new SignalEvent();&lt;/span&gt;
&lt;span class="x"&gt;    e.datetime = &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;MA5_1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;datetime&lt;/span&gt;&lt;span class="x"&gt;;&lt;/span&gt;
&lt;span class="x"&gt;    e.strategyName = &amp;quot;简单移动平均线策略&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;    e.type = SignalEvent.SignalType.SHORT;&lt;/span&gt;
&lt;span class="x"&gt;    e.price = &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;MA5_1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;price&lt;/span&gt;&lt;span class="x"&gt;;&lt;/span&gt;
&lt;span class="x"&gt;      insert(e);&lt;/span&gt;

&lt;span class="x"&gt;      System.out.println(e);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;end
```&lt;/p&gt;</content><category term="交易系统"></category><category term="规则引擎"></category></entry><entry><title>证券行情数据模型</title><link href="http://holbrook.github.io/2013/12/18/2013-12-18-quotation_model.html" rel="alternate"></link><published>2013-12-18T00:00:00+08:00</published><updated>2013-12-18T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-12-18:/2013/12/18/2013-12-18-quotation_model.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;行情数据举例&lt;/h1&gt;
&lt;p&gt;交易系统离不开行情数据。比如，如果访问新浪的股票数据接口：&lt;/p&gt;
&lt;p&gt;http://hq.sinajs.cn/list=sh600133,sh601005&lt;/p&gt;
&lt;p&gt;可能会得到如下的数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;var&lt;/span&gt; &lt;span class="nt"&gt;hq_str_sh600133&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;东湖高新,6.01,6.01,5.91,6.07,5.80,5.92,5.93,8947052,52872049,2000,5.92,57704,5.91,191500,5.90,75000,5.89,142800,5.88,19700,5.93,43750,5.94,51600,5.95,17299,5.96,11445,5.97,2013-12-18,13:56:49,00&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="nt"&gt;var&lt;/span&gt; &lt;span class="nt"&gt;hq_str_sh601005&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;重庆钢铁,2.50,2.50,2.49,2.51,2.48,2.49,2.50,1505600,3764816,448800,2.49,110600,2.48,132500,2.47,206500,2.46,150300,2.45,95501,2.50,447100,2.51,110600,2.52,110800,2.53,136400,2.54,2013-12-18,13:56:49,00&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每只股票返回一组数据。以第一组数据为例，各数据项的含义如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;东湖高新     股票名称&lt;/li&gt;
&lt;li&gt;6.01         今日开盘价（元）&lt;/li&gt;
&lt;li&gt;6.01         昨日收盘价（元）&lt;/li&gt;
&lt;li&gt;5.91         当前价格（元）&lt;/li&gt;
&lt;li&gt;6.07         今日最高价（元）&lt;/li&gt;
&lt;li&gt;5.80         今日最低价（元）&lt;/li&gt;
&lt;li&gt;5.92         买一（元）&lt;/li&gt;
&lt;li&gt;5.93         卖一（元）&lt;/li&gt;
&lt;li&gt;8947052      成交量（股）&lt;/li&gt;
&lt;li&gt;52872049    成交金额（元）&lt;/li&gt;
&lt;li&gt;2000        买一申报量（股）&lt;/li&gt;
&lt;li&gt;5.92        买一出价（元）&lt;/li&gt;
&lt;li&gt;57704       买二申报量（股）&lt;/li&gt;
&lt;li&gt;5.91        买二出价（元）&lt;/li&gt;
&lt;li&gt;191500      买三申报量（股）&lt;/li&gt;
&lt;li&gt;5.90        买三出价（元）&lt;/li&gt;
&lt;li&gt;75000       买四申报量（股）&lt;/li&gt;
&lt;li&gt;5.89        买四出价（元）&lt;/li&gt;
&lt;li&gt;142800      买五申报量（股）&lt;/li&gt;
&lt;li&gt;5.88        买五出价（元）&lt;/li&gt;
&lt;li&gt;19700       卖一申报量（股）&lt;/li&gt;
&lt;li&gt;5.93        卖一报价（元）&lt;/li&gt;
&lt;li&gt;43750       卖二申报量（股）&lt;/li&gt;
&lt;li&gt;5.94        卖二报价（元）&lt;/li&gt;
&lt;li&gt;51600       卖三申报量（股）&lt;/li&gt;
&lt;li&gt;5.95        卖三报价（元）&lt;/li&gt;
&lt;li&gt;17299       卖四申报量（股）&lt;/li&gt;
&lt;li&gt;5.96        卖四报价（元）&lt;/li&gt;
&lt;li&gt;11445       卖五申报量（股）&lt;/li&gt;
&lt;li&gt;5.97        卖五报价（元）&lt;/li&gt;
&lt;li&gt;2013-12-18  日期&lt;/li&gt;
&lt;li&gt;13:56:49,00 时间&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;价格和成交&lt;/h1&gt;
&lt;p&gt;上述的查询结果包含了两种不同的数据：价格(Price)和成交（Transaction)。&lt;/p&gt;
&lt;p&gt;价格是实时数据，记录了某一时点的当前价格（price）和一系列（上面的例子中是五组）的报价(Quote)数据；其中报价又包含了买方的出价（bid)和卖方的要价（offer），通常可能表示为“0.6712/5”、“0.2345/”，“/0.4352”等。&lt;/p&gt;
&lt;p&gt;成交是阶段数据，记录了某一个时段（上面的例子中是一天）内的开盘价(open)，收盘价（close）,最高价（high），最低价（low）；
以及该段时间内总的成交量（volume）和成交价格（amount）。由于(开盘价,收盘价,最高价,最低价）是很常用的一种结构，比如画蜡烛图时就会使用这种结构，所以将其封装为一个&lt;a href="/2013/01/01/money.html#menuIndex6"&gt;值对象&lt;/a&gt;： &lt;strong&gt;OHLC&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;不管是价格信息还是成交信息，都关联到某一证券（Security）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/analysis-pattern/price_and_transaction.png"&gt;&lt;/p&gt;
&lt;h1&gt;场景&lt;/h1&gt;
&lt;p&gt;在上面的模型中，价格和成交直接关联到时点。&lt;/p&gt;
&lt;p&gt;实际应用中，经常会需要将一些价格或成交聚合在一起。比如，某个市场、某个板块的所有股票的价格。而这种聚合通常要指定到某个时间点才有意义。&lt;/p&gt;
&lt;p&gt;可以把这种聚合叫做场景（Scenario），场景关联到某一时间点（TimePoint)。一个场景可以有多个场景元素（ScenarioElement），场景元素作为证券和其他因素之间的关联，聚合到与时点相关的场景中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/analysis-pattern/scenario.png"&gt;&lt;/p&gt;
&lt;p&gt;场景提供了一个把所有因素综合在一起的基础，从而可以很方便的在不同的情况之间进行比较。这就有较高的实用性。&lt;/p&gt;
&lt;p&gt;比如，在跨市场套利中，可以针对不同的市场定义不同的场景，并将场景关联到指定的市场，从而在不同市场之间进行比较。&lt;/p&gt;
&lt;p&gt;在比如在交易系统的风险管理中，可以在多种可能的情况之间进行对比分析。&lt;/p&gt;
&lt;p&gt;有了场景和场景元素的定义，则价格和成交都是场景元素的一种实现：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/analysis-pattern/quotation.png"&gt;&lt;/p&gt;
&lt;h1&gt;多数据源&lt;/h1&gt;
&lt;p&gt;实际应用中，可能需要从多个数据源获取数据。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/analysis-pattern/multi_source.png"&gt;&lt;/p&gt;
&lt;h1&gt;价格指标&lt;/h1&gt;
&lt;p&gt;通过其他场景元素计算获取&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/analysis-pattern/indicator.png"&gt;&lt;/p&gt;</content><category term="交易系统"></category></entry><entry><title>系统交易和交易系统</title><link href="http://holbrook.github.io/2013/12/16/2013-12-16-trade_system.html" rel="alternate"></link><published>2013-12-16T00:00:00+08:00</published><updated>2013-12-16T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-12-16:/2013/12/16/2013-12-16-trade_system.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;证券价格的随机性&lt;/h1&gt;
&lt;p&gt;很多人都从股票投机中赚过钱，但是绝少人能够长期赚钱。甚至这些长期赚钱的人中，绝大部分人的成功次数少于50%。这意味着，证券价格的波动具有随机性。&lt;/p&gt;
&lt;p&gt;投资理论界认为，价格的波动具备高度随机性；而投资实务界认为只是部分随机性。&lt;/p&gt;
&lt;p&gt;如果价格的波动具备完全随机性，则意味着数据没有任何记忆性，完全无法通过过去的数据预测未来。就好像抛硬币，即使之前抛出了一千次正面，第一千零一次抛出正、反面的概率依然是各占50%。&lt;/p&gt;
&lt;p&gt;不可否认，证券价格的变化比抛硬币游戏要复杂得多，目前无法证明其具备完全随机性，但是也无法准确发现其变化规律。&lt;/p&gt;
&lt;p&gt;从实践来看，总有人能够从证券投资中稳定获利。尤其近几年一些量化投资方法的成功，又让人看到了通过数学模型获取稳定收益的希望。&lt;/p&gt;
&lt;h1&gt;赌博还是投资？&lt;/h1&gt;
&lt;p&gt;尽管人的天性中都厌恶风险（不确定性），但是又都或多或少喜欢赌博。&lt;/p&gt;
&lt;p&gt;对于证券投机，可以说本质上也是一种赌博。区别在于大多数人仅仅是赌博，而少数人以数学家的方式参与赌博。&lt;/p&gt;
&lt;p&gt;赌博之所以吸引人，在于其概率性。数学家经过思考和技术能够赢得赌博游戏，是因为其对概率和统计学的把握。&lt;/p&gt;
&lt;p&gt;要进行科学的投资/投机，而不是以赌博的心态去进行交易，一定要明确以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;投资的目标是持续稳定获利&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要期望每次交易都是正确的，甚至不要期望成功交易的次数要大于失败的次数。据说，华尔街的顶尖交易员在十年中的平均正确率仅仅是35%左右&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;成功的交易，其收益率不一定高，不要追求单次交易的高回报率——这种事情发生的概率太小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;失败的交易，一定要将其损失控制在合理的范围。失败是常态，但是一定不要把一次失败演变成灾难&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;符合上述行为的投资，就可以称为科学投资，而不是赌博。&lt;/p&gt;
&lt;p&gt;科学投资的精髓就是捕捉高度随机变化中的非随机性。&lt;/p&gt;
&lt;h1&gt;系统化交易&lt;/h1&gt;
&lt;p&gt;要实现科学投资，需要将一段时间内的所有交易看做一系列整体性、系统化的行为，而不是一次次的“率性而为”。这就要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先要有一个交易策略，这个交易策略经过一系列的统计验证，期望值为正。并且明确知道其成功率、最高收益率、最大损失率等一系列关键性的指标&lt;/li&gt;
&lt;li&gt;根据该交易策略的关键指标，结合自身资金情况，制定一个资金管理策略。资金管理策略保证你有足够的筹码将这个游戏玩下去，而不是中途出局&lt;/li&gt;
&lt;li&gt;严格基于交易策略和资金管理策略，进行一系列的选股、择时、执行等操作&lt;/li&gt;
&lt;li&gt;对于每一笔交易，分析其成功或失败的原因是由于概率、心理因素还是模型的缺陷。在一定的时间后根据最新的统计结果修正模型参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;能够做到这些，就可以称之为“系统化交易”。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/trade-system/trade.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选股：筛选交易对象&lt;/li&gt;
&lt;li&gt;择时：对行情进行判断，选择合适的操作时机&lt;/li&gt;
&lt;li&gt;战术：生成正向或反向交易指令&lt;/li&gt;
&lt;li&gt;执行：记录交易结果&lt;/li&gt;
&lt;li&gt;反馈：核算、评估&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;心理因素&lt;/h1&gt;
&lt;p&gt;系统化交易中，最难克服的是心理障碍。请将手放在心口，听我说：&lt;/p&gt;
&lt;p&gt;你能否承认交易策略和资金管理策略是指引你交易行为的唯一准则，爱他、安慰他、尊重他、保护他，像你爱自己一样，无论每次交易是成功、是失败，也无论你听到了市场上多么动听的传言，亦或你的交易遭到了何种的嘲讽？&lt;/p&gt;
&lt;p&gt;先不要急着回答。人性是如此脆弱，以至于你很快就会释放心中的魔鬼，从而将上面的誓言抛之脑后。请问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;两个选择：1）有75%的机会得到1000美元，但有25%的机会什么都得不到。2）确定可以得到700美元。 你会如何选择？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还是两个选择：1）75%的机会付出1000美元，但有25%的机会什么也不用付出。2）确定付出700美元。 你会如何选择？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可能多数人会在第1个问题中选择2），第二个问题中选择1）。实际上，如果计算了期望值，这两个选择都是错的。这就是你心中的魔鬼。&lt;/p&gt;
&lt;p&gt;传言巴菲特有一次打高尔夫的时候球友们跟他打赌：在三天内如果巴菲特打出一次一杆进洞，就给他20000美元，否则巴菲特要付出10美元。但是巴菲特拒绝了。&lt;/p&gt;
&lt;p&gt;关住内心的魔鬼，从概率的角度进行思考，绝不要心存侥幸。这才是科学交易的精神。&lt;/p&gt;
&lt;p&gt;无论成败，恪守交易策略，才能从大量单个交易的偶然中获取总体期望值的必然；无原则，或者有原则而不遵守，就只能停留在一个个的偶然，并且总体结果也是偶然。&lt;/p&gt;
&lt;h1&gt;交易系统的作用&lt;/h1&gt;
&lt;p&gt;除了心理控制的难关，系统化交易过程中需要进行信息收集、信息处理、交易决策、交易计划、交易执行等大量琐碎耗时的事情，这些事情很可能影响你的心态，甚至由于信息的干扰影响决策的正确性。&lt;/p&gt;
&lt;p&gt;此外，系统化交易需要不断对交易策略和资金管理策略不断进行统计分析、优化和参数调整，对于大多数人来说这也是一个难以胜任的工作。&lt;/p&gt;
&lt;p&gt;上述种种，需要某种工具来辅助，姑且称之为“交易系统”。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/trade-system/goal.png"&gt;&lt;/p&gt;
&lt;p&gt;如上图，交易的“铁三角”是交易者、交易资本和交易对象，而交易系统的主要作用是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理交易策略的生命周期，按照交易策略实施交易&lt;/li&gt;
&lt;li&gt;根据风险控制策略进行资金管理&lt;/li&gt;
&lt;li&gt;辅助交易者进行心理控制&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;交易系统的主要功能&lt;/h1&gt;
&lt;h2&gt;交易策略的生命周期管理&lt;/h2&gt;
&lt;p&gt;交易系统最重要的功能应该是对交易策略的整个生命周期进行管理。&lt;/p&gt;
&lt;p&gt;一个交易策略提出后，要经过一系列的阶段，直到最终被废弃。交易策略的生命周期如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/trade-system/lifecycle.png"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;公式化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;交易策略中的所有规则，既包括买卖点的生成规则，也包括交易对象筛选的规则等，必须能够用公式/程序语言客观、准确的表示。&lt;/p&gt;
&lt;p&gt;并提取出所有的变量/事件和参数。变量/事件用于客观事实的输入，参数用于优化。&lt;/p&gt;
&lt;p&gt;当然，对于一些共性的规则，如检查交易对象的流动性和价格波动程度等规则，可以提取出公共的规则，在交易策略中进行引用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统计检验&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用历史数据对交易策略进行检验，得出交易策略的统计学参数和关键指标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外推检验&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用真实的外部数据，进行模拟盘的操作，检验效果，验证参数和指标的变化&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实战检验&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用真实的外部数据，进行实盘操作，检验效果，验证交易策略与交易者之间是否契合&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;监控与维护&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过上述步骤的交易策略，可以用于实战。在实战过程中要不断监控策略的统计学参数和指标是否已经偏离&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在任一环节，如果发现交易策略不能满足要求，可以对参数进行优化&lt;/p&gt;
&lt;h2&gt;辅助决策&lt;/h2&gt;
&lt;p&gt;经过验证的交易策略只是给出合适的交易信号：买入信号或卖出信号。根据交易信号、资金状况、策略的统计指标等因素来决定是否要交易、交易量是多少等等这些交易要素，是一个决策的过程。&lt;/p&gt;
&lt;p&gt;交易系统应该能够为交易决策提供辅助。&lt;/p&gt;
&lt;h2&gt;支持功能&lt;/h2&gt;
&lt;p&gt;前面提到的交易过程中的其他环节，如信息收集、信息处理、交易日志、结果分析、指标计算等，也需要交易系统进行支持。&lt;/p&gt;
&lt;h1&gt;交易策略与交易者&lt;/h1&gt;
&lt;p&gt;同一套交易策略，在不同的交易员手中，效果截然不同。这里面没有对错，而是一个是否适合的问题。&lt;/p&gt;
&lt;p&gt;交易策略仅仅规定了交易信号产生的规则，但是不同的交易员具有不同的交易周期长短、风险承受水平、投资理念等偏好，所以会适合不同的交易策略。&lt;/p&gt;
&lt;p&gt;所谓最适合的就是最好的，对交易员来说，最重要的时期不是妄图找到“最好”的交易策略，而是应该找到最适合自己投资理念的交易策略。&lt;/p&gt;
&lt;p&gt;在符合自己投资理念的前提下，交易过程中要尽量排除不必要的主观性。对于每对交易，不要关注是成功还是失败，而要关注是对的还是错的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符合策略的成功交易是对的；更重要的是符合策略的失败交易也是对的&lt;/li&gt;
&lt;li&gt;偏离策略的失败交易是错的；更重要的是偏离策略的成功交易也是错的&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;最后的迷思&lt;/h1&gt;
&lt;p&gt;尽管我们希望在有限的条件下建立一个科学的模型，从而获得一个正的“预期收益率”（该死的银行理财产品？），但是，我们还是将命运交给了未知：那冥冥中的概率。&lt;/p&gt;
&lt;p&gt;尽管根据&lt;a href="http://wiki.mbalib.com/wiki/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B"&gt;大数定律&lt;/a&gt;，随着交易次数的增多，总体结果会越来越接近事先计算出的期望值，但是&lt;a href="http://wiki.mbalib.com/wiki/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86"&gt;中心极限定理&lt;/a&gt;指出，大量独立随机变量的平均数近似正态分布。&lt;/p&gt;
&lt;p&gt;就我们有限而短暂的生命来说，我们不可能让交易次数达到无穷，去逼近那个理论中的“期望值“，而只能进行有限次数的交易。如果说一套交易策略，由不同的交易者去实践，则每个交易者的最终结果可以看做中心极限定理中的一个样本。&lt;/p&gt;
&lt;p&gt;很遗憾，中心极限定理告诉我们，最终结果是近似正态分布的，也就是说：有限次的策略交易，最终的统计结果仍然是一个概率分布——正所谓谋事在人，成事在天。&lt;/p&gt;</content><category term="交易系统"></category></entry><entry><title>用Ganglia监控集群的性能</title><link href="http://holbrook.github.io/2013/07/30/ganglia.html" rel="alternate"></link><published>2013-07-30T00:00:00+08:00</published><updated>2013-07-30T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-07-30:/2013/07/30/ganglia.html</id><summary type="html">&lt;p&gt;对基础设施的监控主要包括三个方面：状态，性能和可用性。通俗的讲就是：是否在干活，干了多少活，还能干多少。与Cacti、Nagios、Zabbix等工具相比，Ganglia更关注整个集群的性能和可用性。可以用于集群的性能监控、分析和优化。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Ganglia简介&lt;/h1&gt;
&lt;p&gt;对基础设施的监控主要包括三个方面：状态，性能和可用性。通俗的讲就是：是否在干活，干了多少活，还能干多少。&lt;/p&gt;
&lt;p&gt;有很多开源的强大工具可以用于监控，比如
&lt;a href="http://www.cacti.net/"&gt;Cacti&lt;/a&gt;，
&lt;a href="http://www.nagios.org"&gt;Nagios&lt;/a&gt;
以及比较新的
&lt;a href="http://www.shinken-monitoring.org/"&gt;Shinken&lt;/a&gt;和
&lt;a href="http://www.zabbix.com"&gt;Zabbix&lt;/a&gt;。
这些工具的主要功能是状态监控和报警——就像一个合格的监工，随时掌握基础设施是否在干活，发现谁没干活马上报告。&lt;/p&gt;
&lt;p&gt;如果是传统的运维工作，有这些工具就足够强大了。但是对于分布式系统的开发+运维人员（DevOps?），更关心的是掌握分布式系统的性能和可用性，根据数据做出性能调整、升级、扩容等的决策，从而保证基础设施服务能够满足不断增长的业务需求。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ganglia.sourceforge.net/"&gt;Ganglia&lt;/a&gt;就是这样一种工具。Ganglia 是 UC Berkeley 发起的一个开源监视项目，设计用于测量数以千计的节点。Ganglia主要监控集群的性能指标，如cpu 、mem、硬盘利用率， I/O负载、网络流量情况等，
也可以监控自定义的性能指标。通过Ganglia绘制的曲线很容易见到每个节点的工作状态，对合理调整、分配系统资源，提高系统整体性能起到重要作用。&lt;/p&gt;
&lt;p&gt;gmond 带来的系统负载非常少，这使得它成为在集群中各台计算机上运行的一段代码，而不会影响用户性能。&lt;/p&gt;
&lt;h1&gt;Ganglia架构&lt;/h1&gt;
&lt;p&gt;Ganglia的整体架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Ganglia-architecture" src="images/2013/ganglia/ganglia_architecture.gif"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个被检测的节点或集群运行一个gmond进程，进行监控数据的收集、汇总和发送。gmond即可以作为发送者（收集本机数据），也可以作为接收者（汇总多个节点的数据）。&lt;/li&gt;
&lt;li&gt;通常在整个监控体系中只有一个gmetad进程。该进程定期检查所有的gmonds，主动收集数据，并存储在RRD存储引擎中。&lt;/li&gt;
&lt;li&gt;ganglia-web是使用php编写的web界面，以图表的方式展现存储在RRD中的数据。通常与gmetad进程运行在一起。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，&lt;a href="http://oss.oetiker.ch/rrdtool/"&gt;RRDtool&lt;/a&gt;(Round Robin Database tool,环状数据库工具)是一组操作RRD数据的API，支持数据图形化。RRD是一种环状数据库技术，只存储固定数量的数据，新的数据会覆盖最旧的数据。
更多信息可以参考&lt;a href="http://bbs.chinaunix.net/forum.php?mod=viewthread&amp;amp;tid=864861&amp;amp;page=1"&gt;RRDtool简体中文教程 v1.01&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;Ganglia规划&lt;/h1&gt;
&lt;p&gt;在动手部署Ganglia之前，首先要对监控体系进行初步的规划。主要考虑两方面的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单集群 or 多集群&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果节点较少，使用单集群配置起来更容易；
   如果节点很多，使用多集群可以避免广播风暴。但是需要为每个集群配置不同的组播通道（通过端口区分），同时要配置gmetad同时监听这多个通道。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组播模式 or 单播模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;组播模式是ganglia的默认模式，同一集群的多个gmond之间互相交换数据，gmetad中可以指定集群中的任意一个或多个节点作为"data_source"；&lt;/p&gt;
&lt;p&gt;组播模式可能会带来网络的 “抖动（Jitter）”。据说设置节点的时钟同步可以避免抖动的问题； 但如果网络环境不支持组播（比如Amazon’s AWS EC2），就需要使用单播模式。单播模式时，将大部分节点的gmond.conf中,global的deaf设置改为"yes"，则这些节点只发生数据，不接收其他节点的数据，同样也不能作为gmetad中的"data_source"。&lt;/p&gt;
&lt;p&gt;单播模式中还需要设置“send_metadata_interval”，比如30秒。以强制发送元数据。&lt;/p&gt;
&lt;p&gt;ganglia将一个gmetad覆盖的所有集群/节点称为一个grid。可以在/etc/ganglia/gmetad.conf中通过&lt;code&gt;gridname&lt;/code&gt;指定其名称。多个grid的数据也可以聚合到一个上级gmetad中。&lt;/p&gt;
&lt;h1&gt;安装和配置&lt;/h1&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;在RHEL/CentOS上如果配置了EPEL源，则安装变得非常简单。用yum可以查到如下软件包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ganglia.i686 : Ganglia Distributed Monitoring System&lt;/li&gt;
&lt;li&gt;ganglia.x86_64 : Ganglia Distributed Monitoring System&lt;/li&gt;
&lt;li&gt;ganglia-devel.i686 : Ganglia Library&lt;/li&gt;
&lt;li&gt;ganglia-devel.x86_64 : Ganglia Library&lt;/li&gt;
&lt;li&gt;ganglia-gmetad.x86_64 : Ganglia Metadata collection daemon&lt;/li&gt;
&lt;li&gt;ganglia-gmond.x86_64 : Ganglia Monitoring daemon&lt;/li&gt;
&lt;li&gt;ganglia-gmond-python.x86_64 : Ganglia Monitor daemon python DSO and metric modules&lt;/li&gt;
&lt;li&gt;ganglia-web.x86_64 : Ganglia Web Frontend&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在不同的节点选择对应的软件包安装即可。&lt;/p&gt;
&lt;h2&gt;配置防火墙规则&lt;/h2&gt;
&lt;p&gt;gmond和gmetad之间默认使用UDP的8649端口进行通信，如果配置多个集群，还会有其他端口。要保证这些端口畅通。&lt;/p&gt;
&lt;h2&gt;配置被监控节点(/etc/ganglia/gmond.conf)&lt;/h2&gt;
&lt;p&gt;最重要的配置是集群名称(cluster.name)。&lt;/p&gt;
&lt;p&gt;如果要配置多个集群，每个集群要使用不同的端口。共三个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;udp_send_channel.port&lt;/li&gt;
&lt;li&gt;udp_recv_channel.port&lt;/li&gt;
&lt;li&gt;tcp_accept_channel.port&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;配置中心节点(/etc/ganglia/gmetad.conf)&lt;/h2&gt;
&lt;p&gt;最重要的是配置数据源。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;data_source &amp;quot;NginX&amp;quot; a.a.a.101:8661 a.a.a.102:8661
data_source &amp;quot;LVS&amp;quot;   b.b.b.101 b.b.b.102
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;配置web&lt;/h2&gt;
&lt;p&gt;默认启动httpd服务后，就可以通过&lt;code&gt;http://IP/ganglia&lt;/code&gt;访问。如果提示权限问题，需要检查：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;selinux设置&lt;/li&gt;
&lt;li&gt;防火墙设置&lt;/li&gt;
&lt;li&gt;/etc/httpd/conf.d/ganglia.conf中的&lt;code&gt;Deny from all&lt;/code&gt;限制&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;扩展监控功能&lt;/h1&gt;
&lt;p&gt;Ganglia默认只监控一些通用的性能指标，如果要监控自定义的指标，就需要对Ganglia进行扩展。&lt;/p&gt;
&lt;h2&gt;插件机制&lt;/h2&gt;
&lt;p&gt;从Ganglia 3.1开始，可以使用python开发的插件对Ganglia进行扩展。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/ganglia/gmond.conf&lt;/code&gt;配置中通常会包含：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;include (&amp;#39;/etc/ganglia/conf.d/*.conf&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果安装了&lt;code&gt;ganglia-gmond-python&lt;/code&gt;软件包，会创建一个&lt;code&gt;/etc/ganglia/conf.d/modpython.conf&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;{% highlight nginx %}
modules {
  module {
    name = "python_module"
    path = "modpython.so"
    params = "/usr/lib64/ganglia/python_modules"
  }
}&lt;/p&gt;
&lt;p _="%" endhighlight&gt;include ('/etc/ganglia/conf.d/*.pyconf')&lt;/p&gt;
&lt;p&gt;这样，就可以用python编写自定义的插件。&lt;/p&gt;
&lt;p&gt;Ganglia 在 GitHub 上已经收集了一些&lt;a href="https://github.com/ganglia/gmond_python_modules"&gt;常用的python插件&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;部署NginX插件&lt;/h2&gt;
&lt;p&gt;在&lt;a href="https://github.com/ganglia/gmond_python_modules"&gt;常用的python插件&lt;/a&gt;中包含了
&lt;a href="https://github.com/ganglia/gmond_python_modules/tree/master/nginx_status"&gt;nginx_status插件&lt;/a&gt;，
该插件利用&lt;a href="/nginx_keepalived.html#menuIndex9"&gt;NginX的状态监控功能&lt;/a&gt;获取数据。&lt;/p&gt;
&lt;p&gt;在确保nginx_status可以访问的前提下，只需要做如下配置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将python_modules/目录下的文件复制到gmond节点的&lt;code&gt;/usr/lib64/ganglia/python_modules&lt;/code&gt;目录。这是执行数据采集的脚本&lt;/li&gt;
&lt;li&gt;将conf.d/目录下的文件复制到gmond节点的&lt;code&gt;/etc/ganglia/conf.d/&lt;/code&gt;目录。这些文件定义了collection_group以及metric&lt;/li&gt;
&lt;li&gt;重启gmond&lt;/li&gt;
&lt;li&gt;将graph.d/目录下的文件复制到gmetad节点的&lt;code&gt;/usr/share/ganglia/graph.d&lt;/code&gt;目录。这些文件定义了如何绘制metric的图形&lt;/li&gt;
&lt;li&gt;重启gmetad，在对应的nginx节点详细信息中可以看到nginx metric对应的7个图表。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="Ganglia-nginx" src="images/2013/ganglia/ganglia_nginx.png"&gt;&lt;/p&gt;
&lt;p&gt;理解了NginX插件，基本上能够自己开发Ganglia插件了。&lt;/p&gt;
&lt;h1&gt;TODO：与Nagios结合使用&lt;/h1&gt;
&lt;p&gt;Nagios提供了很好的报警机制，将Ganglia与Nagios结合使用是常见的方式。&lt;/p&gt;</content><category term="运维"></category><category term="cluster"></category></entry><entry><title>keepalived实现双机互备</title><link href="http://holbrook.github.io/2013/07/16/ha_keepalived.html" rel="alternate"></link><published>2013-07-16T00:00:00+08:00</published><updated>2013-07-16T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-07-16:/2013/07/16/ha_keepalived.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;目标：高可用&lt;/h1&gt;
&lt;p&gt;“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。&lt;/p&gt;
&lt;p&gt;通过高可用性设计，可以提高系统的平均无故障时间(MTTF)，
对于重要的系统或系统中重要的节点，必须有高可用性的设计来保证系统的平均无故障时间达到预期的要求。&lt;/p&gt;
&lt;p&gt;前面的&lt;a href="/2013/05/27/nginx_keepalived.html"&gt;NginX负载均衡方案&lt;/a&gt;中就使用了keepalived实现NginX节点的高可用，但那只是高可用性设计中的一种工作方式。
通常来说，高可用设计中多个冗余设备可以采用以下三种工作方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从方式 （非对称方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主机工作，备机处于监控准备状况；当主机宕机时，备机接管主机的一切工作，待主机恢复正常后，按使用者的设定以自动或手动方式将服务切换到主机上运行，数据的一致性通过共享存储系统解决。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双机双工方式（互备互援）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两台主机同时运行各自的服务工作且相互监测情况，当任一台主机宕机时，另一台主机立即接管它的一切工作，保证工作实时，应用服务系统的关键数据存放在共享存储系统中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集群工作方式（多服务器互备方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多台主机一起工作，各自运行一个或几个服务，各为服务定义一个或多个备用主机，当某个主机故障时，运行在其上的服务就可以被其它主机接管。&lt;/p&gt;
&lt;p&gt;显然，主从方式最简单但存在资源浪费的情况；双工方式可以充分利用资源，但配置较复杂，两个节点之间要进行心跳监测；集群工作方式与双工方式并没有本质的区别，但复杂度急剧增加，除了健康状态要多播外，还需要考虑脑裂、仲裁、法定人数等问题。&lt;/p&gt;
&lt;p&gt;本文只讨论双机互备的工作方式。&lt;/p&gt;
&lt;h1&gt;keepalived简介&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://www.keepalived.org/"&gt;keepalived&lt;/a&gt;是&lt;a href="/2013/07/04/lvs_intro.html"&gt;LVS&lt;/a&gt;的扩展项目，最初是为了解决LVS负载调度器的单点故障问题，但由于其适用性较强，配置简洁，也被用在许多其他场合，比如NginX负载均衡的高可用设计。&lt;/p&gt;
&lt;p&gt;keepalived的设计如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keepalived_architecture" src="images/2013/lvs/keepalived_architecture.jpg"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WatchDog：监控checkers和vrrp 进程&lt;/li&gt;
&lt;li&gt;Checkers：服务器健康状态检查(healthchecking)。可以编写自定义的健康检查脚本。&lt;/li&gt;
&lt;li&gt;VRRP STACK：当健康检查失败（服务不可用）时，在节点见进行切换。使用&lt;a href="http://en.wikipedia.org/wiki/Virtual_Router_Redundancy_Protocol"&gt;VRRP(Virtual Router Redundancy Protocol, 虚拟路由器冗余协议）&lt;/a&gt;的组播实现。&lt;/li&gt;
&lt;li&gt;IPVS wrappers：生成ipvs规则。专门为LVS所用。&lt;/li&gt;
&lt;li&gt;Netlink Reflector：设定vrpp的vip地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;keepalived可以在每个节点配置相同的VRRP实例(vrrp_instance)，并指定状态为MASTER或BACKUP。&lt;/p&gt;
&lt;p&gt;当Checkers监测到本节点的服务不可用时，使本机的VRRP实例停止工作，并通知另外节点的VRRP STACK接管VRRP实例，从而对外保证服务继续可用。&lt;/p&gt;
&lt;h1&gt;双机互备方式的实现&lt;/h1&gt;
&lt;p&gt;keepalived实现主备工作的资料到处都有，我这里也有一个&lt;a href="/2013/05/27/nginx_keepalived.html"&gt;NginX主备机制的例子&lt;/a&gt;，这里就不再重复了。&lt;/p&gt;
&lt;p&gt;其实，只要稍微动点脑筋，在主备的基础上就可以实现双机互备甚至集群的工作方式。因为有两个前提：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;keepalived并没有限定节点的个数只能是2个&lt;/li&gt;
&lt;li&gt;keepalived没有限定每个节点只能有一个VRRP实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，双机互备的实现原理就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在每个节点配置两个VRRP实例&lt;/li&gt;
&lt;li&gt;两个实例分别以一个节点为主(MASTER)，另一个节点为备(BACKUP)&lt;/li&gt;
&lt;li&gt;通过外部的其他机制，如DNS轮询，使得两个VRRP实例同时对外提供服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;配置实例&lt;/h1&gt;
&lt;p&gt;keepalived的配置文件（&lt;code&gt;/etc/keepalived/keepalived.conf&lt;/code&gt;)中包含3部分内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;global_defs： 全局配置&lt;/li&gt;
&lt;li&gt;vrrp_instance：vrrp实例，用来定义虚拟路由组&lt;/li&gt;
&lt;li&gt;virtual_server：定义LVS虚拟服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里面只例举一下vrrp实例的配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight nginx %}&lt;/p&gt;
&lt;p&gt;vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass password
    }
    virtual_ipaddress {
        192.168.1.8
    }
}
vrrp_instance VI_2 {
    state BACKUP
    interface eth0
    virtual_router_id 52
    priority 99
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass password
    }
    virtual_ipaddress {
        192.168.1.9
    }
}&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight nginx %}&lt;/p&gt;
&lt;p&gt;vrrp_instance VI_1 {
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 99
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass password
    }
    virtual_ipaddress {
        192.168.1.8
    }
}
vrrp_instance VI_2 {
    state MASTER
    interface eth0
    virtual_router_id 52
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass password
    }
    virtual_ipaddress {
        192.168.1.9
    }
}&lt;/p&gt;
&lt;p&gt;{% endhighlight nginx %}&lt;/p&gt;</content><category term="cluster"></category></entry><entry><title>Pillar：定义Salt配置管理的数据</title><link href="http://holbrook.github.io/2013/07/07/salt_pillar.html" rel="alternate"></link><published>2013-07-07T00:00:00+08:00</published><updated>2013-07-07T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-07-07:/2013/07/07/salt_pillar.html</id><summary type="html">&lt;p&gt;State定义了Salt配置管理的内容，Pillar则定义了Salt配置管理的数据。Pillar使得同一个配置项在各个minion中可以使用不同的数据，从而不需要在State中定义大量的include, extend等关系。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;为什么需要Pillar&lt;/h1&gt;
&lt;p&gt;看了&lt;a href="/2013/06/30/salt_sls_sample.html"&gt;这篇文档&lt;/a&gt;，你可能已经被Salt State的强大所折服。&lt;/p&gt;
&lt;p&gt;是的，Salt State能够解决很多配置管理的问题，但是如下两个场景，如果只用state进行配置就会比较麻烦：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让&lt;code&gt;apache&lt;/code&gt;配置项适应不同的OS&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="/2013/06/30/salt_sls_sample.html#menuIndex1"&gt;这个例子&lt;/a&gt;中的apache配置中通过pkg模块验证&lt;code&gt;apache&lt;/code&gt;软件包是否安装。但是在RedHat系统的yum包管理器和Debian系统的apt包管理器中，apache的包名字分别为&lt;code&gt;httpd&lt;/code&gt;和&lt;code&gt;apache2&lt;/code&gt;。如何避免为apache配置项针对不同的包管理器定义不同的state？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同一个应用在不同环境中的数据库连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假如你开发了一个Django应用，数据库连接信息在应用的settings.py中定义：&lt;/p&gt;
&lt;p&gt;{% highlight python %}
   DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'test',
        'USER': 'root',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '3306',
    }
   }&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;显然，数据库连接信息在开发环境、测试环境、生成环境中各不相同。如果把该应用作为一个state，如何实现在不同环境中的自动部署？&lt;/p&gt;
&lt;p&gt;Salt Pillar就是为了解决类似上述的问题而提供的组件。&lt;/p&gt;
&lt;h1&gt;Pillar是什么？&lt;/h1&gt;
&lt;p&gt;如&lt;a href="/2013/07/02/salt_state_config_structure.html"&gt;这篇文章&lt;/a&gt;所述，Salt Sate定义了配置项以及minion和配置项直接的映射关系；与此类似，Pillar定义了数据以及minion和数据的映射关系。Pillar中定义的数据可以在Salt的其他组件中引用，当然最常见的情况是在State中引用Pillar数据。&lt;/p&gt;
&lt;p&gt;比如，在上一节的第一个问题中，我们可以这样定义State:&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;apache:
    pkg.installed:
      - name: {{ pillar['apache'] }}&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;salt.states.pkg.installed&lt;/code&gt;函数的&lt;code&gt;name&lt;/code&gt;参数就是引用了Pillar中定义的变量&lt;code&gt;apache&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而该变量在Pillar中的定义如下：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p _="%" endif&gt;{ % if grains['os_family'] == 'RedHat' % }
apache: httpd
{ % elif grains['os_family'] == 'Debian' % }
apache: apache2&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;Pillar的配置结构&lt;/h1&gt;
&lt;p&gt;Pillar与State就像是配置管理的左右手，所以Pillar的配置结构与&lt;a href="/2013/07/02/salt_state_config_structure.html"&gt;State的配置结构&lt;/a&gt;几乎完全一样。&lt;/p&gt;
&lt;h2&gt;Pillar Tree和Environment&lt;/h2&gt;
&lt;p&gt;与&lt;a href="/2013/07/02/salt_state_config_structure.html#menuIndex0"&gt;State Tree&lt;/a&gt;一样，Salt中可以定义一棵Pillar Tree，并且将Pillar按照环境进行分组管理。&lt;/p&gt;
&lt;p&gt;Pillar Tree定义在salt master的配置文件&lt;code&gt;/etc/salt/master&lt;/code&gt;的&lt;code&gt;pillar_roots&lt;/code&gt;变量中：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;pillar_roots:
   base:
     - /srv/pillar&lt;/p&gt;
&lt;p&gt;ext_pillar:
     - hiera: /etc/hiera.yaml
     - cmd_yaml: cat /etc/salt/yaml&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h2&gt;Pillar定义&lt;/h2&gt;
&lt;p&gt;Pillar是一组key-value，使用yaml的语法格式。&lt;/p&gt;
&lt;p&gt;简单的定义比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以使用&lt;code&gt;{ { pillar['foo'] } }&lt;/code&gt;的形式进行引用；&lt;/p&gt;
&lt;p&gt;复杂的定义比如：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}
users:
  thatch: 1000
  shouse: 1001
  utahdave: 1002
  redbeard: 1003&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;可以使用包含jinja语法的yaml进行引用：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p _="%" endfor&gt;{ % for user, uid in pillar.get('users', {}).items() % }
   { {user} }:
     user.present:
       - uid: { {uid} }&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;定义好的pillar数据保存在Pillar Tree下面的某个&lt;code&gt;sls&lt;/code&gt;文件中。为了能够在State中引用Pillar数据，
Pillar的目录结构和文件名需要与State能够对应。&lt;/p&gt;
&lt;p&gt;Pillar可以用于任何数据的定义，比如ssh key、证书、密码口令等敏感数据，minion的模块、状态、信息反馈，以及要传递给minion的任何变量的值等等。
这些数据都会以加密通道安全的分发到minion上面。&lt;/p&gt;
&lt;p&gt;Pillar的数据不仅仅可以来自SLS文件，还可以从其他数据源获取数据。相关内容可以自行查阅&lt;a href="http://docs.saltstack.com/topics/pillar/index.html"&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;minion与Pillar之间的映射&lt;/h2&gt;
&lt;p&gt;与&lt;a href="/2013/07/02/salt_state_config_structure.html#menuIndex2"&gt;minion与state之间的映射&lt;/a&gt;一样，
在Pillar的base目录中也存在一个名为&lt;code&gt;top.sls&lt;/code&gt;的入口文件，定义minion与Pillar的映射关系，例如：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;base:
  '*':
    - packages
  'alpha':
    - database&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;上边的例子定义了packages对所有的minion有效，database只对名字为'alpha'的minion有效.&lt;/p&gt;
&lt;h1&gt;Pillar数据的查询和使用&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;查询pillar数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
    salt 'client2' pillar.data
    salt '&lt;em&gt;' pillar.data
    salt '&lt;/em&gt;' pillar.raw key='roles'&lt;/p&gt;
&lt;p&gt;更多的函数可以参考&lt;a href="https://salt.readthedocs.org/en/latest/ref/modules/all/salt.modules.pillar.html"&gt;pillar模块的文档&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刷新pillar数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在master上修改Pilla文件后，需要用以下命令刷新minion上的数据（同步到minion）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   salt &amp;#39;*&amp;#39; saltutil.refresh_pillar
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;在其他sls文件中引用数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pillar解析后是dict对象，直接使用Python语法，可以用索引（&lt;code&gt;pillar['pkgs']['apache']&lt;/code&gt;）或get方法（&lt;code&gt;pillar.get('users', {})&lt;/code&gt;）获取到需要的数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Targetting中使用Pillar&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Targetting中可以用&lt;code&gt;-I&lt;/code&gt;选项指定用Pillar数据选择minion。&lt;/p&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/topics/tutorials/pillar.html"&gt;《Pillar Walkthrough》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/topics/pillar/index.html"&gt;《Pillar of Salt》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="运维"></category></entry><entry><title>ZeroMQ简介</title><link href="http://holbrook.github.io/2013/07/03/zeromq_intro.html" rel="alternate"></link><published>2013-07-03T00:00:00+08:00</published><updated>2013-07-03T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-07-03:/2013/07/03/zeromq_intro.html</id><summary type="html">&lt;p&gt;zeroMQ不是TCP，不是socket，也不是消息队列，而是这些的综合体。&lt;/p&gt;</summary><content type="html">&lt;p&gt;zeroMQ不是TCP，不是socket，也不是消息队列，而是这些的综合体。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ZeroMQ" src="images/2013/zeromq/logo.gif"&gt;&lt;/p&gt;
&lt;h1&gt;ZeroMQ是什么&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://www.zeromq.org/"&gt;ZeroMQ&lt;/a&gt;以嵌入式网络编程库的形式实现了一个并行开发框架（concurrency framework），
能够提供进程内(inproc)、进程间(IPC)、网络(TCP)和广播方式的消息信道，
并支持扇出(fan-out)、发布-订阅(pub-sub)、任务分发（task distribution）、请求/响应（request-reply）等通信模式。
ZeroMQ的性能足以用来构建集群产品，
其异步I/O模型能够为多核消息系统提供足够的扩展性。
ZeroMQ支持30多种语言的API，可以用于绝大多数操作系统。
在提供这些优秀特性的同时，ZeroMQ是开源的，遵循LGPLv3许可。&lt;/p&gt;
&lt;p&gt;ZeroMQ的明确目标是“成为标准网络协议栈的一部分，之后进入Linux内核”。&lt;/p&gt;
&lt;h1&gt;Zero 之禅（The Zen of Zero）&lt;/h1&gt;
&lt;p&gt;ZeroMQ是一个很有个性的项目，其名称也暗合禅意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ø 是一种权衡：让一些丹麦人恼火，但是“Ø”本身也降低了google搜索的命中率以及twitter上的关注度&lt;/li&gt;
&lt;li&gt;Ø 暗合“零代理(broker)”、“零延迟”&lt;/li&gt;
&lt;li&gt;Ø 的目标是“零管理、零消耗、零浪费”&lt;/li&gt;
&lt;li&gt;Ø 符合简约主义：力量的源泉是降低复杂度，而不是增加新功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ZeroMQ对socket API的封装&lt;/h1&gt;
&lt;p&gt;与libevent, ACE等项目不同，使用ZeroMQ时可以不关注网络细节。
ZeroMQ的API提供了对于传统socket API的封装，对于套接字类型、连接处理、帧、甚至路由的底层细节都进行了抽象，
使得一套API可以用于进程内通讯、IPC、TCP和广播等多种消息信道。&lt;/p&gt;
&lt;p&gt;ZeroMQ自己定位为“智能传输层”（The Intelligent Transport Layer），位于网络层和应用层之间。
ZeroMQ使得构建大型并发应用时，可以将基本单元随意的“组装”，由ZeroMQ解决通信的弹性伸缩，&lt;/p&gt;
&lt;p&gt;ZeroMQ的这种设计大大简化了应用程序消息通信的实现，使得在多种场景下重用相同的交互模式成为可能。
使用ZeroMQ可以让编写高性能网络应用程序极为简单和有趣。&lt;/p&gt;
&lt;p&gt;与socket相比，ZeroMQ API的特征如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在后台线程中异步地处理IO。后台线程使用无需锁的数据结构与应用线程通信，所以ZeroMQ应用程序不需要锁、信号量，或者其他等待状态。&lt;/li&gt;
&lt;li&gt;组件可以动态地加入和退出，ZeroMQ会自动重新连接。这意味着可以以任何次序启动组件。可以创建“面向服务架构（service-oriented architectures)”，其中的服务可以在任何时候加入或者退出网络。&lt;/li&gt;
&lt;li&gt;在需要的时候自动对消息排队。这种处理是智能的，在排队前会尽量让消息靠近接收者。&lt;/li&gt;
&lt;li&gt;有处理队列溢出的方法（“高水位标记”）。队列满的时候，ZeroMQ会自动阻塞发送者，或者丢弃消息，取决于你正在使用的消息传递类型（模式）。&lt;/li&gt;
&lt;li&gt;ZeroMQ让应用程序可以使用传输端点相互交流：TCP、多播、进程内、进程间。使用不同的传输端点时不用修改代码。&lt;/li&gt;
&lt;li&gt;根据消息传递模式的不同，使用不同的策略来安全地处理慢速/阻塞的接收者。&lt;/li&gt;
&lt;li&gt;使用请求-应答、发布-订阅等多种模式来路由消息。这些模式定义了如何创建网络拓扑结构。&lt;/li&gt;
&lt;li&gt;需要降低互联的各部分间的复杂性的时候，可以在网络中放置模式扩展的“设备”（小的代理）。&lt;/li&gt;
&lt;li&gt;通过在线路中使用简单的帧，可以精确地传递整个消息。发送10K的消息，则会收到10K的消息。&lt;/li&gt;
&lt;li&gt;不对消息格式做任何假定。消息是从零到数G字节的块。需要在高层使用其他产品来表示数据，如Google的Protocol Buffers、XDR等等。&lt;/li&gt;
&lt;li&gt;智能地处理网络错误。有时候重试，有时候告诉你操作失败。&lt;/li&gt;
&lt;li&gt;降低能耗。使用较少的CPU时间来做更多事情意味着使用更少的能源，而且较老的机器可以使用更长的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ZeroMQ的通信协议&lt;/h1&gt;
&lt;p&gt;ZeroMQ定义了&lt;a href="http://rfc.zeromq.org/spec:13"&gt;ZMTP（ZeroMQ Message Transport Protocol, ZeroMQ消息传输协议）&lt;/a&gt;，在TCP协议之上定义了向后兼容性的规则，可扩展的安全机制，命令和消息分帧，连接元数据，以及其他传输层功能。&lt;/p&gt;
&lt;p&gt;相对于其他的消息传输协议/通信协议，ZeroMQ有明显的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP：ZeroMQ基于消息，使用消息模式而不是字节流。&lt;/li&gt;
&lt;li&gt;XMPP：ZeroMQ更简单、快速、更底层。Jabber可建在ØMQ之上。&lt;/li&gt;
&lt;li&gt;AMQP：完成相同的工作，ZeroMQ要快100倍，而且不需要代理（规范更简洁——比AMQP的规范文档少278页）&lt;/li&gt;
&lt;li&gt;IPC：ZeroMQ可以跨主机通信&lt;/li&gt;
&lt;li&gt;CORBA：ZeroMQ不会将复杂到恐怖的消息格式强加于你。&lt;/li&gt;
&lt;li&gt;RPC：ZeroMQ完全是异步的，你可以随时增加/删除参与者。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.faqs.org/rfcs/rfc1149.html"&gt;RFC 1149&lt;/a&gt;：ZeroMQ比它快多了！&lt;/li&gt;
&lt;li&gt;29west LBM：ZeroMQ是自由软件！&lt;/li&gt;
&lt;li&gt;IBM Low-latency：ZeroMQ是自由软件！&lt;/li&gt;
&lt;li&gt;Tibco：ZeroMQ仍然是自由软件！&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ZeroMQ不是消息队列&lt;/h1&gt;
&lt;p&gt;在摩尔定律的魔咒下，“分布式处理”逐渐成为主流，随之而来的是关于消息通讯、消息中间件的项目层出不穷。&lt;/p&gt;
&lt;p&gt;其中最有名的应该是ZeroMQ和RabbitMQ，Thrift。
&lt;a href="http://www.rabbitmq.com/"&gt;RabbitMQ&lt;/a&gt;是符合&lt;a href="http://www.amqp.org/"&gt;AMQP(Advanced Message Queuing Protocol, 高级消息队列协议)&lt;/a&gt;的消息中间件，
而&lt;a href="http://thrift.apache.org/"&gt;Thrift&lt;/a&gt;是出自于Facebook的跨语言服务访问的框架。&lt;/p&gt;
&lt;p&gt;2011年，&lt;a href="http://zh.wikipedia.org/wiki/%E6%AD%90%E6%B4%B2%E6%A0%B8%E5%AD%90%E7%A0%94%E7%A9%B6%E7%B5%84%E7%B9%94"&gt;欧洲核子研究组织（CERN）&lt;/a&gt;
调查了统一用于操作CERN加速器的中间件解决方案的方式，欧洲核子研究组织的研究比较了
&lt;a href="http://zh.wikipedia.org/wiki/CORBA"&gt;CORBA&lt;/a&gt;、
&lt;a href="http://zh.wikipedia.org/w/index.php?title=Internet_Communications_Engine&amp;amp;action=edit&amp;amp;redlink=1"&gt;Ice&lt;/a&gt;，
&lt;a href="http://zh.wikipedia.org/w/index.php?title=Apache_Thrift&amp;amp;action=edit&amp;amp;redlink=1"&gt;Thrift&lt;/a&gt;，
ZeroMQ,
YAMI4，
&lt;a href="http://zh.wikipedia.org/w/index.php?title=Run-Time_Infrastructure_(simulation)&amp;amp;action=edit&amp;amp;redlink=1"&gt;RTI&lt;/a&gt;和
&lt;a href="http://zh.wikipedia.org/w/index.php?title=Apache_Qpid&amp;amp;action=edit&amp;amp;redlink=1"&gt;Qpid/AMQP&lt;/a&gt;，
ZeroMQ得到了最高的分数。&lt;/p&gt;
&lt;p&gt;但ZeroMQ最大的特点不在性能，而是机制。尽管名字中包含了"MQ"，但ZeroMQ并不是“消息队列/消息中间件”。ZeroMQ是一个传输层API库，
更关注消息的传输。与消息队列相比，ZeroMQ有以下一些特点：&lt;/p&gt;
&lt;p&gt;1 点对点无中间节点&lt;/p&gt;
&lt;p&gt;传统的消息队列都需要一个消息服务器来存储转发消息。而ZeroMQ则放弃了这个模式，把侧重点放在了点对点的消息传输上，并且（试图）做到极致。以为消息服务器最终还是转化为服务器对其他节点的点对点消息传输上。ZeroMQ能缓存消息，但是是在发送端缓存。ZeroMQ里有水位设置的相关接口来控制缓存量。当然，ZeroMQ也支持传统的消息队列（通过zmq_device来实现）。&lt;/p&gt;
&lt;p&gt;2 强调消息收发模式&lt;/p&gt;
&lt;p&gt;在点对点的消息传输上ZeroMQ将通信的模式做了归纳，比如常见的订阅模式（一个消息发多个客户），分发模式（N个消息平均分给X个客户）等等。下面是目前支持的消息模式配对，任何一方都可以做为服务端。
  - PUB and SUB
  - REQ and REP
  - REQ and XREP
  - XREQ and REP
  - XREQ and XREP
  - XREQ and XREQ
  - XREP and XREP
  - PUSH and PULL
  - PAIR and PAIR&lt;/p&gt;
&lt;p&gt;3 以统一接口支持多种底层通信方式&lt;/p&gt;
&lt;p&gt;不管是线程间通信，进程间通信还是跨主机通信，ZeroMQ都使用同一套API进行调用，只需要更改通信协议名称（如，从"ipc:///xxx"改为"tcp://&lt;em&gt;.&lt;/em&gt;.&lt;em&gt;.&lt;/em&gt;:****"）即可。&lt;/p&gt;
&lt;p&gt;4 异步，强调性能&lt;/p&gt;
&lt;p&gt;ZeroMQ设计之初就是为了高性能的消息发送而服务的，所以其设计追求简洁高效。它发送消息是异步模式，通过单独出一个IO线程来实现，所以消息发送调用之后不要立刻释放相关资源哦，会出错的（以为还没发送完），要把资源释放函数交给ZeroMQ让ZeroMQ发完消息自己释放。&lt;/p&gt;
&lt;h1&gt;ZeroMQ的应用案例&lt;/h1&gt;
&lt;p&gt;ZeroMQ如何拯救世界&lt;/p&gt;
&lt;p&gt;由于ZeroMQ的强大，我们可以用ZeroMQ搭建出非常强悍的应用。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2013/06/24/salt_intro.html"&gt;Salt&lt;/a&gt;的底层就使用了ZeroMQ作为通信机制&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mongrel2.org/home"&gt;Mongrel2&lt;/a&gt;是使用ZeroMQ开发的一个Web服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mongrel2是应用ZeroMQ的一个有趣的案例：所有入站消息通过“Push”套接字路由到Mongrel2，套接字可以自动实现负载均衡，将消息分发到连接处理器。反过来，连接处理器处理入站消息（通过Pull套接字），然后将处理结果发布到一个“Pub”套接字，Mongrel2服务器本身已订阅了该套接字，并且通过主题（topic）过滤器监听该套接字的进程号。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="zmq-mongrel2" src="images/2013/zeromq/zmq-mongrel2.png"&gt;&lt;/p&gt;
&lt;p&gt;ZeroMQ带来了一种新的分布式应用架构的思考方式。善用ZeroMQ，可以为应用带来非常强大的特性。&lt;/p&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://zguide.zeromq.org/page:all"&gt;官方指南&lt;/a&gt;，这篇巨长的文档不仅介绍了ZeroMQ的主要方面，网络编程，还融入了ZeroMQ作者对于编程的理念，很值得精读&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.infoq.com/news/2010/09/introduction-zero-mq"&gt;An Introduction to ØMQ (ZeroMQ)&lt;/a&gt;,InfoQ上面对于ZeroMQ的一篇介绍性文章&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.zeromq.org/community"&gt;ZeroMQ社区&lt;/a&gt;，&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hi.baidu.com/ah__fu/item/bdff1d88d236f8c299255f65"&gt;ZeroMQ：云计算时代最好的通讯库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.codingnow.com/2011/02/zeromq_message_patterns.html"&gt;ZeroMQ 的模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="消息中间件"></category></entry><entry><title>lvs+nginx的负载均衡实验</title><link href="http://holbrook.github.io/2013/07/01/lvs_nginx_practice.html" rel="alternate"></link><published>2013-07-01T00:00:00+08:00</published><updated>2013-07-01T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-07-01:/2013/07/01/lvs_nginx_practice.html</id><summary type="html">&lt;p&gt;LVS+NginX是构建大型B/S应用的典型方式。本文记录在实验环境搭建这样一个架构，并进行功能、可靠性、性能等方面的测试的过程。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;准备环境&lt;/h1&gt;
&lt;p&gt;2 LVS(cluster) + 2 NginX
（图）&lt;/p&gt;
&lt;h1&gt;配置&lt;/h1&gt;
&lt;h2&gt;LVS服务器配置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装软件包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pulse: LVS守护进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;piranha: LVS的web管理工具，包括状态监控和配置&lt;/li&gt;
&lt;/ol&gt;
&lt;p _="%" endhighlight&gt;{% highlight bash %}
yum install pulse piranha&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开IP转发功能（ip_forward）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;中设置&lt;code&gt;net.ipv4.ip_forward = 1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/sbin/sysctl -w net.ipv4.ip_forward=1&lt;/code&gt; 或者&lt;code&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看状态：&lt;code&gt;/sbin/sysctl net.ipv4.ip_forward&lt;/code&gt; 或者&lt;code&gt;cat /proc/sys/net/ipv4/ip_forward&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置LVS&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置文件位于&lt;code&gt;/etc/sysconfig/ha/lvs.cf&lt;/code&gt;，使用piranha可以以图形界面的方式进行配置。&lt;/p&gt;
&lt;p&gt;{% highlight bash %}
 # 设置管理密码
 piranha-passwd&lt;/p&gt;
&lt;p&gt;# 启动piranha服务
 /etc/init.d/piranha-gui start&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;接下来可以用浏览器访问: http://IP_OF_LVS:3636（记得配置LVS上的防火墙，否则只能本机访问）。&lt;/p&gt;
&lt;p&gt;点击"Login"按钮，使用用户名&lt;code&gt;piranha&lt;/code&gt;和刚才设置的密码登录，可以看到管理界面：&lt;/p&gt;
&lt;p&gt;&lt;img alt="1" src="images/2013/lvs_nginx_practice/piranha1.png"&gt;&lt;/p&gt;
&lt;p&gt;依次配置全局设置(GLOBAL SETTINGS), 备机设置(REDUNDANCY, 可选)，虚拟服务器(VIRTUAL SERVERS)，即可。&lt;/p&gt;
&lt;p&gt;其中虚拟服务器可以配置基本信息(VIRTUAL SERVER)、真实服务器(REAL SERVER)和监控脚本(MONITORING SCRIPTS)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动服务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置完成后，启动lvs服务(&lt;code&gt;/etc/init.d/pulse start&lt;/code&gt;)，在监控界面(CONTROL/MONITORING)可以看到"Daemon"的状态为"running"。&lt;/p&gt;
&lt;p&gt;如果要设置pulse为开机自动启动，可以使用命令：&lt;code&gt;/sbin/chkconfig --level35 pulse on&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;RS（Real Server，真实服务器）配置&lt;/h2&gt;
&lt;p&gt;这里使用nginx作为Real Server，参考&lt;a href="http://thinkinside.tk/2013/05/27/nginx_keepalived.html"&gt;这篇文章&lt;/a&gt;进行最简单的配置，能够看到nginx默认的欢迎界面即可。&lt;/p&gt;
&lt;p&gt;RS需要进行一系列的设置才能与LVS协同工作，参考如下脚本：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;h1&gt;!/bin/bash&lt;/h1&gt;
&lt;p&gt;VIP=VIP_OF_LVS&lt;/p&gt;
&lt;p&gt;/sbin/ifconfig lo:0 $VIP broadcast $VIP netmask 255.255.255.255 up&lt;/p&gt;
&lt;p&gt;/sbin/route add -host $VIP dev lo:0&lt;/p&gt;
&lt;p&gt;echo "1" &amp;gt;/proc/sys/net/ipv4/conf/lo/arp_ignore&lt;/p&gt;
&lt;p&gt;echo "2" &amp;gt;/proc/sys/net/ipv4/conf/lo/arp_announce&lt;/p&gt;
&lt;p&gt;echo "1" &amp;gt;/proc/sys/net/ipv4/conf/all/arp_ignore&lt;/p&gt;
&lt;p&gt;echo "2" &amp;gt;/proc/sys/net/ipv4/conf/all/arp_announce&lt;/p&gt;
&lt;p&gt;sysctl -p&lt;/p&gt;
&lt;p&gt;/sbin/service iptables stop&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h2&gt;启动LVS服务&lt;/h2&gt;
&lt;p&gt;LVS和RS都配置好之后，可以启动LVS服务。前面提到，pulse是LVS的守护进程(Daemon)。使用如下的命令启动LVS：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/etc/init.d/pulse start
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;命令行工具：ipvsadm&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ipvsadm&lt;/code&gt;是LVS的命令行管理工具，可以用于更改运行时状态或更改配置文件。主要功能包括：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 增加/编辑虚拟服务器（VS）
 ipvsadm -A|E -t|u|f virutal-service-address:port [-s scheduler] [-p [timeout]] [-M netmask]&lt;/p&gt;
&lt;p&gt;# 删除虚拟服务器
 ipvsadm -D -t|u|f virtual-service-address&lt;/p&gt;
&lt;p&gt;# 清除内核虚拟服务器表中的所有记录。
 ipvsadm -C&lt;/p&gt;
&lt;p&gt;# 放弃内存中的修改，读取配置文件
 ipvsadm -R&lt;/p&gt;
&lt;p&gt;# 将内存中的修改保存为配置文件
 ipvsadm -S [-n]&lt;/p&gt;
&lt;p&gt;# 增加/编辑真实服务器（RS）
 ipvsadm -a|e -t|u|f service-address:port -r real-server-address:port&lt;/p&gt;
&lt;p&gt;# 删除真实服务器
 ipvsadm -d -t|u|f service-address -r server-address&lt;/p&gt;
&lt;p&gt;# 显示虚拟服务器表
 ipvsadm -L|l [options]&lt;/p&gt;
&lt;p&gt;# 虚拟服务表计数器清零（清空当前的连接数量等）
 ipvsadm -Z [-t|u|f service-address]&lt;/p&gt;
&lt;p&gt;# 设置连接超时值
 ipvsadm –set tcp tcpfin udp&lt;/p&gt;
&lt;p&gt;# 启动守护进程, 可以是master或backup方式
 ipvsadm –start-daemon state [--mcast-interface interface]&lt;/p&gt;
&lt;p&gt;# 停止守护进程
 ipvsadm –stop-daemon&lt;/p&gt;
&lt;p&gt;# 查看帮助
 ipvsadm -h&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;功能验证&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;检查LVS启动过程： &lt;code&gt;tail -f /var/log/messages&lt;/code&gt;，可以看到虚拟服务启动、连接到各个真实服务器等记录。&lt;/li&gt;
&lt;li&gt;将两台真实服务器的nginx欢迎界面（index.html）修改成不同的内容，重复刷新对虚拟服务器的访问，能看到内容变化&lt;/li&gt;
&lt;li&gt;使用命令&lt;code&gt;ipvsadm&lt;/code&gt;检查分流状况&lt;/li&gt;
&lt;li&gt;关闭一台nginx, &lt;code&gt;/var/log/messages&lt;/code&gt;中会记录服务器连接失败，此时通过&lt;code&gt;ipvsadm&lt;/code&gt;检查会发现所有的流量被分流到另一个nginx上面&lt;/li&gt;
&lt;li&gt;重新启动刚才关闭的nginx, &lt;code&gt;/var/log/messages&lt;/code&gt;中会记录服务器连接成功，此时通过&lt;code&gt;ipvsadm&lt;/code&gt;检查会发现恢复了负载分担&lt;/li&gt;
&lt;li&gt;lvs+keepalived的故障切换测试（未测试）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;性能测试&lt;/h1&gt;
&lt;p&gt;使用Apache Bench进行简单的性能测试，得出如下结论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单个nginx的最佳并发：1900，最大并发：2900；使用LVS+2台nginx的最佳并发：3000，最大并发：5900。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;说明通过LVS做负载均衡能提高并发能力，但不是线性增加，会有一定的损失。具体数据需要进一步测试。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;经过LVS访问nginx比直接访问nginx会增加50毫秒左右的响应时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;官方的测试数字是：VS/NAT方式达到1112并发，VS/DR或VS/TUN方式可以达到25,000并发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;F5的并发处理能力超过10万，可以保持的连接数能达到几百万。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="cluster"></category></entry><entry><title>Salt state 配置结构</title><link href="http://holbrook.github.io/2013/07/01/salt_state_config_structure.html" rel="alternate"></link><published>2013-07-01T00:00:00+08:00</published><updated>2013-07-01T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-07-01:/2013/07/01/salt_state_config_structure.html</id><summary type="html">&lt;p&gt;Salt的state配置比较复杂，官方文档也比较零散。初学者不易掌握。但是如果把Salt的state配置看做是编写代码，就很容易掌握其脉络。&lt;/p&gt;</summary><content type="html">&lt;p&gt;配置的目标是通过master管理多个mision的状态，最终配置的实现是使用文件夹和文件。而Salt state的设计就是在二者之间建立逻辑关系。&lt;/p&gt;
&lt;p&gt;Salt的state配置比较复杂，官方文档也比较零散。初学者不易掌握。但是如果把Salt的state配置看做是编写代码，就很容易掌握其脉络。&lt;/p&gt;
&lt;p&gt;下图是Salt state配置结构的逻辑图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="salt_functions" src="images/2013/salt_usage/salt_state_config_structure.png"&gt;&lt;/p&gt;
&lt;p&gt;配置的目标是通过master管理多个mision的状态，最终配置的实现是使用文件夹和文件。而Salt state的设计就是在二者之间建立逻辑关系。&lt;/p&gt;
&lt;h1&gt;StateTree 和 Environment&lt;/h1&gt;
&lt;p&gt;每个master上面都会建立一棵state树，将各个state的配置分级管理。&lt;/p&gt;
&lt;p&gt;这棵树的第一层就是环境（environment)的划分。salt将环境分为base环境和自定义环境。base环境是必须存在的，其他的环境根据自己的需要进行定义。典型的可以划分开发环境(dev), 用户参与测试环境（uat)，生成环境(prod), 备份环境（backup)等等。&lt;/p&gt;
&lt;p&gt;Salt约定base环境必须存在，是其他环境的基础，base环境中定义的state可以在各个自定义环境中使用。&lt;/p&gt;
&lt;p&gt;显然，每个环境至少需要一个文件夹来保持多个state配置。事实上，Salt允许一个环境使用多个文件夹。&lt;/p&gt;
&lt;p&gt;Salt环境与目录的对应关系在salt master的配置文件&lt;code&gt;/etc/salt/master&lt;/code&gt;的&lt;code&gt;file_roots&lt;/code&gt;变量中定义。&lt;code&gt;/etc/salt/master&lt;/code&gt;文件也是使用YAML格式。&lt;/p&gt;
&lt;p&gt;一个典型的配置如下：&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
 file_roots:
   base:
     - /srv/salt/
   dev:
     - /srv/salt/dev/services
     - /srv/salt/dev/states
   prod:
     - /srv/salt/prod/services
     - /srv/salt/prod/states&lt;/p&gt;
&lt;h1&gt;state定义&lt;/h1&gt;
&lt;p&gt;Salt state即可以使用单个的sls文件(single state)，也可以使用一个文件夹并在其中保持多个sls及其他配置文件（multi-state)。&lt;/p&gt;
&lt;p&gt;state之间还可以使用require, include, extend等关系进行关联。&lt;/p&gt;
&lt;h1&gt;minion 与 state之间的映射&lt;/h1&gt;
&lt;p&gt;一个salt master可以管理多个minion, 也可以定义很多个state。需要在minion和state之间建立一种多对多的映射关系。&lt;/p&gt;
&lt;p&gt;Salt在一个&lt;code&gt;top.sls&lt;/code&gt;文件中定义这种映射关系。比如：&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
base:
  '&lt;em&gt;':
    - servers
dev:
  '&lt;/em&gt;nodb*':
    - mongodb&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;按环境的不同划分state的存放目录；定义state文件/文件夹并在state之间使用关系实现复用；建立minion和state之间的多对多映射关系。&lt;/p&gt;
&lt;p&gt;掌握了这三点，就掌握了Salt state配置的脉络。&lt;/p&gt;
&lt;p&gt;实际上，Salt中&lt;a href="/2013/07/07/salt_pillar.html"&gt;Pillar的配置&lt;/a&gt;也使用了类似的结构。&lt;/p&gt;</content><category term="运维"></category></entry><entry><title>Salt state实例解析</title><link href="http://holbrook.github.io/2013/06/30/salt_sls_sample.html" rel="alternate"></link><published>2013-06-30T00:00:00+08:00</published><updated>2013-06-30T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-06-30:/2013/06/30/salt_sls_sample.html</id><summary type="html">&lt;p&gt;在Salt的官方教程中，以apache和sshd的state配置作为例子。掌握这两个例子，就能够触类旁通，处理日常工作中大部分的配置管理问题。
本文对这两个例子进行详细的分析和注释&lt;/p&gt;</summary><content type="html">&lt;p&gt;在Salt的&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/starting_states.html"&gt;官方教程&lt;/a&gt;中，以apache和sshd的state配置作为例子。掌握这两个例子，就能够触类旁通，处理日常工作中大部分的配置管理问题。
本文对这两个例子进行详细的分析和注释。&lt;/p&gt;
&lt;h1&gt;目录结构&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/starting_states.html"&gt;文档&lt;/a&gt;
中的例子包含了多个文件。这些文件之间互相引用和关联。目录结构及文件清单如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;apache/init.sls&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;apache/httpd.conf&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ssh/init.sls&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ssh/server.sls&lt;/li&gt;
&lt;li&gt;ssh/banner&lt;/li&gt;
&lt;li&gt;ssh/ssh_config&lt;/li&gt;
&lt;li&gt;ssh/sshd_config&lt;/li&gt;
&lt;li&gt;ssh/custom-server.sls&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个配置分别放在了&lt;code&gt;apache&lt;/code&gt;和&lt;code&gt;ssh&lt;/code&gt;文件夹。一个Salt状态可以使用单个的SLS文件，或者使用一个文件夹。后者更加灵活方便。&lt;/p&gt;
&lt;h1&gt;apache/init.sls&lt;/h1&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;apache:
    pkg:
      - installed
    service:
      - running
      - watch:
        - pkg: apache
        - file: /etc/httpd/conf/httpd.conf
        - user: apache
    user.present:
      - uid: 87
      - gid: 87
      - home: /var/www/html
      - shell: /bin/nologin
      - require:
        - group: apache
    group.present:
      - gid: 87
      - require:
        - pkg: apache&lt;/p&gt;
&lt;p&gt;/etc/httpd/conf/httpd.conf:
    file.managed:
      - source: salt://apache/httpd.conf
      - user: root
      - group: root
      - mode: 644
      - template: jinja
      - context:
        custom_var: "override"
      - defaults:
        custom_var: "default value"
        other_var: 123&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sls文件使用&lt;a href="http://yaml.org/spec/1.1/"&gt;YAML&lt;/a&gt;格式定义，最外面的层级定义配置项。&lt;/li&gt;
&lt;li&gt;一个sls文件中可以有多个配置项，配置项的ID可以起任意的名字。本例中包含ID为&lt;code&gt;apache&lt;/code&gt;和&lt;code&gt;/etc/httpd/conf/httpd.conf&lt;/code&gt;两个配置项。&lt;/li&gt;
&lt;li&gt;配置项内是一系列的状态声明。所有的状态项来自Salt状态模块。即可以使用&lt;a href="http://docs.saltstack.com/ref/states/all/index.html"&gt;Salt内置的状态模块&lt;/a&gt;，也可以&lt;a href="http://docs.saltstack.com/ref/states/writing.html"&gt;编写自定义的状态模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态声明内部指定状态函数的调用。状态函数是每个Salt状态模块中定义的函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;apache配置项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.pkg.html#module-salt.states.pkg"&gt;pkg模块&lt;/a&gt;，使用操作系统的包管理器(如yum, apt-get)安装软件包&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.pkg.html#salt.states.pkg.installed"&gt;salt.states.pkg.installed函数&lt;/a&gt;, 验证软件包是否安装以及是否为指定的版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.service.html#module-salt.states.service"&gt;service模块&lt;/a&gt;管理服务/守护进程(daemon)的启动或停止&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.service.html#salt.states.service.running"&gt;salt.states.service.running函数&lt;/a&gt;检查服务是否已经启动&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.service.html#module-salt.states.service"&gt;service模块&lt;/a&gt;定义了&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.service.html#salt.states.service.mod_watch"&gt;salt.states.service.mod_watch&lt;/a&gt;函数，可以使用&lt;a href="http://docs.saltstack.com/ref/states/ordering.html#the-watch-requisite"&gt;&lt;code&gt;watch&lt;/code&gt;要素&lt;/a&gt;监控其他的模块是否满足。这里监控以下情况：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apache&lt;/code&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.pkg.html#module-salt.states.pkg"&gt;软件包(pkg)&lt;/a&gt;是否已安装&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/httpd/conf/httpd.conf&lt;/code&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.file.html#module-salt.states.file"&gt;文件(file)&lt;/a&gt;是否存在&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apache&lt;/code&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.user.html#module-salt.states.user"&gt;用户(user)&lt;/a&gt;是否存在&lt;/li&gt;
&lt;li&gt;&lt;code&gt;user.present&lt;/code&gt;是简写形式，直接调用&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.user.html#module-salt.states.user"&gt;&lt;code&gt;user&lt;/code&gt;&lt;/a&gt;模块的&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.user.html#salt.states.user.present"&gt;&lt;code&gt;present&lt;/code&gt;&lt;/a&gt;函数检查是否存在如下属性的&lt;code&gt;apache&lt;/code&gt;用户：&lt;/li&gt;
&lt;li&gt;uid=87&lt;/li&gt;
&lt;li&gt;gid=87&lt;/li&gt;
&lt;li&gt;home目录为&lt;code&gt;/var/www/html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;登录脚本为&lt;code&gt;/bin/nologin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;检查依赖项：&lt;code&gt;apache&lt;/code&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.group.html#module-salt.states.group"&gt;用户组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group.present&lt;/code&gt;是简写形式，直接调用&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.group.html#module-salt.states.group"&gt;&lt;code&gt;group&lt;/code&gt;&lt;/a&gt;模块的&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.group.html#salt.states.group.present"&gt;&lt;code&gt;present&lt;/code&gt;&lt;/a&gt;函数检查是否存在如下属性的&lt;code&gt;apache&lt;/code&gt;用户组：&lt;/li&gt;
&lt;li&gt;gid=87&lt;/li&gt;
&lt;li&gt;检查依赖项：&lt;code&gt;apache&lt;/code&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.pkg.html#module-salt.states.pkg"&gt;软件包&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/httpd/conf/httpd.conf&lt;/code&gt;配置项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file.managed&lt;/code&gt;是简写形式，直接调用&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.file.html#module-salt.states.file"&gt;file模块&lt;/a&gt;的&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.file.html#salt.states.file.managed"&gt;managed方法&lt;/a&gt;根据需要从master获取文件并可能会通过模板系统(templating system)进行渲染。文件要满足如下要求：&lt;ol&gt;
&lt;li&gt;使用master上面的apache/httpd.conf文件&lt;/li&gt;
&lt;li&gt;user=root&lt;/li&gt;
&lt;li&gt;group=root&lt;/li&gt;
&lt;li&gt;mode=644&lt;/li&gt;
&lt;li&gt;使用&lt;a href="http://jinja.pocoo.org/"&gt;&lt;code&gt;jinja&lt;/code&gt;&lt;/a&gt;模板渲染&lt;/li&gt;
&lt;li&gt;上下文变量：&lt;/li&gt;
&lt;li&gt;custom_var="override"&lt;/li&gt;
&lt;li&gt;默认值:&lt;/li&gt;
&lt;li&gt;custom_var="default value"&lt;/li&gt;
&lt;li&gt;other_var=123&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;ssh/init.sls&lt;/h1&gt;
&lt;p&gt;{% highlight yaml %}
 openssh-client:
    pkg.installed&lt;/p&gt;
&lt;p&gt;/etc/ssh/ssh_config:
    file.managed:
      - user: root
      - group: root
      - mode: 644
      - source: salt://ssh/ssh_config
      - require:
        - pkg: openssh-client&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;h1&gt;ssh/server.sls&lt;/h1&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;include:
    - ssh&lt;/p&gt;
&lt;p&gt;openssh-server:
   pkg.installed&lt;/p&gt;
&lt;p&gt;sshd:
   service.running:
     - require:
       - pkg: openssh-client
       - pkg: openssh-server
       - file: /etc/ssh/banner
       - file: /etc/ssh/sshd_config&lt;/p&gt;
&lt;p&gt;/etc/ssh/sshd_config:
   file.managed:
     - user: root
     - group: root
     - mode: 644
     - source: salt://ssh/sshd_config
     - require:
       - pkg: openssh-server&lt;/p&gt;
&lt;p&gt;/etc/ssh/banner:
   file:
     - managed
     - user: root
     - group: root
     - mode: 644
     - source: salt://ssh/banner
     - require:
       - pkg: openssh-server&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;include语句将别的state添加到当前文件中，使得state可以跨文件引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用include相当于把被引用的内容文件添加到自身，可以require、watch或extend被引用的SLS中定义的内容。&lt;/p&gt;
&lt;p&gt;这里引用了&lt;code&gt;ssh&lt;/code&gt;state。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;openssh-server&lt;/code&gt;配置项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sshd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;配置项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/ssh/banner&lt;/code&gt;配置项&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ssh/custom-server.sls&lt;/h1&gt;
&lt;p&gt;{% highlight yaml %}
 include:
   - ssh.server&lt;/p&gt;
&lt;p _="%" endhighlight&gt;extend:
   /etc/ssh/banner:
     file:
       - source: salt://ssh/custom-banner&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引用&lt;code&gt;ssh&lt;/code&gt;state的server配置项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extend&lt;/code&gt;可以复用已有的state，在原来的基础上进行扩展，增加新的配置或修改已有的配置。&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;/etc/ssh/banner&lt;/code&gt;配置项的文件修改为&lt;code&gt;salt://ssh/custom-banner&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="运维"></category></entry><entry><title>salt的主要功能及使用</title><link href="http://holbrook.github.io/2013/06/25/salt_usage.html" rel="alternate"></link><published>2013-06-25T00:00:00+08:00</published><updated>2013-06-25T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-06-25:/2013/06/25/salt_usage.html</id><summary type="html">&lt;p&gt;本文介绍Salt的主要功能和基本使用，包括minion节点的管理，批量操作，以及非常重要的配置管理。&lt;/p&gt;</summary><content type="html">&lt;p&gt;掌握了这些内容，可以使用Salt极大提高运维的效率（事实上，Salt对于开发阶段也能提供很大的帮助，开发和运维的界限正在逐渐模糊）。&lt;/p&gt;
&lt;p&gt;&lt;a href="/2013/06/24/salt_intro.html"&gt;Salt的介绍&lt;/a&gt;中提到了Salt支持变更操作、配置管理、状态监控所需的一些功能，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="salt_functions" src="images/2013/salt_usage/salt_functions.png"&gt;&lt;/p&gt;
&lt;p&gt;本文详细介绍如何使用这些功能。&lt;/p&gt;
&lt;p&gt;如果想对Salt的功能和使用有一个初步的了解，最好参考官方文档：&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/walkthrough.html"&gt;Salt Stack Walkthrough&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;批量操作(targeting)&lt;/h1&gt;
&lt;p&gt;再回顾一下&lt;a href="http://thinkinside.tk/2013/06/24/salt_intro.html#测试-ref"&gt;前文中的例子&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 测试连通性
 salt '*' test.ping&lt;/p&gt;
&lt;p&gt;# 查询主机运行了多长时间
 sudo salt '*' cmd.run "uptime"&lt;/p&gt;
&lt;p&gt;# 批量重启服务
 salt '*' cmd.run "service httpd restart"&lt;/p&gt;
&lt;p&gt;# 让多台机器一起，使用Apache Bench进行压力测试
 salt '*' cmd.run "ab -n 10 -c 2 http://www.google.com/"&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;上面的例子都是对多个节点进行批量操作：使用通配符"'*'"对所有注册的节点进行操作。Salt支持多种方式对节点id(minion id)进行匹配。包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认：&lt;a href="http://en.wikipedia.org/wiki/Glob_(programming)"&gt;通配符(globbing)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;E：&lt;a href="http://zh.wikipedia.org/zh-hans/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"&gt;正则表达式(Regular Expression)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;L：列表&lt;/li&gt;
&lt;li&gt;N: 分组(group)&lt;/li&gt;
&lt;li&gt;C：复合匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先看一下通配符、正则表达式和列表的例子：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 通配符是最常用的匹配方式。Salt使用&lt;a href="http://docs.python.org/2/library/fnmatch.html"&gt;linux风格的通配符&lt;/a&gt;
 salt '&lt;em&gt;' test.ping
 salt '&lt;/em&gt;.example.net' test.ping
 salt '&lt;em&gt;.example.&lt;/em&gt;' test.ping
 salt 'web?.example.net' test.ping
 salt 'web[1-5]' test.ping
 salt 'web-[x-z]' test.ping&lt;/p&gt;
&lt;p&gt;# 正则表达式可以适应更复杂的情况。使用&lt;a href="http://docs.python.org/2/library/re.html#module-re"&gt;python的re模块&lt;/a&gt;进行匹配
 salt -E 'web1-(prod|devel)' test.ping&lt;/p&gt;
&lt;p&gt;# 最直接的方式是自己指定多个minion，即列表
 salt -L 'web1,web2,web3' test.ping&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.saltstack.com/topics/targeting/compound.html"&gt;复合匹配(Compound matchers)&lt;/a&gt;有点复杂，后续会在其他文章中专门介绍。&lt;/p&gt;
&lt;p&gt;分组匹配见本文的下一节。&lt;/p&gt;
&lt;h1&gt;节点分组（nodegroups）&lt;/h1&gt;
&lt;p&gt;好吧，批量操作确实很爽。但是每次都输入匹配规则有点麻烦，对于复杂的匹配规则更是如此。
salt的 [nodegroups功能]((http://docs.saltstack.com/topics/targeting/nodegroups.html)可以将常用的匹配规则保存下来（称之为minion的分组）。批量操作是，只需要使用L标记指定要操作的group名字即可。
groups定义在master的配置文件&lt;code&gt;/etc/salt/master&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;group 的定义可以使用各种匹配规则，比如：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;group1: 'L@foo.domain.com, bar.domain.com,baz.domain.com or bl*.domain.com'
group2: 'G@os:Debian and foo.domain.com'&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;同样的，使用复合匹配(Compound matchers)定义group的内容不在本文范围之内。&lt;/p&gt;
&lt;h1&gt;命令编排（execution）&lt;/h1&gt;
&lt;p&gt;Salt生来就有命令编排的功能。据说，Salt最先实现的是远程执行技术，然后才添加的配置管理功能。Salt使用ZeroMQ来处理命令执行的请求和响应消息，安装配置简单，并且性能非常高。&lt;/p&gt;
&lt;p&gt;Salt即可以批量执行命令，也可以单机执行。通常单机执行用于测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单机（立即）执行。 使用&lt;a href="http://docs.saltstack.com/topics/tutorials/quickstart.html"&gt;salt-call&lt;/a&gt;命令单机执行操作&lt;/li&gt;
&lt;li&gt;批量(立即)执行。最常用的操作。使用salt命令，对匹配的minion节点执行操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Salt可以执行的命令也可以分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统命令，使用&lt;code&gt;cmd.run&lt;/code&gt;执行&lt;/li&gt;
&lt;li&gt;Salt模块，将常用的命令/批处理封装到内置的Salt模块(module)，使用&lt;code&gt;模块名.功能名&lt;/code&gt;的方式执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 执行系统命令
 salt '*' cmd.run 'hostname'&lt;/p&gt;
&lt;p&gt;# 执行Salt模块
 salt '*' disk.usage&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;使用Salt模块的好处是能够做到一致。比如同样是查看磁盘使用情况，&lt;code&gt;salt '*' cmd.run "df -h"&lt;/code&gt;只能用于&lt;em&gt;NIX节点，而&lt;code&gt;salt '*' disk.usage&lt;/code&gt;对&lt;/em&gt;NIX和Windows都适用，并且采用相同结构返回数据，便于批量处理。&lt;/p&gt;
&lt;p&gt;Salt已经内置了&lt;a href="http://docs.saltstack.com/ref/modules/all/index.html"&gt;大量的模块&lt;/a&gt;，这些模块涵盖了日常管理任务的主要任务，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用的管理任务，比如apt, at, cp, cron, disk, extfs, file, grains, hosts, iptables, mount, network, pam, parted, pkg, ps, selinux, shadow, ssh, test等&lt;/li&gt;
&lt;li&gt;针对特定软件的任务，比如apache, cassandra, djangomod, git, mongodb, mysql, nginx, nova, postgres, solr, sqlite3, 和tomcat&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且，自己开发Salt模块也非常简单，很容易将实际管理操作中的一些经验通过自定义的模块固化下来，并方便分享。&lt;/p&gt;
&lt;p&gt;在开发和调试模块的时候，可以使用&lt;code&gt;test=True&lt;/code&gt;参数进行模拟执行(Dry run)。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;salt &amp;#39;minion1.example.com&amp;#39; state.highstate -v test=True
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;节点信息(grains)&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://docs.saltstack.com/topics/targeting/grains.html"&gt;grains&lt;/a&gt;是Salt内置的一个非常有用的模块。在用salt进行管理客户端的时候或者写state的时候都可以引用grains的变量。&lt;/p&gt;
&lt;p&gt;grains的基本使用举例如下：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 查看grains分类
 salt '*' grains.ls&lt;/p&gt;
&lt;p&gt;# 查看grains所有信息
 salt '*' grains.items&lt;/p&gt;
&lt;p&gt;# 查看grains某个信息
 salt '*' grains.item osrelease&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;配置管理（state)&lt;/h1&gt;
&lt;p&gt;配置管理是Salt中非常重要的内容之一。Salt通过内置的state模块支持配置管理所需的功能。关于这部分内容，官方文档有很详细的描述，可以参考
&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/states_pt1.html"&gt;part 1&lt;/a&gt;，
&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/states_pt2.html"&gt;part 2&lt;/a&gt;和
&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/states_pt3.html"&gt;part 3&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Salt中可以定义节点的目标状态，称之为state。state对应配置管理中的配置，可以对其进行标识、变更控制、变更识别、状态报告、跟踪和归档以及审计等一些的管理行为。&lt;/p&gt;
&lt;h2&gt;状态描述&lt;/h2&gt;
&lt;p&gt;Salt使用SLS文件（SaLt State file）描述状态。SLS使用&lt;a href="http://yaml.org/spec/1.1/"&gt;YAML&lt;/a&gt;格式进行数据序列化，因此简单明了，可读性也很高。&lt;/p&gt;
&lt;h3&gt;基本描述(yaml)&lt;/h3&gt;
&lt;p&gt;下边是一个简单的SLS文件例子:&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;apache:
   pkg:
     - installed
   service:
     - running
     - require:
       - pkg: apache&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;该文件描述一个ID为&lt;code&gt;apache&lt;/code&gt;的配置状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件包（pkg)已经安装&lt;/li&gt;
&lt;li&gt;服务应该处于运行中&lt;/li&gt;
&lt;li&gt;服务的运行依赖于&lt;code&gt;apache&lt;/code&gt;软件包的安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;state文件中的所有YAML变量名来自Salt的state模块。&lt;/p&gt;
&lt;p&gt;Salt内置了大量的state模块，比如cron, cmd, file, group, host, mount, pkg, service, ssh_auth，user等。
详细清单参考&lt;a href="http://docs.saltstack.com/ref/states/all/index.html"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;还可以开发自己的state模块。&lt;/p&gt;
&lt;h3&gt;扩展描述(jinja)&lt;/h3&gt;
&lt;p&gt;state可以使用&lt;a href="http://jinja.pocoo.org/"&gt;jinja&lt;/a&gt;模板引擎进行扩展，其语法可以参考&lt;a href="http://jinja.pocoo.org/docs/templates/"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面是一个更复杂的例子：&lt;/p&gt;
&lt;p&gt;{% highlight html+jinja %}&lt;/p&gt;
&lt;p&gt;vim:
  pkg:
    { % if grains['os_family'] == 'RedHat' % }
    - name: vim-enhanced
    { % elif grains['os'] == 'Debian' % }
    - name: vim-nox
    { % elif grains['os'] == 'Ubuntu' % }
    - name: vim-nox
    { % endif % }
    - installed&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;该state增加了判断逻辑：如果是redhard系列的就安装 vim-enhanced，如果系统是Debian或者Ubuntu就安装vim-nox。&lt;/p&gt;
&lt;h3&gt;逻辑关系&lt;/h3&gt;
&lt;p&gt;state之间可以有&lt;a href="http://docs.saltstack.com/ref/states/ordering.html"&gt;逻辑关系&lt;/a&gt;。常见的关系举例如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;require：依赖某个state，在运行此state前，先运行依赖的state，依赖可以有多个&lt;/li&gt;
&lt;/ul&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
 httpd:
   pkg:
     - installed
   file.managed:
     - name: /etc/httpd/conf/httpd.conf
     - source: salt://httpd/httpd.conf
     - require:
       - pkg: httpd&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;watch：在某个state变化时运行此模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
redis:
  pkg:
    - latest
  file.managed:
    - source: salt://redis/redis.conf
    - name: /etc/redis.conf
    - require:
      - pkg: redis
    service.running:
      - enable: True
      - watch:
      - file: /etc/redis.conf
      - pkg: redis&lt;/p&gt;
&lt;p&gt;watch除具备require功能外，还增了关注状态的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;order：优先级比require和watch低，有order指定的state比没有order指定的优先级高&lt;/li&gt;
&lt;/ul&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
vim:
  pkg.installed:
    - order: 1&lt;/p&gt;
&lt;p&gt;想让某个state最后一个运行，可以用last&lt;/p&gt;
&lt;h2&gt;保存状态&lt;/h2&gt;
&lt;p&gt;状态描述文件(SLS)要保存在master节点中，并通过指令分发到minion节点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路径设置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Salt master的配置文件(&lt;code&gt;/etc/salt/master&lt;/code&gt;)中可以通过&lt;code&gt;file_roots&lt;/code&gt;参数指定状态文件的保存路径。可以为不同的环境（如开发环境、UAT环境、生产环境、灾备环境等）分别指定路径，如下所示：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;file_roots:
  base:
    - /srv/salt/
  dev:
    - /srv/salt/dev/services
    - /srv/salt/dev/states
  prod:
    - /srv/salt/prod/services
    - /srv/salt/prod/states&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;其中,base环境是必须的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;入口文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;file_roots&lt;/code&gt;中必须指定“base”环境的路径，因为该路径中存在Salt state的&lt;a href="http://docs.saltstack.com/ref/states/highstate.html"&gt;入口文件: top.sls&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Top文件建立配置环境、节点和状态配置之间的映射关系。比如一个简单的top.sls文件：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;base:
  '&lt;em&gt;':
    - servers
dev:
  '&lt;/em&gt;nodb*':
    - mongodb&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;该文件指定了：
- 所有节点使用base环境的servers配置
- &lt;em&gt;nodb&lt;/em&gt;节点使用dev环境的mongodb配置&lt;/p&gt;
&lt;p&gt;结合第一部分的file_roots配置，该top配置意味存在以下的配置文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/srv/salt/servers.sls&lt;/li&gt;
&lt;li&gt;/srv/salt/dev/mongodb.sls&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：这里也可以使用文件夹&lt;code&gt;/srv/salt/servers/&lt;/code&gt;和&lt;code&gt;/srv/salt/dev/mongodb/&lt;/code&gt;，在文件夹中放置一组状态文件和配置文件，便于建立复杂的状态配置。&lt;/p&gt;
&lt;p&gt;top.sls中的可配置内容非常丰富，具体内容可以参考&lt;a href="http://docs.saltstack.com/ref/states/highstate.html"&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;状态生效（State Enforcement）&lt;/h2&gt;
&lt;p&gt;master上对状态进行定义，最终这些状态要传递到minion节点上。在本节的例子中，如果定义好了状态文件&lt;code&gt;/srv/salt/dev/mongodb.sls&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;mongodb:
  pkg:
    - installed&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;可以使用命令&lt;code&gt;salt "minion1" state.highstate -v&lt;/code&gt;使得所有针对"minion1"的state生效；&lt;/p&gt;
&lt;p&gt;在执行状态之前先进行测试是个好主意，需要指定参数&lt;code&gt;test=True&lt;/code&gt;。比如，&lt;code&gt;salt "minion1" state.highstate -v test=True&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;关于state模块的更多用法，可以参考&lt;a href="https://salt.readthedocs.org/en/latest/ref/modules/all/salt.modules.state.html"&gt;state模块说明&lt;/a&gt;，或&lt;a href="http://docs.saltstack.com/ref/states/index.html#state-enforcement"&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;更多&lt;/h2&gt;
&lt;p&gt;Salt的state模块的功能不仅如此，还可以使用模板和变量，以及定义状态的定时自动生效。&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;本文介绍Salt的主要功能和基本使用，包括minion节点的管理，批量操作，以及非常重要的配置管理。
掌握了这些内容，可以使用Salt极大提高运维的效率（事实上，Salt对于开发阶段也能提供很大的帮助，开发和运维的界限正在逐渐模糊）。&lt;/p&gt;
&lt;p&gt;后续会介绍一些使用案例以及Salt的高级功能。&lt;/p&gt;</content><category term="运维"></category></entry><entry><title>用salt管理成千上万的服务器</title><link href="http://holbrook.github.io/2013/06/24/salt_intro.html" rel="alternate"></link><published>2013-06-24T00:00:00+08:00</published><updated>2013-06-24T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-06-24:/2013/06/24/salt_intro.html</id><summary type="html">&lt;p&gt;实在是厌倦了对大量服务器日复一日的重复操作。尤其是在虚拟化的时代，系统的每个组件都有很多个相同的节点在运行，更让重复的次数再乘以N。
当我发现Salt的时候，我的眼前一亮：这正是我所需要的东西。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;引言：一个”非专职运维人员“的烦恼&lt;/h1&gt;
&lt;p&gt;加入到某证券公司的IT部门，尽管所在的部门挂了一个“研发部”的名字，但是我发现有大概40%的时间是在做运维工作。&lt;/p&gt;
&lt;p&gt;这来自两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自主开发的应用，需要持续的改进，不断的更新、发布、部署、调整配置，这不是运维部门喜欢的状态。&lt;/li&gt;
&lt;li&gt;软件商提供的“产品”无法满足运维部门的要求：无法通过简单的 &lt;a href="http://en.wikipedia.org/wiki/Q%26A"&gt;Q&amp;amp;A&lt;/a&gt; 文档保证系统的正常运行，经常需要有一定技术能力的人员解决系统运行过程中各种稀奇古怪的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种情况下只能自己做一个“非专职运维人员”，需要频繁的登录各种服务器，执行一些命令来查看状态或者更改配置（包括配置文件的变更和软件包的安装部署）。很多操作都是不断的重复，日复一日，让人厌烦。&lt;/p&gt;
&lt;p&gt;”重复的工作应该交给程序去做“，所以我自己写过一些脚本。为了避免将脚本上传到几十台服务器并且不时进行更改，我使用&lt;a href="https://github.com/fabric/fabric"&gt;Fabric&lt;/a&gt;来进行服务器的批量操作。&lt;/p&gt;
&lt;p&gt;尽管避免了”批量的人工操作“，但我还是在进行”人工的批量操作“。远远没有实现自动管理。将有限的生命解放出来，投入到更有意义的编码工作是一个奔四程序员应有的追求，所以我又睁大红肿的眼睛，迷茫的搜索这个世界。&lt;/p&gt;
&lt;p&gt;我发现了&lt;a href="https://puppetlabs.com/"&gt;Puppet&lt;/a&gt;，&lt;a href=""&gt;Chef&lt;/a&gt;和&lt;a href=""&gt;CFEngine&lt;/a&gt;，但是并不满意。直到我发现了&lt;a href="http://saltstack.org/"&gt;Salt&lt;/a&gt;,我的眼前一亮：这正是我所需要的东西。&lt;/p&gt;
&lt;p&gt;如果说Salt有什么独特之处打动了我，那就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单：可能是源于python的简约精神，Salt的安装配置和使用简单到了令人发指的地步。任何稍有经验的linux使用者可以在10分钟之内搭建一个测试环境并跑通一个例子（相比之下，puppet可能需要30--60分钟）。&lt;/li&gt;
&lt;li&gt;高性能：Salt使用大名鼎鼎的&lt;a href="/2013/07/03/zeromq_intro.html"&gt;ZeroMQ&lt;/a&gt;作为通讯协议，性能极高。可以在数秒钟之内完成数据的传递&lt;/li&gt;
&lt;li&gt;可伸缩：基于&lt;a href="/2013/07/03/zeromq_intro.html"&gt;ZeroMQ&lt;/a&gt;通信，具备很强的扩展性；可以进行分级管理，能够管理分布在广域网的上万台服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管&lt;a href="http://www.twitter.com"&gt;twitter&lt;/a&gt;、&lt;a href="http://www.douban.com/"&gt;豆瓣&lt;/a&gt;、&lt;a href="http://www.oracle.com"&gt;oracle&lt;/a&gt;、等著名网站的运维团队都在使用puppet，但是我相信，他们切换到salt只是一个时间问题。毕竟不是所有的人都喜欢操纵傀儡(puppet)，但是谁又能离开盐(salt)呢？&lt;/p&gt;
&lt;p&gt;关于Salt和Puppet的对比，可以参考&lt;a href="http://www.opencredo.com/blog/a-dive-into-salt-stack"&gt;这里&lt;/a&gt;，或者看看&lt;a href="http://wiki.saltstack.cn/reproduction/dive-into-saltstack"&gt;中文版&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;Salt快速入门&lt;/h1&gt;
&lt;p&gt;Salt的体系结构中将节点区分为: master, minion, syndic。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master: 老大，管理端&lt;/li&gt;
&lt;li&gt;minion: 马仔，被管理端&lt;/li&gt;
&lt;li&gt;syndic: 头目，对于老大来说是马仔，对于马仔来说是老大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在入门阶段，先不考虑syndic。&lt;/p&gt;
&lt;h2&gt;安装配置&lt;/h2&gt;
&lt;p&gt;如果将操作系统区分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;*NIX&lt;/li&gt;
&lt;li&gt;Linux&lt;/li&gt;
&lt;li&gt;Solaris&lt;/li&gt;
&lt;li&gt;HP Unix&lt;/li&gt;
&lt;li&gt;FreeBSD&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS X&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;windows&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理论上来说，Salt可以安装在任何*NIX系统上，包括master和minion。除了&lt;a href="https://github.com/saltstack/salt"&gt;源代码&lt;/a&gt;之外，
还可以通过Salt提供的&lt;a href="https://github.com/saltstack/salt-bootstrap"&gt;安装脚本&lt;/a&gt;，或者&lt;a href="https://pypi.python.org/pypi/salt"&gt;PyPI&lt;/a&gt;进行安装。&lt;/p&gt;
&lt;p&gt;对于Linux，尤其是企业环境中常用的RHEL,CentOS,Ubuntu，可以通过包管理器非常容易的安装master 和/或 minion。
比如: yum(需要先配置&lt;a href="http://fedoraproject.org/wiki/EPEL/zh-cn"&gt;EPEL&lt;/a&gt;), apt(需要增加&lt;code&gt;http://debian.madduck.net/repo/&lt;/code&gt;库)，yaourt，ports。&lt;/p&gt;
&lt;p&gt;Mac OS X 先使用HomeBrew解决依赖包：&lt;code&gt;brew install swig zmq&lt;/code&gt;，然后用PyPI安装：&lt;code&gt;pip install salt&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于windows，只能安装minion（windows只适合做马仔）。从&lt;a href="http://saltstack.com/downloads/"&gt;官方网站&lt;/a&gt;下载合适的安装包。安装过程中可以指定master地址和本机名称。
安装后需要自己启动Salt服务。配置文件在C:\salt\conf\minion。&lt;/p&gt;
&lt;p&gt;具体的各操作系统下的安装可以参考&lt;a href="http://docs.saltstack.com/topics/installation/index.html"&gt;官方文档&lt;/a&gt;。这里为了简单，只考虑常用的RHEL/CentOS 和 windows。 在下面的例子中，使用一台RHEL/CentOS作为master， 另外一台RHEL/CentOS和一台windows 2003 Server作为 minion。&lt;/p&gt;
&lt;h3&gt;安装管理端(master)&lt;/h3&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 安装EPEL,注意选择合适的版本
 rpm -ivh http://mirrors.sohu.com/fedora-epel/6/x86_64/epel-release-6-8.noarch.rpm
 yum update&lt;/p&gt;
&lt;p&gt;# 安装master
 yum install salt-master&lt;/p&gt;
&lt;p&gt;# 修改配置
 vim /etc/salt/master&lt;/p&gt;
&lt;p&gt;# 最基本的设定服务端监听的IP(比如使用VIP做master的高可用时)：
 # interface: 服务端监听IP
 # 其他配置参考&lt;a href="http://docs.saltstack.com/ref/configuration/master.html"&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;# 启动服务(以下命令等效)
 salt-master -d
 /etc/init.d/salt-master start
 service salt-master start&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h3&gt;安装被管理端(minion)&lt;/h3&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 安装EPEL,注意选择合适的版本
 rpm -ivh http://mirrors.sohu.com/fedora-epel/6/x86_64/epel-release-6-8.noarch.rpm
 yum update&lt;/p&gt;
&lt;p&gt;# 安装minion
 yum install salt-minion&lt;/p&gt;
&lt;p&gt;# 修改配置
 vim /etc/salt/minion&lt;/p&gt;
&lt;p&gt;# 最基本的设定是指定master地址，以及本机标识符：
 # master: master的主机名或IP地址
 # id: 本机标识符
 # 其他配置参考&lt;a href="http://docs.saltstack.com/ref/configuration/minion.html"&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;# 启动服务(以下命令等效)
 salt-minion -d
 /etc/init.d/salt-minion start
 service salt-minion start&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h3&gt;接受minion的托管请求&lt;/h3&gt;
&lt;p&gt;minion向master投诚后，还需要master接受才行。这个过程叫做“授信”。&lt;/p&gt;
&lt;p&gt;Salt底层使用公钥-私钥证书来保证通信信道的安全。具体的机制可以参考ZeroMQ的相关内容。Salt已经屏蔽了底层的细节，只需要使用封装好的命令：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 在master上运行
 # 查看所有minion
 salt-key -L&lt;/p&gt;
&lt;p&gt;Accepted Keys:
 windows
 bond_app_server_main
 mac_os_vm
 salt-master
 Unaccepted Keys:
 minion1
 minion2
 Rejected Keys:&lt;/p&gt;
&lt;p&gt;#其中Unaccepted Keys是未许可的minion。可以使用下面的命令通过认证：
 salt-key -a minion1&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;安装配置好之后，首先要测试一下联通性：&lt;code&gt;salt '*' test.ping&lt;/code&gt;。salt会列出每个认证过的minion的联通状态(true 或 false)。&lt;/p&gt;
&lt;p&gt;再举一些例子：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 查询主机运行了多长时间
 sudo salt '*' cmd.run "uptime"&lt;/p&gt;
&lt;p&gt;# 批量重启服务
 salt '*' cmd.run "service httpd restart"&lt;/p&gt;
&lt;p&gt;# 让多台机器一起，使用Apache Bench进行压力测试
 salt '*' cmd.run "ab -n 10 -c 2 http://www.google.com/"&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;注意，默认情况下master和minion之间使用以下端口进行通信：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4505(publish_port): salt的消息发布系统&lt;/li&gt;
&lt;li&gt;4506(ret_port):salt客户端与服务端通信的端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络的设置需要保证这些端口可以访问。&lt;/p&gt;
&lt;h1&gt;Salt的强大功能&lt;/h1&gt;
&lt;p&gt;上面的例子都是用Salt进行批量操作。但是Salt的功能不仅如此。&lt;/p&gt;
&lt;p&gt;认真分析一下我的“非专职运维工作”的内容，发现可以分为以下三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变更操作：根据需要对节点中某个资源的某种状态进行调整，并检验变更的结果&lt;/li&gt;
&lt;li&gt;配置管理：让上述行为变得“可管理”，支持“有关人士”对上述行为的标记、控制、识别、报告、跟踪和归档甚至审批和审计&lt;/li&gt;
&lt;li&gt;状态监控：随时掌握状态，发现异常。尽量在系统用户发现问题之前解决麻烦&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Salt对上述三个方面提供了完美的支持，事实上，Salt提供的功能比我需要的还要多。下图是Salt的主要功能：&lt;/p&gt;
&lt;p&gt;&lt;img alt="salt_functions" src="images/2013/salt_usage/salt_functions.png"&gt;&lt;/p&gt;
&lt;p&gt;具体的功能使用在&lt;a href="/2013/06/25/salt_usage.html"&gt;这篇文章&lt;/a&gt;中详细说明。&lt;/p&gt;
&lt;h1&gt;Salt的网络资源&lt;/h1&gt;
&lt;h2&gt;网站&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://saltstack.org/"&gt;salt官方网站&lt;/a&gt;，&lt;/li&gt;
&lt;li&gt;&lt;a href="http://saltstack.cn/"&gt;中国SaltStack用户组(CSSUG)网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://intothesaltmine.org/blog/html/index.html"&gt;Into The Salt Mine,关于Salt的各种安装、配置、使用的博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack"&gt;saltstack将代码托管在github上&lt;/a&gt;,包括：&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt"&gt;salt主工程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-bootstrap"&gt;salt-bootstrap，一个快速安装Salt的脚本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-states"&gt;salt states参考配置&lt;/a&gt;，大量用于监控目标主机状态的配置文件，可以直接使用&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-cloud"&gt;Salt Cloud&lt;/a&gt;,使得Salt支持各种云服务(Amazon EC2, HP Cloud, OpenStack,Parallels等)的扩展&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salty-vagrant"&gt;salty-vagrant&lt;/a&gt;, 用Salt管理&lt;a href="http://www.vagrantup.com/"&gt;Vagrant虚拟环境&lt;/a&gt;的扩展&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-api"&gt;salt-api&lt;/a&gt;，基于Salt进行二次开发的包&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-ui"&gt;salt-ui&lt;/a&gt;, 一个图形界面&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/pepper"&gt;pepper&lt;/a&gt;, Stand-alone CLI tools that mimic Salt's CLI tools but proxy Salt commands through salt-api &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-contrib"&gt; salt-contrib&lt;/a&gt;, Salt Module Contributions &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/sublime-text"&gt; sublime-text&lt;/a&gt;, Salt-related syntax highlighting and snippets for Sublime Text &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/formulae"&gt; formulae&lt;/a&gt;, &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-vim"&gt; salt-vim&lt;/a&gt;, Vim files for editing Salt files &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-ci"&gt; salt-ci&lt;/a&gt;, Salt-CI — Salt Continuous Integration &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-genesis"&gt; salt-genesis&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-qa"&gt; salt-qa&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/saltstack_org"&gt; saltstack_org&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/saltstack/salt-windows-install"&gt; salt-windows-install&lt;/a&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/cssug"&gt;中国SaltStack用户组在github上托管的代码&lt;/a&gt;，包括：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/cssug/salt"&gt;salt的一个分支&lt;/a&gt;, 其目标是实现中心库和配置管理功能。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/cssug/salt-dashboard"&gt;salt的web管理界面&lt;/a&gt;，基于Django。&lt;/li&gt;
&lt;/ul&gt;</content><category term="运维"></category></entry><entry><title>Jekyll建站过程</title><link href="http://holbrook.github.io/2013/05/27/2013-05-27-jekyll_mysite.html" rel="alternate"></link><published>2013-05-27T00:00:00+08:00</published><updated>2013-05-27T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-05-27:/2013/05/27/2013-05-27-jekyll_mysite.html</id><summary type="html">&lt;p&gt;本站建立过程中的一些经验，不断完善中...&lt;/p&gt;</summary><content type="html">&lt;p&gt;早在2012年8月，就通过&lt;a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html"&gt;这篇文章&lt;/a&gt;知道了Jekyll,  但是一直没有去尝试。&lt;/p&gt;
&lt;p&gt;直到最近静下心来，才发现使用Jekyll 搭建博客非常简单。当然，上手简单，想用好并不容易。&lt;/p&gt;
&lt;p&gt;本文记录在使用Jekyll搭建博客过程中的一些过程和经验，并持续完善和改进。&lt;/p&gt;
&lt;p&gt;本文分成3个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础篇：最简单、最快速的使用Jekyll&lt;/li&gt;
&lt;li&gt;进阶篇：一些个性化定制的选项&lt;/li&gt;
&lt;li&gt;推广篇：博客推广的一些手段和方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;基础篇&lt;/h1&gt;
&lt;h2&gt;关于Jekyll&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Jekyll" src="images/posts/tools/jekyll_mysite/jekyll.jpg"&gt;&lt;/p&gt;
&lt;p&gt;已经有太多的文章介绍了&lt;a href="http://jekyllrb.com/"&gt;Jekyll&lt;/a&gt;(/'dʒiːk əl/)。
简单的说，Jekyll是用ruby语言实现的一个静态网站生成器，可以将&lt;a href="https://help.github.com/articles/my-custom-domain-isn-t-working"&gt;Markdown&lt;/a&gt; (或者&lt;a href="http://textile.sitemonks.com/"&gt;Textile&lt;/a&gt;)编辑的文档生成html。
当然也可以用来生成博客。
我使用Markdown标记语言，其语法可以参考&lt;a href="http://wowubuntu.com/markdown"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Jekyll支持&lt;a href="http://wiki.shopify.com/Liquid"&gt;Liquid&lt;/a&gt;模板语言，写文档时的感觉很像是在写Django模板。Jekyll定义了一些&lt;a href="http://jekyllrb.com/docs/variables/"&gt;内置的变量&lt;/a&gt;，包括全局变量、页面变量等。
&lt;a href="http://jekyllrb.com/docs/frontmatter/"&gt;在文档中可以设置页面变量的值&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;与RoR类似，Jekyll也可以通过插件来增加额外的功能。&lt;/p&gt;
&lt;h2&gt;关于github Pages&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/"&gt;github&lt;/a&gt;是程序员的facebook。&lt;a href="http://pages.github.com/"&gt;github Pages&lt;/a&gt;是github提供的静态网页托管。可以为用户或者项目创建站点。
有意思的是，github Pages对于上传的静态文件会通过Jekyll进行处理后再发布出来。&lt;/p&gt;
&lt;p&gt;于是，一些”不务正业“的程序员就开始使用github Pages建立博客，现在这股风潮已经愈演愈烈，一些程序员聚集的博客站点可能要小心应对了。&lt;/p&gt;
&lt;h2&gt;使用github Pages写博客的好处&lt;/h2&gt;
&lt;p&gt;为什么说”一些程序员聚集的博客站点可能要小心应对了“呢？ 因为github Pages简直是为程序员量身定制的博客系统。
（当然，估计也只有程序员会愿意折腾这些事情）。&lt;/p&gt;
&lt;p&gt;对我来说，使用github Pages写博客的好处主要体现在以下方面：
1. 自由，随意定制
2. 方便，在github上托管
3. 可控，有版本管理
4. 直接，只需提交，不需要先导出再提交，让人愿意持续更新文章
5. 高效，使用markdown语言能提高写作的效率（但是个人觉得不如org-mode)
6. 免费，无限流量，无限空间&lt;/p&gt;
&lt;h2&gt;关于Jekyll Bootstrap&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://jekyllbootstrap.com/"&gt;jekyll-bootstrap&lt;/a&gt;是用Jekyll建立博客的一套模板，提供了主题（themes)、评论、。。等功能，&lt;/p&gt;
&lt;p&gt;对于Jekyll的初学者能提供很大的帮助，其网站上号称“基于GitHub Pages建博客的最快方式”，可以“用3分钟就建立一个博客”。&lt;/p&gt;
&lt;h2&gt;3分钟建立博客&lt;/h2&gt;
&lt;p&gt;让我们看看上述工具的组合如何用3分钟建立博客。假设你已经有git的基础，在github上托管过项目。并且使用的不是windows。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 检查ruby版本
ruby -v
#更换更快的gem源，可选
gem sources --remove http://rubygems.org/
gem sources -a http://ruby.taobao.org/
gem sources -l

#如果不是1.9.3+，需要升级到1.9.3
bash &amp;lt; &amp;lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer )
source ~/.bashrc

rvm install 1.9.3
# 安装jekyll, 并使用rdiscount作为markdown解析器
sudo gem install jekyll
gem install rdiscount

# 使用Jekyll-Bootstrap，其实就是一个复制的过程。下面的USERNAME代表你在github上的用户名
git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com


# 使用GitHub Pages的账户主页建立博客，必须使用如下形式的项目名称并使用主分支
# 如果使用项目主页，必须使用项目的gh-pages分支
cd USERNAME.github.com
git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git
git push origin master

好了，等上几分钟，你的主页就发布在了https://USERNAME.github.com。
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;其他操作&lt;/h2&gt;
&lt;h3&gt;jekyll命令&lt;/h3&gt;
&lt;p&gt;安装jekyll会产生一个命令行工具：jekyll，提供以下功能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;                &lt;span class="n"&gt;Build&lt;/span&gt; &lt;span class="n"&gt;your&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt;
&lt;span class="n"&gt;doctor&lt;/span&gt;               &lt;span class="n"&gt;Search&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;specific&lt;/span&gt; &lt;span class="n"&gt;deprecation&lt;/span&gt; &lt;span class="n"&gt;warnings&lt;/span&gt;
&lt;span class="n"&gt;help&lt;/span&gt;                 &lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;documentation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;               &lt;span class="nn"&gt;Import&lt;/span&gt; &lt;span class="nn"&gt;your&lt;/span&gt; &lt;span class="nn"&gt;old&lt;/span&gt; &lt;span class="nn"&gt;blog&lt;/span&gt; &lt;span class="nn"&gt;to&lt;/span&gt; &lt;span class="nn"&gt;Jekyll&lt;/span&gt;
&lt;span class="n"&gt;new&lt;/span&gt;                  &lt;span class="n"&gt;Creates&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Jekyll&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt; &lt;span class="n"&gt;scaffold&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;PATH&lt;/span&gt;
&lt;span class="n"&gt;serve&lt;/span&gt;                &lt;span class="n"&gt;Serve&lt;/span&gt; &lt;span class="n"&gt;your&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt; &lt;span class="n"&gt;locally&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Rakefile&lt;/h3&gt;
&lt;p&gt;Jekyll-Bootstrap提供了一个Rakefile（ruby的makefile），包含一些博客相关的任务（task），包括：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ rake -T
rake page           &lt;span class="c1"&gt;# Create a new page.&lt;/span&gt;
rake post           &lt;span class="c1"&gt;# Begin a new post in ./_posts&lt;/span&gt;
rake preview        &lt;span class="c1"&gt;# Launch preview environment&lt;/span&gt;
rake theme:install  &lt;span class="c1"&gt;# Install theme&lt;/span&gt;
rake theme:package  &lt;span class="c1"&gt;# Package theme&lt;/span&gt;
rake theme:switch   &lt;span class="c1"&gt;# Switch between Jekyll-bootstrap themes.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;进阶篇&lt;/h1&gt;
&lt;h2&gt;放弃Jekyll bootstrap&lt;/h2&gt;
&lt;p&gt;Jekyll bootstrap确实能带来一些变量，但是和RoR一样，充满了各种puzzle。
更加让中国人不爽的是，作者将其缩写定义为“JB”。&lt;/p&gt;
&lt;p&gt;经过初步的尝试后，我决定放弃JB，也不想尝试&lt;a href="http://octopress.org/"&gt;Octopress&lt;/a&gt;。我的选择是用原生的Jekyll来构建博客，让一切都在掌控之中。&lt;/p&gt;
&lt;h2&gt;Jekyll的目录结构&lt;/h2&gt;
&lt;p&gt;使用Jekyll创建一个干净的站点：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jekyll new clearly
$ tree clearly/
clearly/
├── _config.yml
├── _layouts
│   ├── default.html
│   └── post.html
├── _posts
│   └── 2013-05-29-welcome-to-jekyll.markdown
├── css
│   ├── main.css
│   └── syntax.css
└── index.html
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，博客文章放在_posts目录中，可以使用子目录。
博客文章必须使用
    YEAR-MONTH-DAY-title.MARKUP
的形式命名，比如：
    2011-12-31-new-years-eve-is-awesome.md&lt;/p&gt;
&lt;p&gt;_layouts目录存放页面模板，其他还可以使用html、css、image等静态资源。&lt;/p&gt;
&lt;p&gt;Jekyll会把任何不以下划线开头的文件和目录都复制/生成到网站（在本地是生成到_site/目录)。&lt;/p&gt;
&lt;h2&gt;设计模板&lt;/h2&gt;
&lt;p&gt;jekyll把_layouts目录中的文档看做是模板，如果某个文档中的头部变量声明中指定了layout：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---
layout: post
...
---
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;则Jekyll在生成页面时会使用该模板进行渲染，用文档的内容替换模板中的{{ content }}部分。&lt;/p&gt;
&lt;p&gt;模板本身也是文档，所以一个模板也可以用layout变量指定使用一个模板作为布局，这就是模板的继承。&lt;/p&gt;
&lt;p&gt;此外，在设计模板时，利用好Liquid语言的include语法能够带来很大的变量。被包含的页面部件需要放在_includes文件夹中。&lt;/p&gt;
&lt;p&gt;因为Jekyll生成的是静态站点，可能会需要大量的js以增加动态特性，在设计模板时要遵循&lt;a href="http://dev.opera.com/articles/view/the-seven-rules-of-unobtrusive-javascrip/"&gt;Unobtrusive JavaScript原则&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;灵活的导航&lt;/h2&gt;
&lt;p&gt;使用静态的导航菜单会带来两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文档过长&lt;/li&gt;
&lt;li&gt;“当前项”的高亮不好处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以在_config.yml中设置一个导航菜单的变量：&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
    menuitems:
    - name:         首页
      url:          /index.html
    - name:         分类
      url:          /categories.html
    - name:         标签
      url:          /tags.html
    - name:         归档
      url:          /archive.html
    - name:         读书
      url:          /reading.html
    - name:         工作
      url:          /working.html
    - name:         关于
      url:          /about.html&lt;/p&gt;
&lt;p&gt;然后在模板的导航部分可以这样写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;ul&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;nav&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  {/% for item in site.menuitems %/}
    {/% if item.url == page.url %/}
    &lt;span class="nt"&gt;&amp;lt;li&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;active&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    {/% else %/}
    &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;
    {/% endif %/}
    &lt;span class="nt"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="nv"&gt;item.url&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="nv"&gt;item.name&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
  {/% endfor %/}
&lt;span class="nt"&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;分类、标签、归档和RSS&lt;/h2&gt;
&lt;p&gt;这些都是博客站点必须有的元素。分类、标签和归档可以安装不同的方式检索博客文章；RSS可以订阅博客。&lt;/p&gt;
&lt;p&gt;用Jekyll的变量和模板很容易实现这些元素。&lt;/p&gt;
&lt;p&gt;注意：不管文件的扩展名是md、html还是xml、txt，只要文件的头部包含变量声明，Jekyll的模板引擎就会对其进行处理。
其中md和html文件都会处理为html，其他类型会保持扩展名。&lt;/p&gt;
&lt;p&gt;但如果不是写文档，最好不要使用md，否则会按照markdown语法进行渲染，带来一些意想不到的麻烦。&lt;/p&gt;
&lt;p&gt;具体的例子可以参考JB中的代码。&lt;/p&gt;
&lt;p&gt;你可能需要对每个分类、每个标签建立单独的索引页面，这个活手工做比较麻烦，可以使用Jekyll插件或者自己写脚本生成文件，
但这不符合“KISS”原则，这里不进行探讨。&lt;/p&gt;
&lt;p&gt;对于标签云(tag cloud)，在不使用插件的情况下，可以使用js实现，参考如下代码：
{% highlight html %}
    &lt;div class="tag-cloud"&gt;
       {/% for tag in site.tags %/}
          &lt;a href="/pages/tags.html#{/{ tag[0] }/}-ref" id="{/{ forloop.index }/}" class="__tag" style="margin: 5px"&gt;{/{ tag[0] }/}&lt;/a&gt;
       {/% endfor %/}
    &lt;/div&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
   $(function() {
      var minFont = 15.0,
          maxFont = 40.0,
          diffFont = maxFont - minFont,
          size = 0;

      {/% assign max = 1.0 %/}
      {/% for tag in site.tags %/}
         {/% if tag[1].size &amp;gt; max %/}
            {/% assign max = tag[1].size %/}
         {/% endif %/}
      {/% endfor %/}

      {/% for tag in site.tags %/}
         size = (Math.log(&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="nv"&gt;.size&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;) / Math.log(&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;max&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;)) * diffFont + minFont;
         $(&amp;quot;#&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nb"&gt;forloop&lt;/span&gt;&lt;span class="nv"&gt;.index&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&amp;quot;).css(&amp;quot;font-size&amp;quot;, size + &amp;quot;px&amp;quot;);
      {/% endfor %/}
   });
&lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;关于分类和标签的设计，可以参考&lt;a href="http://thinkinside.tk/2012/11/05/blog_design_categories_and_tags.html"&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;分页&lt;/h2&gt;
&lt;p&gt;TODO: ajax分页
TODO: 浮动标题 on paginator&lt;/p&gt;
&lt;h2&gt;语法高亮&lt;/h2&gt;
&lt;p&gt;对于程序员，博客中难免会包含一些代码。实现代码高亮可以有几种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用外部资源，比如&lt;a href="https://gist.github.com/"&gt;GitHub Gist&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单，但是需要使用外部链接或通过js嵌入到页面，不利于文档和代码的统一维护&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用js在前端渲染，比如&lt;a href="https://code.google.com/p/google-code-prettify/"&gt;google-code-prettify&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单高效，对语言的支持不够多&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Jekyll插件，比如调用&lt;a href="http://pygments.org/"&gt;pygments&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推荐方式。支持&lt;a href="http://pygments.org/languages/"&gt;100多种语言&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;~~~本站采取js的方式。只需要在post的模板中进行配置，就可以为所有博文的代码进行渲染~~~&lt;/p&gt;
&lt;p&gt;~~~Jekyll在编译markdown时，会将符合“代码格式”的内容放到一个&amp;lt; pre&amp;gt;&amp;lt; code&amp;gt;&lt;/ code&gt;&amp;lt; /pre&amp;gt;标签中。~~~
~~~而prettify提供的js会对html中的所有&amp;lt; pre&amp;gt;&amp;lt; /pre&amp;gt;或&amp;lt; code&amp;gt;&lt;/ code&gt;区块进行处理，甚至会自动判断使用的语言。~~~&lt;/p&gt;
&lt;p _="%" endhighlight&gt;~~~在post模板的合适位置中增加以下内容：~~~
{% highlight html %}
&lt;link href="/js/google-code-prettify/prettify.css" rel="stylesheet"&gt;
&lt;script src="/js/google-code-prettify/prettify.js"&gt;&lt;/script&gt;
&lt;script&gt;
$(document).ready(function(){
     prettyPrint();
});
&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;~~~如果要更改配色方案，只需要修改css文件。~~~&lt;/p&gt;
&lt;p&gt;本站采用pygments的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装pygments&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;pip install pygments&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在_config.yml中设置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;pygments:       true&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在代码的前后增加过滤器：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight ruby linenos %}&lt;/p&gt;
&lt;p _="%/" endhighlight&gt;{/% highlight ruby linenos %/}
def foo
  puts 'foo'
end&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改样式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从&lt;a href="https://github.com/mojombo/tpw/blob/master/css/syntax.css"&gt;这里&lt;/a&gt;获取css样例，并自行更改。&lt;/p&gt;
&lt;h2&gt;文档目录(TODO)&lt;/h2&gt;
&lt;p&gt;如果写比较长的文章，提供一个类似于developerworks上的文档目录进行导航可以方便阅读。&lt;/p&gt;
&lt;h2&gt;使用公式&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.mathjax.org/"&gt;MathJax&lt;/a&gt; is an open source JavaScript display engine for mathematics that works in all modern browsers.&lt;/p&gt;
&lt;p&gt;使用maruku来解析markdown文件，可以把LaTeX解析成图片，&lt;/p&gt;
&lt;p&gt;优点是网页加载速度快。但是在windows下安装复杂，且需要安装有LaTeX
        Mathjax  &lt;a href="http://www.mathjax.org/"&gt;http://www.mathjax.org/&lt;/a&gt;，缺点是动态加载，速度慢。&lt;/p&gt;
&lt;p&gt;参考：http://chen.yanping.me/cn/blog/2012/03/10/octopress-with-latex/&lt;/p&gt;
&lt;h2&gt;处理图片&lt;/h2&gt;
&lt;p&gt;设置一个IMAGE_ROOT变量，可以可以在post中设置，也可以在post的模板中通过指定的规则capture（或者assign）。&lt;/p&gt;
&lt;p&gt;则引可以使用{{page.IMAGE_ROOT}}/xxx.png的形式插入图片，便于以后的调整和管理。&lt;/p&gt;
&lt;p&gt;{{page.url}}
page_url&lt;/p&gt;
&lt;h2&gt;处理表格(TODO)&lt;/h2&gt;
&lt;h2&gt;博客搬家（TODO）&lt;/h2&gt;
&lt;p&gt;用Jekyll写博客的，通常不会是新博主，会存在博客搬家的需求。&lt;/p&gt;
&lt;p&gt;Jekyll提供了一个import的子命令(需要插件jekyll-import），可以将旧的博客导入到Jekyll。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thomasf/exitwp"&gt;exitwp&lt;/a&gt;是一个用python开发的工具，号称是将wordpress的博客导出并转换成markdown，但实际上
任何能导出rss/atom的博客都可以用这个工具进行转换。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/thomasf/exitwp
sudo pip install --upgrade  -r pip_requirements.txt
cd exitwp/wordpress-xml/
wget http://your/atom/file/xml
cd ..
python exitwp.py
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;推广篇&lt;/h1&gt;
&lt;h2&gt;使用域名&lt;/h2&gt;
&lt;p&gt;Github Pages会为站点分配类似"USERNAME.github.com"的二级域名。你也可以使用自己的域名。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;申请域名&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;免费的域名(.tk)可以在&lt;a href="http://www.dot.tk/zh/index.html"&gt;DotTK&lt;/a&gt;申请。&lt;/p&gt;
&lt;p&gt;.tk是南太平洋岛国托克劳的国家域名，支持域名转发（可隐藏原URL）、电邮转发、A记录解析、CNAME别名记录、MX邮件记录、设置DNS服务器等服务。&lt;/p&gt;
&lt;p&gt;收费的域名到处有，是否使用国内的域名商随你。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;域名解析服务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说域名提供商会提供简单的解析服务，也支持将解析服务指向到其他的提供者。&lt;/p&gt;
&lt;p&gt;国外的如&lt;a href="http://www.godaddy.com/"&gt;Godaddy&lt;/a&gt;，可能被墙。&lt;/p&gt;
&lt;p&gt;国内的如&lt;a href="https://www.dnspod.cn/"&gt;DNSPod&lt;/a&gt;，有免费版。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在jekyll站点中增加CNAME文件，记录使用的域名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果使用顶级域名，在域名解析服务提供商那里将A记录指向&lt;a href="1"&gt;204.232.175.78&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果使用二级域名，在域名解析服务提供商那里增加CNAME记录，指向&lt;a href="1"&gt;204.232.175.78&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;社会化网络&lt;/h2&gt;
&lt;p&gt;Jekyll生成的是静态网站，诸如评论、推荐、关注之类的功能就无法实现了。&lt;/p&gt;
&lt;p&gt;不过好在现在有很多社会化网络应用，通过混搭(marshup) 可以把各种各样第三方的功能部件（widgets）加到你的博客中。&lt;/p&gt;
&lt;p&gt;与博客相关的Widget主要有几类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;社会化评论&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;专门提供评论功能的网站，可以为博客增加评论功能。也可能附带着关注、相关文章、推荐等功能。&lt;/p&gt;
&lt;p&gt;国外的有&lt;a href="http://disqus.com/"&gt;disqus&lt;/a&gt;，国内的有&lt;a href="http://www.uyan.cc/"&gt;友言&lt;/a&gt;，&lt;a href="http://duoshuo.com/"&gt;多说&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;社会化推荐&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;自动推荐跨站的相关文章。包括自动推相关文章。&lt;/p&gt;
&lt;p&gt;国内的有&lt;a href="http://www.ujian.cc/publishers"&gt;友荐&lt;/a&gt;，&lt;a href="http://www.wumii.com/widget/relatedItems.htm"&gt;无觅&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Jekyll本身也可以实现站内文章推荐的功能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;社会化分享&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将自己喜欢的网址分享给别人，通常附带推荐功能。&lt;/p&gt;
&lt;p&gt;国内的有&lt;a href="http://www.jiathis.com/"&gt;加网&lt;/a&gt; ，&lt;a href="http://share.baidu.com/"&gt;百度分享&lt;/a&gt;等。其中加网提供了划词分享功能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;社交网站&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以发布简短的动态。比如Twitter, Facebook, Google Plus, 新浪微博等网站。与博客的联动可以是自己发布博客动态，
   也可以是由别人推荐（这种方式即为社会化推荐）。&lt;/p&gt;
&lt;p&gt;如果是自己发布动态，需要让别人能够方便的“关注/Follow”你，最好提供“一键关注的按钮”，或者提供连接能够让别人在这些网上方便的找到你。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;社会化登录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;没懂，感觉也就是OpenID或OAuth的集合。暂时不予考虑。&lt;/p&gt;
&lt;p&gt;由于存在着伟大的墙，我只好尽量选择国内的社会化网络资源。对于更喜欢的国外的资源，尽量考虑如何不拖慢墙内用户的访问速度。&lt;/p&gt;
&lt;p&gt;我对社会化网络资源的利用方式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;评论功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只选一个，我选择了&lt;a href="http://www.uyan.cc/"&gt;友言&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推荐功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以有多个，那么先加上友荐和无觅，Jekyll自带的相关文章功能也在测试中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分享功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只选一个，还是选择&lt;a href="http://share.baidu.com/"&gt;百度分享&lt;/a&gt;吧，与&lt;a href="http://tongji.baidu.com/web/welcome/login"&gt;百度统计&lt;/a&gt;可以勾搭在一起，而且据说有利于百度的SEO。&lt;/p&gt;
&lt;h2&gt;流量分析和统计&lt;/h2&gt;
&lt;p&gt;第三方的流量分析和统计工具可以说是最古老的marshup，尽管没有社会化网络的功能。&lt;/p&gt;
&lt;p&gt;可以选择的有国外的&lt;a href="http://www.google.cn/intl/zh-CN_ALL/analytics/"&gt;Google Analysis&lt;/a&gt;、&lt;a href="http://www.sitemeter.com"&gt;SiteMeter&lt;/a&gt;和国内的&lt;a href="http://tongji.baidu.com/web/welcome/login"&gt;百度统计&lt;/a&gt;、
   &lt;a href="http://linezing.com"&gt;量子恒道统计&lt;/a&gt;等。&lt;/p&gt;
&lt;p&gt;出于种种无奈，还是选择了百度。&lt;/p&gt;</content><category term="blog"></category></entry><entry><title>用nginX+keepalived实现高可用的负载均衡</title><link href="http://holbrook.github.io/2013/05/27/nginx_keepalived.html" rel="alternate"></link><published>2013-05-27T00:00:00+08:00</published><updated>2013-05-27T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-05-27:/2013/05/27/nginx_keepalived.html</id><summary type="html">&lt;p&gt;实施nginx和keepalived的规划、安装、配置等步骤。&lt;/p&gt;</summary><content type="html">&lt;p&gt;前面的&lt;a href="http://thinkinside.tk/weblayer_nginx_keepalived/"&gt;《统一web访问层方案》&lt;/a&gt;中就目的、目标和整体方案进行了讨论，本文讨论具体的实施。简单来说就是在两台服务器上分别部署NginX，并通过keepalived实现高可用。&lt;/p&gt;
&lt;h1&gt;1 规划和准备&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;需要统一访问的应用系统：
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;应用系统&lt;/th&gt;&lt;th&gt; 域名/虚拟目录&lt;/th&gt;&lt;th&gt;应用服务器及URL&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;svn&lt;/td&gt;&lt;td&gt;  dev.mycompany.com/svn   &lt;/td&gt;&lt;td&gt;http://50.1.1.21/svn&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;svn web管理&lt;/td&gt;&lt;td&gt;    dev.mycompany.com/submin    &lt;/td&gt;&lt;td&gt;http://50.1.1.21/submin&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;网站    &lt;/td&gt;&lt;td&gt;www.mycompany.com  &lt;/td&gt;&lt;td&gt;http://50.1.1.10; http://50.1.1.11; http://50.1.1.12&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;OA&lt;/td&gt;&lt;td&gt;   oa.mycompany.com    &lt;/td&gt;&lt;td&gt;http://50.1.1.13:8080; http://50.1.1.14:8080&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;web访问服务器&lt;/p&gt;
&lt;p&gt;用两台接入服务器50.1.1.3/4分别作为主、备(MASTER、BACKUP)服务器，使用RHEL5.6x64，配置了yum 私服。&lt;/p&gt;
&lt;p&gt;两台接入服务器公用一个虚拟IP（VIP）：50.1.1.2&lt;/p&gt;
&lt;h1&gt;2 安装&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;两台接入服务器分别安装NginX和keepalived:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c1"&gt;#准备依赖包：&lt;/span&gt;
    yum -y install gcc pcre-devel zlib-devel openssl-devel

    &lt;span class="c1"&gt;#下载&lt;/span&gt;
    wget http://nginx.org/download/nginx-1.2.4.tar.gz
    wget http://www.keepalived.org/software/keepalived-1.2.7.tar.gz

    &lt;span class="c1"&gt;#安装NginX&lt;/span&gt;
    tar zxvf nginx-1.2.4.tar.gz
    &lt;span class="nb"&gt;cd&lt;/span&gt; nginx-1.2.4
    ./configure
    make &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install

    &lt;span class="c1"&gt;#安装keepalived&lt;/span&gt;
    tar zxvf keepalived-1.2.7.tar.gz
    &lt;span class="nb"&gt;cd&lt;/span&gt; keepalived-1.2.7
    ./configure
    make
    make install

    cp /usr/local/etc/rc.d/init.d/keepalived /etc/rc.d/init.d/
    cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/
    mkdir /etc/keepalived
    cp /usr/local/etc/keepalived/keepalived.conf /etc/keepalived/
    cp /usr/local/sbin/keepalived /usr/sbin/

    &lt;span class="c1"&gt;#加入启动&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/usr/local/nginx/sbin/nginx&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/rc.local
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/etc/init.d/keepalived start&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/rc.local
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;3 配置&lt;/h1&gt;
&lt;h2&gt;3.1 配置NginX&lt;/h2&gt;
&lt;p&gt;两台接入服务器的NginX的配置完全一样,主要是配置/usr/local/nginx/conf/nginx.conf的http。其中多域名指向是通过虚拟主机（配置http下面的server）实现；同一域名的不同虚拟目录通过每个server下面的不同location实现；到后端的服务器在http下面配置upstream,然后在server或location中通过proxypass引用。要实现前面规划的接入方式，http的配置如下：&lt;/p&gt;
&lt;p&gt;{% highlight c %}
    http {
        include       mime.types;
        default_type  application/octet-stream;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;sendfile&lt;/span&gt;        &lt;span class="nt"&gt;on&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="nt"&gt;upstream&lt;/span&gt; &lt;span class="nt"&gt;dev&lt;/span&gt;&lt;span class="nc"&gt;.hysec.com&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;21&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;


    &lt;span class="nt"&gt;upstream&lt;/span&gt; &lt;span class="nt"&gt;www&lt;/span&gt;&lt;span class="nc"&gt;.hysec.com&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;ip_hash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;11&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;12&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="nt"&gt;upstream&lt;/span&gt; &lt;span class="nt"&gt;oa&lt;/span&gt;&lt;span class="nc"&gt;.hysec.com&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;ip_hash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;13&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;14&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


    &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;listen&lt;/span&gt;      &lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;server_name&lt;/span&gt; &lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;svn&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;submin&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;

    &lt;span class="nt"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;listen&lt;/span&gt;       &lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;server_name&lt;/span&gt;  &lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nt"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;listen&lt;/span&gt;       &lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;server_name&lt;/span&gt;  &lt;span class="n"&gt;oa&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;oa&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;验证方法：&lt;/p&gt;
&lt;p&gt;首先用IP访问前表中各个应用服务器的url，再用域名和路径访问前表中各个应用系统的域名/虚拟路径&lt;/p&gt;
&lt;h2&gt;3.2 配置keepalived&lt;/h2&gt;
&lt;p&gt;按照上面的安装方法，keepalived的配置文件在/etc/keepalived/keepalived.conf。主、从服务器的配置相关联但有所不同。如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Master配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight c %}&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;! Configuration File for keepalived

global_defs {
notification_email {
        wanghaikuo@hysec.com
        wanghaikuo@gmail.com
   }

   notification_email_from wanghaikuo@hysec.com
   smtp_server smtp.hysec.com
   smtp_connect_timeout 30
   router_id nginx_master

}

vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 101
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        50.1.1.2
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Backup配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight c %}
    ! Configuration File for keepalived&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;global_defs {
notification_email {
        wanghaikuo@hysec.com
        wanghaikuo@gmail.com
   }

   notification_email_from wanghaikuo@hysec.com
   smtp_server smtp.hysec.com
   smtp_connect_timeout 30
   router_id nginx_backup

}

vrrp_instance VI_1 {
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 99
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        50.1.1.2
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先后在主、从服务器上启动keepalived:&lt;/p&gt;
&lt;p&gt;/etc/init.d/keepalived start&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在主服务器上查看是否已经绑定了虚拟IP：&lt;/p&gt;
&lt;p&gt;ip addr&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止主服务器上的keepalived:&lt;/p&gt;
&lt;p&gt;/etc/init.d/keepalived stop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后在从服务器上查看是否已经绑定了虚拟IP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动主服务器上的keepalived，看看主服务器能否重新接管虚拟IP&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;3.3 让keepalived监控NginX的状态&lt;/h2&gt;
&lt;p&gt;经过前面的配置，如果主服务器的keepalived停止服务，从服务器会自动接管VIP对外服务；一旦主服务器的keepalived恢复，会重新接管VIP。 但这并不是我们需要的，我们需要的是当NginX停止服务的时候能够自动切换。&lt;/p&gt;
&lt;p&gt;keepalived支持配置监控脚本，我们可以通过脚本监控NginX的状态，如果状态不正常则进行一系列的操作，最终仍不能恢复NginX则杀掉keepalived，使得从服务器能够接管服务。&lt;/p&gt;
&lt;p&gt;如何监控NginX的状态
最简单的做法是监控NginX进程，更靠谱的做法是检查NginX端口，最靠谱的做法是检查多个url能否获取到页面。&lt;/p&gt;
&lt;p&gt;如何尝试恢复服务
如果发现NginX不正常，重启之。等待3秒再次校验，仍然失败则不再尝试。&lt;/p&gt;
&lt;p&gt;根据上述策略很容易写出监控脚本。这里使用nmap检查nginx端口来判断nginx的状态，记得要首先安装nmap。监控脚本如下:&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="c1"&gt;# check nginx server status&lt;/span&gt;
&lt;span class="nv"&gt;NGINX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/nginx/sbin/nginx
&lt;span class="nv"&gt;PORT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;80

nmap localhost -p &lt;span class="nv"&gt;$PORT&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PORT&lt;/span&gt;&lt;span class="s2"&gt;/tcp open&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;#echo $?&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -ne &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nv"&gt;$NGINX&lt;/span&gt; -s stop
    &lt;span class="nv"&gt;$NGINX&lt;/span&gt;
    sleep 3
    nmap localhost -p &lt;span class="nv"&gt;$PORT&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PORT&lt;/span&gt;&lt;span class="s2"&gt;/tcp open&amp;quot;&lt;/span&gt;
    &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -ne &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; /etc/init.d/keepalived stop
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;不要忘了设置脚本的执行权限，否则不起作用。&lt;/p&gt;
&lt;p _="%" c highlight&gt;假设上述脚本放在/opt/chk_nginx.sh，则keepalived.conf中增加如下配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vrrp_script chk_http_port {
    script &amp;quot;/opt/chk_nginx.sh&amp;quot;
    interval 2
    weight 2
}

track_script {
    chk_http_port
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p _="%" c highlight&gt;更进一步，为了避免启动keepalived之前没有启动nginx , 可以在/etc/init.d/keepalived的start中首先启动nginx:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;start() {
    /usr/local/nginx/sbin/nginx
    sleep 3
    echo -n $&amp;quot;Starting &lt;span class="nv"&gt;$prog&lt;/span&gt;: &amp;quot;
    daemon keepalived &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;KEEPALIVED_OPTIONS&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
    RETVAL=$?
    echo
    [ &lt;span class="nv"&gt;$RETVAL&lt;/span&gt; -eq 0 ] &lt;span class="err"&gt;&amp;amp;&amp;amp;&lt;/span&gt; touch /var/lock/subsys/&lt;span class="nv"&gt;$prog&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;4 还可以做什么&lt;/h1&gt;
&lt;p&gt;对于简单重复性劳动，人总是容易犯错，这种事情最好交给机器去做。 比如，在这个案例中，作为统一接入服务器，可能经常要修改nginx的配置、nginx下面的html文件等。而且，一定要保证集群中的每台服务器的配置相同。 最好的做法是由配置管理服务器来管理，如果没有，也可以使用简单的linux文件同步来解决。&lt;/p&gt;
&lt;h1&gt;5 支持https&lt;/h1&gt;
&lt;p&gt;需要安装openSSL：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install openssl-devel
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在nginx/conf下生成秘钥：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}
    #生成RSA密钥
    openssl dsaparam -rand -genkey -out myRSA.key 1024&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#生成CA密钥：(要输入一个自己记得的密码)
openssl gendsa -des3 -out cert.key myRSA.key

#用这个CA密钥来创建证书，需要上一步创建的密码
openssl req -new -x509 -days 365 -key cert.key -out cert.pem

#把证书设置为root专用
chmod 700 cert.*

#生成免密码文件
openssl rsa -in cert.key -out cert.key.unsecure
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;如果要启用SSL，首先在安装nginx是要增加配置参数：--with-http_ssl_module ，
然后在nginx中进行如下配置：&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight c %}
    # 这里是SSL的相关配置
    server {
      listen 443;
      server_name www.example.com; # 你自己的域名
      root /home/www;
      ssl on;
      ssl_certificate cert.perm;
      #使用.unsecure文件可以在nginx启动时不输入密码
      ssl_certificate_key cert.key.unsecure;
      location / {
      #...
      }
    }&lt;/p&gt;
&lt;p&gt;公共证书的申请过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生成RSA(私钥)文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;openssl genrsa -des3 -out myRSA.key 2048&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成csr文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;openssl req -new -key myRSA.key -out my.csr&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将csr提交给证书机构，比如GlobalSign。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;证书机构会返回私有证书(crt)和中级证书（crt）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到机构网站下载根证书（root_CA.cer), 将根证书拼接到私有证书之后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在nginx中配置证书：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;{% highlight c %}
    ssl_certificate /etc/ssl/my.crt;
    ssl_certificate_key /etc/ssl/myRSA.key;
    ssl_client_certificate /etc/ssl/root_CA.cer;&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;6 支持webservice&lt;/h1&gt;
&lt;p&gt;通过chunkin-nginx-module模块支持webservice。&lt;/p&gt;
&lt;p&gt;否则会报错：411：http 头中缺少 Conten-Length 参数&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}
    git clone https://github.com/agentzh/chunkin-nginx-module.git&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#重新编译nginx
cd PATH/TO/NGINX/SOURCE
./configure xxx --add-module=/PATH/TO/chunkin-nginx-module
make &amp;amp;&amp;amp; make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p _="%" c highlight&gt;在nginx的server{}节点中增加配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;chunkin on;

error_page 411 = @my_411_error;

location @my_411_error {
    chunkin_resume;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;7 状态监控&lt;/h1&gt;
&lt;p&gt;编译时需要增加&lt;code&gt;--with-http_stub_status_module&lt;/code&gt;参数。&lt;/p&gt;
&lt;p&gt;查看编译参数：使用命令&lt;code&gt;/usr/local/nginx/sbin/nginx -V&lt;/code&gt;&lt;/p&gt;
&lt;p _="%" highlight nginx&gt;安装好之后增加配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;location /nginx_status {
    stub_status on;
    access_log   off;
    # deny all;
    allow all;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;重新加载配置后，会看到一些文本：&lt;/p&gt;
&lt;p&gt;Active connections: 1 （对后端发起的活动连接数）&lt;/p&gt;
&lt;p&gt;server accepts handled requests&lt;/p&gt;
&lt;p&gt;5 5 5  （处理连接个数，成功握手次数，处理请求数）&lt;/p&gt;
&lt;p&gt;Reading: 0 Writing: 1 Waiting: 0 （读取客户端header数，返回客户端header数，等待数即active-reading-writing）&lt;/p&gt;</content><category term="cluster"></category></entry><entry><title>重拾vim</title><link href="http://holbrook.github.io/2013/05/23/vim_addon_manager.html" rel="alternate"></link><published>2013-05-23T00:00:00+08:00</published><updated>2013-05-23T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-05-23:/2013/05/23/vim_addon_manager.html</id><summary type="html">&lt;p&gt;从emacs切换回vim&lt;/p&gt;</summary><content type="html">&lt;p&gt;以前在&lt;a href="http://www.cnblogs.com/holbrook/" title="心内求法"&gt;博客园&lt;/a&gt;时，用&lt;a href="http://www.cnblogs.com/holbrook/archive/2012/04/12/2444992.html" title="Emacs学习笔记(9):org-mode，最好的文档编辑利器，没有之一"&gt;emacs org-mode&lt;/a&gt; 写博客，并且写了一系列&lt;a href="http://www.cnblogs.com/holbrook/tag/emacs/" title="emacs 学习笔记"&gt;《emacs 学习笔记》&lt;/a&gt;。
emacs 和 org-mode 的强大毋庸置疑，但是经过1年多的使用，还是有些不适应：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;小手指很受伤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过于依赖配置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于我的工作要经常登录到linux服务器进行操作，这就带来了一个问题：
   服务器上的emacs在不配置的情况下几乎无法使用，但是在服务器上使用vim，又不符合手指中记忆的快捷键。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;emacs有点重，比如不得不使用的ecb,cedet,jdee等等，都是大块头。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我还没有做好准备去掌握Erlang语言。但是对于vim，我可以使用我喜欢的python去写插件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过艰难的取舍，还是决定在个人工作领域也回到vim。保护手指，保护大脑。&lt;/p&gt;
&lt;h1&gt;插件管理器(Vundle)&lt;/h1&gt;
&lt;p&gt;重新关注vim后，首先发现了一系列插件管理器。主要有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/gmarik/vundle"&gt;Vundle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=2905"&gt;vim-addon-manager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=2332"&gt;pathogen.vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=3458"&gt;vvundle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/c9s/Vimana"&gt;vvimana&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过简单的比较，我选择了Vundle。这里不想对上述插件管理器做一个完整的对比，只是简单说一个我看中的Vundle的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只需要维护需要的插件列表就可以统一安装，同样，复制环境时也只需要复制一个文件(.vimrc)&lt;/li&gt;
&lt;li&gt;支持git更新&lt;/li&gt;
&lt;li&gt;支持插件搜索功能&lt;/li&gt;
&lt;li&gt;自动管理插件依赖关系&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;安装Vundle&lt;/h2&gt;
&lt;p&gt;安装Vundle只需要一条命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你使用git管理vim配置，还可以使用git submodule：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git submodule add https://github.com/gmarik/vundle.git vim/bundle/vundle
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会在.gitmodule中增加如下配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[submodule &amp;quot;vim/bundle/vundle&amp;quot;]&lt;/span&gt;
    &lt;span class="na"&gt;path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;vim/bundle/vundle&lt;/span&gt;
&lt;span class="s"&gt;    url = https://github.com/gmarik/vundle.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;之后运行git命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git submodule init
git submodule update
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;即可。&lt;/p&gt;
&lt;h2&gt;配置插件&lt;/h2&gt;
&lt;p&gt;在.vimrc中配置需要的插件，作者给出了一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set nocompatible               &amp;quot; be iMproved
filetype off                   &amp;quot; required!
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()


&amp;quot; let Vundle manage Vundle
&amp;quot; required!
Bundle &amp;#39;gmarik/vundle&amp;#39;


&amp;quot; My Bundles here:
&amp;quot;
&amp;quot; original repos on github
Bundle &amp;#39;tpope/vim-fugitive&amp;#39;
Bundle &amp;#39;Lokaltog/vim-easymotion&amp;#39;
Bundle &amp;#39;rstacruz/sparkup&amp;#39;, {&amp;#39;rtp&amp;#39;: &amp;#39;vim/&amp;#39;}
Bundle &amp;#39;tpope/vim-rails.git&amp;#39;
&amp;quot; vim-scripts repos
Bundle &amp;#39;L9&amp;#39;
Bundle &amp;#39;FuzzyFinder&amp;#39;
&amp;quot; non github repos
Bundle &amp;#39;git://git.wincent.com/command-t.git&amp;#39;
&amp;quot; ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于重名的Vim插件，需要在插件后面加上作者的姓氏， 比如 Bundle 'Javascript-Indentation'&lt;/li&gt;
&lt;li&gt;对于插件名称中包含空格和斜杠的情况， 需要将空格和斜杠替换为 -&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;安装插件&lt;/h2&gt;
&lt;p&gt;只需要在启动vim后，运行命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:BundleInstall
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vbundle就会自动安装或更新前面配置好的插件&lt;/p&gt;
&lt;h2&gt;其他操作&lt;/h2&gt;
&lt;p&gt;使用帮助：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:h vundle
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看插件清单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:BundleList
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;搜索插件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:BundleSearch markdown
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;清理不用的插件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:BundleClean
#或者
:BundleClean markdown
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;必备插件（TODO）&lt;/h1&gt;
&lt;p&gt;下面是我使用的一些vim插件，直接在.vimrc中配置。可以在 &lt;a href="https://github.com/holbrook/macENV/blob/master/vimrc"&gt;github&lt;/a&gt; 查看。&lt;/p&gt;
&lt;h2&gt;编辑器增强&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/scrooloose/nerdtree"&gt;NERDTree&lt;/a&gt;（Bundle 'The-NERD-tree'）可以在窗口左侧打开文件浏览器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bundle 'vim-orgmode'&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Bundle 'winmanager'&lt;/li&gt;
&lt;li&gt;Bundle 'SuperTab'&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;语法高亮&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Markdown（Bundle 'Markdown'） markdown文件的语法高亮&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;vim基本操作&lt;/h1&gt;
&lt;p&gt;以前整理过一个 &lt;a href="http://www.cnblogs.com/holbrook/archive/2009/05/13/2357377.html"&gt;vim 常用命令备忘&lt;/a&gt;, 如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="images/2013/vim_addon_manager/vim_cheet_sheet.xlsx"&gt;vim_cheet_sheet.xlsx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;别人的一个更详细的版本：&lt;/p&gt;
&lt;p&gt;&lt;a href="images/2013/vim_addon_manager/vi-vim-cheat-sheet-list.png"&gt;vi-vim-cheat-sheet-list&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果已经有一定的基础，还可以使用vim cheat sheet。下面的图分别可以用于打印版或者桌面背景。&lt;/p&gt;
&lt;p&gt;&lt;img alt="打印版，Eng" src="images/2013/vim_addon_manager/vi-vim-cheat-sheet.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="打印版，Chs" src="images/2013/vim_addon_manager/vi-vim-cheat-sheet-sch.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="桌面版，Eng" src="images/2013/vim_addon_manager/vi-vim_cheat_sheet_dark.png"&gt;&lt;/p&gt;</content><category term="vim"></category></entry><entry><title>《统计学》读书笔记(1/17:一些基本概念)</title><link href="http://holbrook.github.io/2013/05/12/2013-05-12-statistics_intro_1.html" rel="alternate"></link><published>2013-05-12T00:00:00+08:00</published><updated>2013-05-12T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-05-12:/2013/05/12/2013-05-12-statistics_intro_1.html</id><summary type="html">&lt;p&gt;第一章，介绍统计学能解决的问题以及解决问题的思路。\n统计学将现象分为个体随机性和总体的规律性，通过随机现象找到总体的规律。而规律就是变量之间的关系。最好，列出了一些常用的统计软件。&lt;/p&gt;</summary><content type="html">&lt;p&gt;@&lt;a href="http://book.douban.com/subject/2193810/"&gt;豆瓣&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;统计是什么&lt;/h1&gt;
&lt;p&gt;统计是人类思维的一个归纳过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从现实世界中收集数据&lt;/li&gt;
&lt;li&gt;分析收集到的数据&lt;/li&gt;
&lt;li&gt;从分析结果得出结论&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于统计的一个例子如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;站在一个路口，看到每过去20辆小轿车时，也有100辆自行车通过，同时记录每辆车上的人数（收集）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均每10个轿车载有12个人，每辆自行车上只有1人（分析）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以，小汽车和自行车在这个路口的运载能力为24:100（结论）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1&gt;统计学是什么&lt;/h1&gt;
&lt;p&gt;统计学（statistics），是用以收集数据，分析数据和由数据得出结论的一组概念、原则和方法。&lt;/p&gt;
&lt;p&gt;主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何有效的收集数据&lt;/li&gt;
&lt;li&gt;如果数据和指标的关系缺乏模型，如何用统计方法建立模型&lt;/li&gt;
&lt;li&gt;如何评价数据的有效性&lt;/li&gt;
&lt;li&gt;如何得出结论&lt;/li&gt;
&lt;li&gt;如何利用数据和模型进行预测&lt;/li&gt;
&lt;li&gt;如何用图形化的方式表现统计结论&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，统计模型是从数据产生的，会根据新的数据不断改进，最终会被新的模型（可能不是统计模型）所代替。&lt;/p&gt;
&lt;p&gt;统计学的一些特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统计学的思维方式是归纳为主，而不是演绎为主&lt;/li&gt;
&lt;li&gt;统计学是应用学科，是为具体目标服务的，不形成自己的数学体系&lt;/li&gt;
&lt;li&gt;统计学可以应用到大量的学科&lt;/li&gt;
&lt;li&gt;有些学科已经形成了与统计学结合的分支学科，如经济计量学(econometrics)，数据挖掘(Data Mining)等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于统计学的应用性和交叉性，统计学需要一些其他学科的基础，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各种可能用到的数学&lt;/li&gt;
&lt;li&gt;计算机&lt;/li&gt;
&lt;li&gt;其他领域的知识&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面列举一些可以用统计学解决的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你买了一台电视时，被告知三年内可以免费保修。你想过厂家凭什么这样说吗？说多了，厂家会损失；说少了，会失去竞争，也是损失。到底这个保修期是怎样决定的呢？&lt;/li&gt;
&lt;li&gt;大学排名是一个非常敏感的问题。不同的机构得出不同的结果；各自都说自己是客观、公正和有道理的。到底如何理解这些不同的结果呢？&lt;/li&gt;
&lt;li&gt;任何公司都有一个信用问题。当然，在这些公司试图得到贷款时并没有不还贷的不良记录。如何根据它们的财务和商业资料来判断一个公司的信用等级呢？&lt;/li&gt;
&lt;li&gt;我国东部和西部的概念是一个比较笼统的概念。如何能够根据需要，选择一些指标来把各省，或各市县甚至村进行分类呢？&lt;/li&gt;
&lt;li&gt;疾病传播时，如何能够通过感染者入院前后的各种因素得到一个疾病传染方式的模型呢？&lt;/li&gt;
&lt;li&gt;如何通过大众调查来得到性别、年龄、职业、收入等各种因素与公众对某项事物（比如商品或政策）的态度的关系呢？&lt;/li&gt;
&lt;li&gt;一个从来没有研究过红楼梦的统计学家如何根据比较写作习惯得出红楼梦从哪一段开始就不是曹雪芹的手笔了呢？&lt;/li&gt;
&lt;li&gt;如何才能够客观地得到某个电视节目的收视率，以确定广告的价格是否合理呢？&lt;/li&gt;
&lt;li&gt;如何确定观众/听众是否忠实于某节目？&lt;/li&gt;
&lt;li&gt;如何对电视节目排名次？&lt;/li&gt;
&lt;li&gt;什么因素影响一个节目的收视率？&lt;/li&gt;
&lt;li&gt;如何按照各种不同环境估计某商店的顾客人数？&lt;/li&gt;
&lt;li&gt;如何按照各种指标评价雇员？&lt;/li&gt;
&lt;li&gt;如何把地区(市县镇等)按照各种指标分类？&lt;/li&gt;
&lt;li&gt;如何确定红楼梦第几回不是曹雪芹所写？&lt;/li&gt;
&lt;li&gt;如何确定一个产品的可靠性？&lt;/li&gt;
&lt;li&gt;如何进行偏差较少的民意调查？&lt;/li&gt;
&lt;li&gt;如何根据一些财务数据发现漏税的嫌疑单位?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;随机性和规律性，概率和机会&lt;/h1&gt;
&lt;p&gt;自然科学的很多领域有确定性，但其他的领域存在着随机性（randomness），比如吸烟与寿命的关系。&lt;/p&gt;
&lt;p&gt;随机性与很多不易说清的因素有关。&lt;/p&gt;
&lt;p&gt;对于一些现象，虽然个体存在随机性，但是总体却可能存在规律性——统计规律。&lt;/p&gt;
&lt;p&gt;这种总体性的规律体现为概率（probability)，描述某件事情发生的机会有多大。&lt;/p&gt;
&lt;p&gt;有些概率是精确的，比如掷骰子时每个点数出现的概率都是1/6。&lt;/p&gt;
&lt;p&gt;有些概率无法精确推断,比如你周末去公园的概率是8成。&lt;/p&gt;
&lt;p&gt;从随机性的个体现象推导出规律性的统计结论，就是统计学存在的意义。&lt;/p&gt;
&lt;h1&gt;统计结果/统计结论是否有效？&lt;/h1&gt;
&lt;p&gt;统计学可以从个体现象（数据）得到结论。但是结论是否有效？&lt;/p&gt;
&lt;p&gt;依靠统计学的部门很有可能闹笑话，比如xx局和xx局。那么，该如何评价统计的结果或者结论？&lt;/p&gt;
&lt;p&gt;这里面需要注意几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据可以有误或作假&lt;/li&gt;
&lt;li&gt;统计方法（有意或无意）使用不当可以误导。有低级误导和高级误导。&lt;/li&gt;
&lt;li&gt;常识判断和直觉是重要的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是一些统计结论，可以思考一些如何理解这些结论的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“明天降水概率为40％”&lt;/li&gt;
&lt;li&gt;“我冬天去新加坡度假的概率为10％”&lt;/li&gt;
&lt;li&gt;“该节目收视率是30%”&lt;/li&gt;
&lt;li&gt;“调查结果表明20%的观众喜欢某节目”&lt;/li&gt;
&lt;li&gt;“抽样调查结果的误差为±3%”&lt;/li&gt;
&lt;li&gt;“支持率的95％置信区间为(25%,30%)”&lt;/li&gt;
&lt;li&gt;“某学校排名第一”&lt;/li&gt;
&lt;li&gt;“某县是贫困县”&lt;/li&gt;
&lt;li&gt;“某国的综合竞争力排名第43位”&lt;/li&gt;
&lt;li&gt;“该国家属于发展中国家”&lt;/li&gt;
&lt;li&gt;“该药品疗效99%”&lt;/li&gt;
&lt;li&gt;“该国贫富差距大”&lt;/li&gt;
&lt;li&gt;“这个县收入比那个县高”&lt;/li&gt;
&lt;li&gt;“该结果统计显著”&lt;/li&gt;
&lt;li&gt;“消费价格指数为120%”&lt;/li&gt;
&lt;li&gt;“他的血压已经正常了”&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;统计学描述问题的方法：常量，变量和数据&lt;/h1&gt;
&lt;p&gt;统计学将研究的对象分为总体，样本和个体。
总体，样本和个体都有其属性。&lt;/p&gt;
&lt;p&gt;对于确定的属性，称为常量(constant)；对于不确定性的属性，称为变量(variable)。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一节火车车厢有多少坐位是一个常量；车厢中旅客的人数是一个变量&lt;/li&gt;
&lt;li&gt;一个学校的在校男女生比例是一个常量；该校任意一群学生的男女生比例是一个变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变量根据是否为数值类型可以区分为定量变量（数据变量，随机变量）和定性变量（属性变量，分类变量）&lt;/p&gt;
&lt;p&gt;定量变量的值是数值类型，比如身高身高体重，购买某商品的人数等等。由于定量变量的值是随机的，所以又称为随机变量。&lt;/p&gt;
&lt;p&gt;定性变量的值是非数值类型，比如性别，观点等。定性变量描述对象的属性，用于表达对象的类别，也叫做属性变量或分类变量。&lt;/p&gt;
&lt;p&gt;为了便于用模型描述定性变量，通常将定性变量抽象为离散的值。类似于枚举类型。&lt;/p&gt;
&lt;p&gt;数据：就是关于变量的每个实例的实际值/观测值。&lt;/p&gt;
&lt;p&gt;通常能获得一部分数据，是对于真实情况的不完全的观测。&lt;/p&gt;
&lt;p&gt;统计学的方法可以根据这些不完全的观测推断出全体的规律性。比如掷骰子的实验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常量：骰子有6个面&lt;/li&gt;
&lt;li&gt;分类变量：奇数，偶数&lt;/li&gt;
&lt;li&gt;数据：掷1000次骰子的实际点数&lt;/li&gt;
&lt;li&gt;分析：奇数次数493，偶数次数507&lt;/li&gt;
&lt;li&gt;结论：？？？&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;变量之间的关系&lt;/h1&gt;
&lt;p&gt;通常，单个的变量没有意义，人们更加关心变量之间的关系。比如，职业种类与收入是否有关系？政府投入与经济增长是否有关系？
除了上述二元关系，还有复杂的多变量关系，如企业的固定资产、流动资产、预算分配、管理模式、生产率、债务和利润。&lt;/p&gt;
&lt;p&gt;如同本文开始所说，有些关系可以明确确定，有些关系只能依靠统计学作出推断。&lt;/p&gt;
&lt;h2&gt;定量变量间的关系&lt;/h2&gt;
&lt;p&gt;比如，一组广告投入和销售额之间的数据，做成二维点图（散点图）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="1" src="images/2013/statistics_intro/1.png"&gt;&lt;/p&gt;
&lt;p&gt;通常对于变量之间的关系会研究以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这两个变量是否有关系？（相关性）&lt;/li&gt;
&lt;li&gt;如果有，它们的关系是否显著？&lt;/li&gt;
&lt;li&gt;这些关系是什么关系，能否用数学模型来描述？&lt;/li&gt;
&lt;li&gt;这个关系是否带有普遍性？（是否只对此样本有效？——需要收集更多数据）&lt;/li&gt;
&lt;li&gt;这个关系是不是因果关系？（需要排除其他因素的影响才能判断）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;因果关系是对变量关系的深入分析&lt;/p&gt;
&lt;p&gt;不是因果关系也可以用来作为推断的依据&lt;/p&gt;
&lt;p&gt;比如，中西医对疾病的因果关系的理解不同&lt;/p&gt;
&lt;p&gt;但是从统计结果上来看，中西医都具有疗效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照变量类型的不同，变量之间的关系可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定量变量间的关系&lt;/li&gt;
&lt;li&gt;定性变量间的关系&lt;/li&gt;
&lt;li&gt;定性定量变量间的混合关系&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;常用的统计软件&lt;/h1&gt;
&lt;p&gt;统计学涉及到大量数据的计算，离不开统计软件的支持（在应用计算机之前，主要通过查表的方式得到计算结果）。常用的统计软件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;R
  这是一个免费的，由志愿者管理的软件。其编程语言与S-plus所基于的S语言一样，很方便。还有不断加入的各个方向统计学家编写的统计软件包。同时从网上可以不断更新和增加有关的软件包和程序。这是发展最快的软件，受到世界上统计师生的欢迎。是用户量增加最快的统计软件。对于一般非统计工作者来说，主要问题是它没有“傻瓜化”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S-plus
  这是统计学家喜爱的软件。不仅由于其功能齐全，而且由于其强大的编程功能，使得研究人员可以编制自己的程序来实现自己的理论和方法。它也在进行“傻瓜化”以争取顾客。但仍然以编程方便为顾客所青睐。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SPSS
  这是一个很受欢迎的统计软件；它容易操作，输出漂亮，功能齐全，价格合理。对于非统计工作者是很好的选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Excel
  严格说来并不是统计软件，但作为数据表格软件，必然有一定统计计算功能。而且凡是有Microsoft Office的计算机，基本上都装有Excel。但要注意，有时在装Office时没有装数据分析的功能，那就必须装了才行。当然，画图功能是都具备的。对于简单分析，Excel还算方便，但随着问题的深入，Excel就不那么“傻瓜”，需要使用函数，甚至根本没有相应的方法了。多数专门一些的统计推断问题还需要其他专门的统计软件来处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SAS
  这是功能非常齐全的软件；尽管价格不菲，许多公司还是因为其功能众多和某些美国政府机构认可而使用。尽管现在已经尽量“傻瓜化”，仍然需要一定的训练才可以进入。对于基本统计课程则不那么方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Minitab
  这个软件是很方便的功能强大而又齐全的软件，也已经“傻瓜化”，在我国用的不如SPSS与SAS那么普遍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Statistica
  也是功能强大而齐全的“傻瓜化”的软件，在我国用的也不如SAS与SPSS那么普遍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Eviews
  这是一个主要处理回归和时间序列的软件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GAUSS
  这是一个很好用的统计软件，许多搞经济的喜欢它。主要也是编程功能强大。目前在我国使用的人不多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FORTRAN
  这是应用于各个领域的历史很长的非常优秀的编程软件，功能强大，也有一定的统计软件包。计算速度比这里介绍的都快得多。但需要编程和编译。操作不那么容易。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MATLAB
  这也是应用于各个领域的以编程为主的软件，在工程上应用广泛。编程类似于S和R。但是统计方法不多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="统计学"></category></entry><entry><title>技术分析的理论体系</title><link href="http://holbrook.github.io/2013/01/26/technical_analysis.html" rel="alternate"></link><published>2013-01-26T00:00:00+08:00</published><updated>2013-01-26T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-01-26:/2013/01/26/technical_analysis.html</id><summary type="html">&lt;p&gt;100个股民可能有101种分析手段，但通常都是采用技术分析（Technical Analysis,TA)。本文视图整理技术分析理论的总体理论框架，以便对于研究内容有一个定位和界定，并作为今后学习的索引。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;价值投资和趋势投资&lt;/h1&gt;
&lt;p&gt;投资的终极目的就是获利；为了获利，就要找出价格变化的一些规律； 通过不同的手段发现价格规律，就形成了不同的投资策略。 策略的不同，体现了投资者看待市场角度的不同。&lt;/p&gt;
&lt;p&gt;大体来说，证券市场的投资策略主要有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;价值投资。分析证券的内在价值，当证券的价格与内在价值发生偏离（高估或低估）时，就产生了投资机会。&lt;/li&gt;
&lt;li&gt;趋势投资。预测价格的变化趋势，当证券的价格变化具有明显趋势时，就产生了投资机会。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一度以来，人们认为价值投资比较容易量化，操作稳健，是投资的正统，其他的都是旁门左道。 比如《有价证券分析》的作者本杰明·格雷厄姆就说过：“投资是基于详尽的分析，本金的安全和满意回报有保证的操作。不符合这一标准的操作就是投机。”&lt;/p&gt;
&lt;p&gt;但个人认为，价值投资和趋势投资（或者说投资和投机）并没有本质的区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所谓的价值投资，也是对趋势的一种预测。价值投资认为从长期来看，股票价格的趋势是向“内在价值”回归。&lt;/li&gt;
&lt;li&gt;价值投资也存在假设，价值投资的前提和假设是：股票价格围绕“内在价值 ”的稳固基点上下波动。该假设并没有被明确的证明。&lt;/li&gt;
&lt;li&gt;价值投资并不容易量化。尽管价值投资认为内在价值可以用一定的、量化的方法来测定，但是信息获取的范围、来源、准确性、时效不同，以及分析方法的不同，会导致完全不同的估值结果。&lt;/li&gt;
&lt;li&gt;价值投资也不能保证本金的安全和满意的回报。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然价值投资和趋势投资并没有本质的不同，但是两种方法有各自适用的场合。&lt;/p&gt;
&lt;p&gt;对于机构投资者等大资金的投资者，每次操作（买入或卖出）都会产生较大的成本，需要一段时间周期才能完成。这就决定了大资金投资者通常不会频繁操作，而且 需要“先知先觉”，在趋势明显确定之前就开始操作以保证能够在合适的时点完成操作，对于这种较长期的投资，更倾向于价值投资；&lt;/p&gt;
&lt;p&gt;而对于散户，收集信息非常困难并明显滞后，但是资金量小“船小好调头”，通常采用短线操作，更青睐趋势投资。&lt;/p&gt;
&lt;p&gt;当然，两种投资理念并不是冲突的，完全可以根据情况结合使用。&lt;/p&gt;
&lt;h1&gt;何为技术分析&lt;/h1&gt;
&lt;p&gt;无论是价值投资还是趋势投资，都需要通过某种手段进行分析，获取未来价格变化的趋势。&lt;/p&gt;
&lt;p&gt;价值投资通过基本面分析预测未来某一时点/时段证券的内在价值（价格变化的趋势就是向内在价值靠近）；趋势投资通过技术分析预测今后较短一段时间内价格变化的趋势。&lt;/p&gt;
&lt;p&gt;二者的本质区别在于着眼点的不同。基本面分析的目标是证券的内在属性，影响内在价值的因素五花八门，大到国际形势，小到公司管理细节。 技术分析的目标是市场行为，即当前情况下市场对证券价格会做出如何的反应。“当前情况”主要是当前（和历史）的成交价格及成交量，当然也可以包含很多五花八门的要素，比如黑子活动周期、月亮的阴晴圆缺等。&lt;/p&gt;
&lt;p&gt;如果要给技术分析一个明确的定义，可以参考&lt;a href="http://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90"&gt;维基百科的定义&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;技术分析是指研究过去金融市场的资讯（主要是经由使用图表）来预测价格的趋势决定投资的策略。纯理论上，技术分析只考虑市场或金融工具真实的价格行为。&lt;/p&gt;
&lt;h1&gt;理论基础和假设&lt;/h1&gt;
&lt;p&gt;所有的技术分析都是建立在三大假设之上的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;市场行为包容消化一切（价格变化反映一切）。&lt;/li&gt;
&lt;li&gt;价格以趋势方式演变。&lt;/li&gt;
&lt;li&gt;历史会重演。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果一定要为技术分析找到一个理论基础，大概可以算是凯恩斯的“空中楼阁理论”。其实这并不能算是一个理论，而仅仅是一个假设。&lt;/p&gt;
&lt;p&gt;凯恩斯认为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;证券的内在价值理论上是存在的，但是很难准确的进行长期预期;&lt;/li&gt;
&lt;li&gt;由于长期难以预测，所以应该关注短期。长期只不过是一连串短期的连接；&lt;/li&gt;
&lt;li&gt;在短期来说，价格并不是由内在价值决定的，而是由投资者心理决定的，是空中楼阁；&lt;/li&gt;
&lt;li&gt;获利需要顺势而为，在短期，就是要顺应投资者的心理和行为模式；&lt;/li&gt;
&lt;li&gt;短期价格体现了投资者的平均预期；&lt;/li&gt;
&lt;li&gt;一般人从心理上倾向于趋势会延续，除非预测到未来会变化的因素；&lt;/li&gt;
&lt;li&gt;在短期，投资者不需要关心证券的内在价值，而只需要关心平均预期及其可能发生的变化；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;凯恩斯的分析完全抛开了股票的内在价值，认为证券的价格在短期主要决定于投资者的心理预期，而不存在向内在价值靠拢的趋势。对于短期趋势的预测，就是对短期心理预期的预测。&lt;/p&gt;
&lt;h1&gt;技术分析理论派别&lt;/h1&gt;
&lt;p&gt;技术分析名为“技术”，但更像是“艺术”。技术分析没有严格的数学推理，更多的是依赖经验的总结。 证券市场众多的投资者根据自身的经验总结出了很多的“规律”。但是这些“规律”之间并不能互相映射。而且“规律”运用的程度和结果与使用者的经验有很大关系。&lt;/p&gt;
&lt;p&gt;目前被广泛认可的理论派别包括：&lt;a href="http://wiki.mbalib.com/wiki/%E9%81%93%E6%B0%8F%E7%90%86%E8%AE%BA"&gt;道氏理论&lt;/a&gt;、
&lt;a href="http://wiki.mbalib.com/wiki/%E6%B3%A2%E6%B5%AA%E7%90%86%E8%AE%BA"&gt;波浪理论&lt;/a&gt;和
&lt;a href="http://wiki.mbalib.com/w/index.php?title=%E6%B1%9F%E6%81%A9%E6%B3%95%E5%88%99&amp;amp;action=edit"&gt;江恩理论&lt;/a&gt; 。
各种规律都能或多或少在这些理论中找到影子。&lt;/p&gt;
&lt;p&gt;技术分析的理论严格来说并不能算是“理论”，上述三个派别都提出了趋势可能存在的类型及其特征，但是无法给出这些趋势存在或特征的证明。&lt;/p&gt;
&lt;h2&gt;道氏理论要点&lt;/h2&gt;
&lt;p&gt;道氏理论是所有市场技术研究的鼻祖。其创造者指明了技术分析的真谛：不是预测股市，而是反映市场趋势；是根据价格模式的研究,推测未来价格行为的一种方法。&lt;/p&gt;
&lt;p&gt;道氏理论在三个假设的基础上，提出了关于趋势的五个“定理”：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在3个级别的趋势 短期（持续几天–几周），中期（持续几周–几月），长期（持续几月–几年），次级走势围绕上级走势折返。&lt;/li&gt;
&lt;li&gt;存在一个市场的主要走势 主要走势是一种长期走势，代表市场的整体趋势，根据方向不同称为多头市场和空头市场（牛市和熊市）&lt;/li&gt;
&lt;li&gt;主要的空头市场包含三个主要的阶段 试探前一多头高点失败后的下跌；下跌一定程度后的反弹和调整；调整后的持续下跌&lt;/li&gt;
&lt;li&gt;主要的多头市场包含三个主要的阶段 前一空头下跌放缓；震荡上扬；持续走高&lt;/li&gt;
&lt;li&gt;存在次级折返走势，要分析其与主要走势的区别与联系&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;波浪理论要点&lt;/h2&gt;
&lt;p&gt;波浪理论号称“道氏理论告诉人们何谓大海，而波浪理论指导你如何在大海上冲浪”。其含义是道氏理论是一种定性的分析，而波浪理论在道氏理论的基础上实现了一定程度的定量分析。&lt;/p&gt;
&lt;p&gt;波浪理论在“群体心理”的假设上，提出价格的变化具有类似潮汐或波浪一样的形态。主要内容包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;5升3降是基本的形态&lt;/li&gt;
&lt;li&gt;各等级的波会互相叠加，但都各自符合基本形态&lt;/li&gt;
&lt;li&gt;存在9个等级的划分&lt;/li&gt;
&lt;li&gt;波浪的形态与时间无关，或者说，尽管波长可能不同，但波形一定符合基本形态&lt;/li&gt;
&lt;li&gt;在特定的趋势阶段下，对应的波浪会有一些明显的特征。反过来说，把握了波浪的特征，可以判断正处于趋势的哪个阶段&lt;/li&gt;
&lt;li&gt;波浪的某些特征可以向斐波那契数列、黄金分割率等数字上靠拢&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;江恩理论要点&lt;/h2&gt;
&lt;p&gt;江恩理论是一个“神奇”的理论，主要“神奇”在：江恩理论不仅引入了数学，还包含了天文、宗教等因素。江恩的一些作图方法看起来就像占星术或者周易。而且江恩理论对趋势的预测准确性非常高，甚至有人评价“不可思议”。&lt;/p&gt;
&lt;p&gt;由于江恩理论的神奇性，短期无法给出该理论的一个简要说明，这些内容留待以后研究。 但江恩理论的重要特征是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;周期性和一些“魔术数字”&lt;/li&gt;
&lt;li&gt;在预测趋势的同时，还提出了一整套的操作程序，对于错误的预测能够进行补救。如“十二条买卖规则”，“二十一条买卖守则”等&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;技术分析的应用方法&lt;/h1&gt;
&lt;p&gt;不管应用哪种技术分析理论，其应用方法是一样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据基本指标技术出趋势性指标&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些指标都是对历史数据中交易行为的一种量化，有些指标是简单计算出来的，也有的指标需要经过统计分析后得出。
   趋势性指标主要体现了量、价、时、空四大要素。
   也有人将指标划分为趋势型指标、超买超卖型指标、人气和意愿指标、大势领先指标等类别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对单个趋势性指标或多个指标的组合进行分析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以直接观察数字，也可以做出图形(比如K线、切线等）观察形态，最终得出对趋势的判断。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据预测到的趋势进行操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里需要注意的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由于趋势的预测不可能100%正确，所以要指定风险控制、资金管理等策略，简单的说就是先制定交易原则，以及预测失败的处理办法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同的趋势具有不同的敏感度，敏感度越高，其适用的时间范围就越小，风险也越大。对趋势级别的选择要和自己的操作级别相适应。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;资料&lt;/h1&gt;
&lt;p&gt;本文只是对技术分析理论的大体框架进行了最粗略的概览，要想深入学习，还需要阅读大量的资料。目前找到的资料包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;书籍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《股市晴雨表》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;《道氏理论》&lt;/li&gt;
&lt;li&gt;《专业投机原理》&lt;/li&gt;
&lt;li&gt;《股市趋势技术分析》&lt;/li&gt;
&lt;li&gt;《江恩测市法则》&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《在华尔街45年》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.ifta.org/"&gt;国际技术分析师联盟&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;市场技术分析师协会&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.aapta.us/"&gt;美国专业技术分析师协会&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.csta.org/"&gt;加拿大技术分析师公会&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.moneydj.com/z/analyst/analyst_home.htm"&gt;MoneyDJ技术分析学院&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.facebook.com/pages/tu-biao-ren-ji-shu-fen-xi/290418956236"&gt;图表人技术分析Facebook专页&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>你真的会数钱吗？</title><link href="http://holbrook.github.io/2013/01/01/money.html" rel="alternate"></link><published>2013-01-01T00:00:00+08:00</published><updated>2013-01-01T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-01-01:/2013/01/01/money.html</id><summary type="html">&lt;p&gt;货币，记账相关的领域模型，使用值对象&lt;/p&gt;</summary><content type="html">&lt;hr&gt;
&lt;p&gt;一篇旧的博文，原文发表在&lt;a href="http://www.cnblogs.com/holbrook/archive/2013/01/01/2841307.html"&gt;博客园&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;快年底了，假如你们公司的美国总部给每个人发了一笔201212.21美元的特别奖金，作为程序员的你， 该如何把这笔钱收入囊中？&lt;/p&gt;
&lt;h1&gt;1.美元？美元！&lt;/h1&gt;
&lt;p&gt;你可能觉得，这根本不是问题。在自己的账户中直接加上一笔“转入”就行了。但是首先就遇到了币种的问题。&lt;/p&gt;
&lt;p&gt;一般来说，银行账户都是单币种的。你可能会说不对啊，我的一卡通就能存入不同的币种啊？但那是一个“账号（Account Number）”对应的多个“账户(Account)”。 通常财务记账的时候，一个“账户(Account)”都使用同一币种。&lt;/p&gt;
&lt;p&gt;账户(Account)记录了资金的往来，包含很多条目(Entry)。账户会记录结余，结余等于所有条目中金额的总和。&lt;/p&gt;
&lt;p&gt;我们不可能为每个币种设计一种条目，所以需要抽象出一个货币类——Money，适用于各种不同的币种：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Money类" src="images/posts/domain/money/money.png"&gt;&lt;/p&gt;
&lt;p&gt;Money类至少要记录金额和币种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于金额，由于货币存在最小面额，所以金额的类型可以采用定点小数或者整型。考虑到会对金额进行一些运算，用整数处理应该更方便。如果用java语言实现，可以使用long类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于币种，java提供了java.util.Currency类，专门用于表示货币，符合ISO 4217货币代码标准。Currency使用Singleton模式，需要用getInstance方法获得实例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要的方法包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String getCurrencyCode() 获取货币的ISO 4217货币代码&lt;/li&gt;
&lt;li&gt;int getDefaultFractionDigits() 获取与此货币一起使用的默认小数位数&lt;/li&gt;
&lt;li&gt;static Currency getInstance(Locale locale) 返回给定语言环境的国家/地区的 Currency 实例&lt;/li&gt;
&lt;li&gt;static Currency getInstance(String currencyCode) 返回给定货币代码的 Currency 实例。&lt;/li&gt;
&lt;li&gt;String getSymbol() 获取默认语言环境的货币符号&lt;/li&gt;
&lt;li&gt;String getSymbol(Locale locale) 获取指定语言环境的货币符号&lt;/li&gt;
&lt;li&gt;String toString() 返回此货币的 ISO 4217 货币代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过Currency类的帮助，我们的Money类看起来大概是这个样子(为了方便，提供多种构造函数)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  public class Money {
      private long amount;
      private Currency currency;

      public double getAmount() {
          return BigDecimal.valueOf(amount, currency.getDefaultFractionDigits()).doubleValue();

      }

      public Currency getCurrency() {
          return currency;
      }

      public Money(double amount, Currency currency) {
          this.currency = currency;
          this.amount = Math.round(amount * centFactor());
      }

      public Money(long amount, Currency currency) {
          this.currency = currency;
          this.amount = amount * centFactor();
      }

      private static final int[] cents = new int[] { 1, 10, 100, 1000,10000 };

      private int centFactor() {
          return cents[currency.getDefaultFractionDigits()];
      }
  }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用Money类表示我们的$201212.21奖金，就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Money myMoney = new Money(201212.21,Currency.getInstance(Locale.US));
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;2.存入账户&lt;/h1&gt;
&lt;p&gt;终于解决了币种的问题，可以把钱存入账户了。存入的逻辑是：在条目中记录一笔账目，并计算账户的余额。&lt;/p&gt;
&lt;p&gt;不同币种之间相加或相减是没有意义的，为了避免人为错误，在Money的代码中就要禁止这种操作。我们可以采用抛出异常的方式。 为了简单起见，这里不再定义一个单独的"MoneyException"，而是直接使用java.lang.Exception:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public Money add(Money money) throws Exception{
    if(!money.getCurrency().equals(this.currency)){
        throw(new Exception(&amp;quot;different currency can&amp;#39;t be add&amp;quot;));
    }
    BigDecimal value = this.getAmount().add(money.getAmount());
    Money result = new Money(value.doubleValue(),this.getCurrency());
    return result;
}

public Money minus(Money money) throws Exception{
    if(!money.getCurrency().equals(this.currency)){
        throw(new Exception(&amp;quot;different currency can&amp;#39;t be minus&amp;quot;));
    }

    BigDecimal value =this.getAmount().add(money.getAmount().negate());
    Money result = new Money(value.doubleValue(),this.getCurrency());
    return result;

}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;3.收税&lt;/h1&gt;
&lt;p&gt;先不要高兴得太早，这笔钱属于“一次性所得”，需要交20%的个人所得税。税后所得应该是多少？&lt;/p&gt;
&lt;p&gt;你可能说：是80%。只要为Money加上一个multiply(double factor)方法就可以进行计算了。&lt;/p&gt;
&lt;p&gt;但是牵扯到了舍入的问题。由于货币存在最小单位，在做乘/除法运算的时候就要考虑到舍入的问题了。最好是能够控制舍入的行为。假如税务部门对于 舍入的计算有明确规定，我们也可以做一个遵纪守法的好公民。&lt;/p&gt;
&lt;p&gt;在java.math.BigDecimal中定义了7种舍入模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ROUND_UP：等于远离0的数。&lt;/li&gt;
&lt;li&gt;ROUND_DOWN：等于靠近0的数。&lt;/li&gt;
&lt;li&gt;ROUND_CEILING：等于靠近正无穷的数。&lt;/li&gt;
&lt;li&gt;ROUND_FLOOR：等于靠近负无穷的数。&lt;/li&gt;
&lt;li&gt;ROUND_HALFUP：等于靠近的数，若舍入位为5，应用ROUNDUP。&lt;/li&gt;
&lt;li&gt;ROUND_HALFDOWN：等于靠近的数，若舍入位为5，应用ROUNDDOWN。&lt;/li&gt;
&lt;li&gt;ROUND_HALFEVEN：舍入位前一位为奇数，应用ROUNDHALFUP；舍入位前一位为偶数，应用ROUNDHALFDOWN。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以借用这些模式作为参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public static final int ROUND_UP = BigDecimal.ROUND_UP;
public static final int ROUND_DOWN = BigDecimal.ROUND_DOWN;
public static final int ROUND_CEILING = BigDecimal.ROUND_CEILING;
public static final int ROUND_FLOOR = BigDecimal.ROUND_FLOOR;
public static final int ROUND_HALF_UP = BigDecimal.ROUND_HALF_UP;
public static final int ROUND_HALF_DOWN = BigDecimal.ROUND_HALF_DOWN;
public static final int ROUND_HALF_EVEN = BigDecimal.ROUND_HALF_EVEN;
public static final int ROUND_UNNECESSARY = BigDecimal.ROUND_UNNECESSARY;


public Money multiply(double multiplicand, int roundingMode) {
    BigDecimal amount = this.getAmount().multiply(new BigDecimal(multiplicand));
    amount = amount.divide(BigDecimal.ONE,roundingMode);
    return new Money(amount.doubleValue(),this.getCurrency());
}

public Money divide(double divisor, int roundingMode) {
    BigDecimal amount = this.getAmount().divide(new BigDecimal(divisor),
            roundingMode);
    Money result = new Money(amount.doubleValue(), this.getCurrency());
    return result;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;4.转成人民币&lt;/h1&gt;
&lt;p&gt;尽管各领域的国际化提了十几年，但是在国内想直接用美元消费还是有一定困难。所以你决定将这笔钱换成人民币。&lt;/p&gt;
&lt;p&gt;对于账户来说，就是在美元账户和人民币账户分别做一笔转出和转入。 转入和转出的amount值是不同的，因为涉及到币种转换的问题。 显然，账户对象不应该知道如何进行汇率转换，责任又落在了Money类上。&lt;/p&gt;
&lt;p&gt;最直观的做法是在Money类上增加一个convertTo(Currency currency)的方法。 但汇率实在是一个复杂的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汇率是经常变化的；&lt;/li&gt;
&lt;li&gt;汇率转换时的舍入处理会有相关的约定；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些复杂的问题处理如果直接放在Money类上会显得十分笨重，单独设计一个MoneyConverter类会比较好：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.Currency&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;interface&lt;/span&gt; &lt;span class="n"&gt;MoneyConverter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Money&lt;/span&gt; &lt;span class="n"&gt;convertTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Money&lt;/span&gt; &lt;span class="n"&gt;money&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Currency&lt;/span&gt; &lt;span class="n"&gt;currency&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们实现一个最简单的转化器，使用固定的汇率值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.math.BigDecimal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.Currency&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.Locale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SimpleMoneyConverter&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;MoneyConverter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;BigDecimal&lt;/span&gt; &lt;span class="n"&gt;DOLLAR_TO_CNY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BigDecimal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;6.2365&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Currency&lt;/span&gt; &lt;span class="n"&gt;DOLLAR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Currency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Locale&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;US&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Currency&lt;/span&gt; &lt;span class="n"&gt;CNY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Currency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Locale&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHINA&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Money&lt;/span&gt; &lt;span class="n"&gt;convertTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Money&lt;/span&gt; &lt;span class="n"&gt;money&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Currency&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="n"&gt;known&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;money&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCurrency&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="n"&gt;known&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;
            &lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;unknown currency&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;BigDecimal&lt;/span&gt; &lt;span class="n"&gt;factorSource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;BigDecimal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ONE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;factorTarget&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BigDecimal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ONE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;money&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCurrency&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DOLLAR&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="n"&gt;factorSource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DOLLAR_TO_CNY&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DOLLAR&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="n"&gt;factorTarget&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DOLLAR_TO_CNY&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;BigDecimal&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;money&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getAmount&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;multiply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;factorSource&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;divide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;factorTarget&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Money&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;doubleValue&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;known&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Currency&lt;/span&gt; &lt;span class="n"&gt;currency&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DOLLAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;currency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CNY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，即使是最简单的转换器，处理起来也比较麻烦。所以千万不要在Money类中做这件事情。&lt;/p&gt;
&lt;p&gt;通过转换器可以很容易得到转成人民币后的值。&lt;/p&gt;
&lt;h1&gt;5.分钱&lt;/h1&gt;
&lt;p&gt;有好处不能独享。这笔钱你决定和老婆三七开。当然，你三！&lt;/p&gt;
&lt;p&gt;这又是一个新的舍入问题：即使你指定各自的舍入计算方法，也不能保证各部分舍入后的值加总后仍等于原值。&lt;/p&gt;
&lt;p&gt;前面的“可定制乘除法”似乎不能很好的解决这个问题，所以我们需要一个新的方法： Money[] allocate(double[] ratioes)&lt;/p&gt;
&lt;p&gt;传入分配比例的数组，返回分配结果的数组。&lt;/p&gt;
&lt;p&gt;为了保证分配的公平，可以使用伪随机数来处理误差。&lt;/p&gt;
&lt;p&gt;该方法的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public Money[] allocate(double[] ratioes) throws Exception{
    if(ratioes.length==0){
        throw (new Exception(&amp;quot;there is no ratio&amp;quot;));
    }

    double ratioTotal = 0;
    for(double ratio:ratioes){
        ratioTotal += ratio;
    }

    if(0==ratioTotal){
        throw(new Exception(&amp;quot;total of ratioes is zero&amp;quot;));
    }


    double total = this.getAmount().doubleValue();
    double delta = total;
    Money[] results = new Money[ratioes.length];

    for(int i=0;i&amp;lt;ratioes.length;i++){
        double amount = total*ratioes[i]/ratioTotal;
        results[i] = new Money(amount,this.getCurrency());
        delta -= results[i].getAmount().doubleValue();
    }

    int i = (int)(Math.random() * ratioes.length);
    results[i] = results[i].minus(new Money(delta,this.getCurrency()));
    return results;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;6.记账&lt;/h1&gt;
&lt;p&gt;将一切重要的数据保存到数据库是很通常的做法。但是将Money保存到数据库的时候，你要小心了！&lt;/p&gt;
&lt;p&gt;Money不能作为单独的实体。如果把Money当做实体来处理，就会产生一些问题：&lt;/p&gt;
&lt;p&gt;会有很多实体关联到Money，比如本文中的Account，Entry等。
需要非常小心处理对Money对象的引用，避免多个实体引用到同一个Money对象。在第一点的前提下，这会变得很困难。
所以应该把Money嵌入到需要的实体中，而不是把Money作为单独的实体。这样，Money仅仅是实体对象（比如Entry）的一个属性，只不过其具有多个内置的属性值。&lt;/p&gt;
&lt;p&gt;在JPA中，可以使用@Embeddable来标注Money类。&lt;/p&gt;
&lt;p&gt;更复杂的情况是，由于一个Account中的所有Entry都应该具有相同的Currency，将Currency保存到Account中会更简洁，Entry中只记录ammount。&lt;/p&gt;
&lt;p&gt;可以为Money的currency属性增加@Transient标注，在Entry类的getMoney中进行组装。&lt;/p&gt;
&lt;h1&gt;7.来点高级的&lt;/h1&gt;
&lt;p&gt;在DDD（领域驱动设计）中，Money是典型的值对象（Value Object）。值对象与实体的根本区别是：值对象不需要进行标识（ID）。&lt;/p&gt;
&lt;p&gt;这会带来一些处理上的不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实体对象根据ID判断是否相等，值对象只根据内部属性值判断是否相等&lt;/li&gt;
&lt;li&gt;值对象通常小而且简单，创建的代价较小&lt;/li&gt;
&lt;li&gt;值对象只传递值，不传递对象引用，不用判断值对象是否指向同一个物理对象&lt;/li&gt;
&lt;li&gt;通常将值对象设计为通过构造函数进行属性设置，一旦创建就无法改变其属性值&lt;/li&gt;
&lt;li&gt;由于值对象根据内部属性值判等，我们要为Money类覆盖equals方法： public boolean equals(Object other)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;8.其他未尽事宜&lt;/h1&gt;
&lt;p&gt;我们还可以为Money类增加互相比较的方法（略）&lt;/p&gt;
&lt;p&gt;可以在构造函数中进行格式校验（略）&lt;/p&gt;
&lt;p&gt;可以增加一些帮助显式的方法 使用currency的getSymbol(Locale locale)方法、和NumberFormat的format方法，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;NumberFormat nf=NumberFormat.getCurrencyInstance(Locale.CHINA);

String s=nf.format(73084.803984);// result：￥73,084.80
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;9.小结&lt;/h1&gt;
&lt;p&gt;本文探讨如何在应用中处理货币类型，包括币种转换、各种计算、如何持久化等内容。&lt;/p&gt;
&lt;p&gt;货币类型是典型的值对象，本文也介绍了一点值对象的特点。更多的内容可以参考DDD。&lt;/p&gt;</content><category term="领域模型"></category></entry><entry><title>Java规则引擎规范：JSR94</title><link href="http://holbrook.github.io/2012/12/07/jsr94.html" rel="alternate"></link><published>2012-12-07T00:00:00+08:00</published><updated>2012-12-07T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-12-07:/2012/12/07/jsr94.html</id><summary type="html">&lt;p&gt;Java World似乎总会出现一些接口规范，这样做的好处是可以面向接口编程，可以在实现了该接口的产品/组件之间自由切换，避免被厂商绑架。 本文要介绍的JSR94:Java Rule Engine API，Java规则引擎API规范。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Java World似乎总会出现一些接口规范，这样做的好处是可以面向接口编程，可以在实现了该接口的产品/组件之间自由切换，避免被厂商绑架。 本文要介绍的&lt;a href="http://jcp.org/aboutJava/communityprocess/final/jsr094/index.html"&gt;JSR94:Java Rule Engine API&lt;/a&gt;，
Java规则引擎API规范。&lt;/p&gt;
&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;JSR-94是JCP(Java Community Process)制定的关于Java规则引擎API的规范，包括接口定义和示例代码。于2004年8月发布。 JSR-94定义了javax.rules和javax.rules.admin,前者包含了Java规则引擎运行时（Rumtime)API及异常（Exception）定义，后者包含了规则管理相关的API和异常定义。&lt;/p&gt;
&lt;h1&gt;规则管理API&lt;/h1&gt;
&lt;p&gt;规则管理API在javax.rules.admin中定义,主要包括以下类/接口：&lt;/p&gt;
&lt;p&gt;&lt;img alt="javax.rules.admin" src="images/rule-engine/javax.rules.admin.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rule：规则实体&lt;/li&gt;
&lt;li&gt;RuleExecutionSet：执行集，某个规则对应的动作&lt;/li&gt;
&lt;li&gt;LocalRuleExecutionSetProvider：用于从本地创建执行集，如InputStream,Reader等&lt;/li&gt;
&lt;li&gt;RuleExectuionSetProvider：用于从本地或远程创建执行集，如xml Element，Serializable等&lt;/li&gt;
&lt;li&gt;RuleAdministrator：用于获取ExecutionSetProvider，并管理执行集的注册/注销&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规则管理API实现的功能包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;装载规则（Rule）和执行集（RuleExecutionSet)&lt;/li&gt;
&lt;li&gt;执行集的注册/注销,只有注册的执行集对应的规则才能被客户访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;运行时API&lt;/h1&gt;
&lt;p&gt;运行时API在javax.rules中定义，主要包括以下类/接口：&lt;/p&gt;
&lt;p&gt;&lt;img alt="javax.rules" src="images/rule-engine/javax.rules.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RuleServiceProviderManager: 通过URL注册/注销RuleServiceProvider&lt;/li&gt;
&lt;li&gt;RuleServiceProvider: 提供对RuleRuntime和RuleAdministrator的访问&lt;/li&gt;
&lt;li&gt;RuleRuntime: 规则引擎运行时，可以创建规则会话&lt;/li&gt;
&lt;li&gt;RuleSession: 规则会话，用于执行规则&lt;/li&gt;
&lt;li&gt;RuleExecutionSetMetaData: 执行集元数据，包括name,url,description等。执行集元数据会被RuleSession使用&lt;/li&gt;
&lt;li&gt;StatelessRuleSession: 无状态规则会话&lt;/li&gt;
&lt;li&gt;StatefulRuleSession: 有状态规则会话&lt;/li&gt;
&lt;li&gt;Handle和ObjectFilter: 有状态会话维护会话状态的帮助类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规则引擎运行时API实现的功能包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册/注销规则引擎实例，只有注册的规则引擎实例才能被使用&lt;/li&gt;
&lt;li&gt;从注册的规则引擎实例创建Runtime&lt;/li&gt;
&lt;li&gt;从Runtime创建会话，包括有状态和无状态两种会话&lt;/li&gt;
&lt;li&gt;通过会话执行规则&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;异常定义&lt;/h1&gt;
&lt;p&gt;除了前面提到的主要类/接口外，JSR94还规定了规则引擎运行时及管理的一些异常，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="javax.rules.exceptions" src="images/rule-engine/javax.rules.exceptions.png"&gt;&lt;/p&gt;
&lt;h1&gt;代码示例&lt;/h1&gt;
&lt;p&gt;下面是使用Drools作为规则引擎实例的一个例子，规则文件使用了Drools的drl格式：&lt;/p&gt;
&lt;p&gt;JSR94Sample.java&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;com.sample&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.io.FileReader&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.ArrayList&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.HashMap&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.List&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.ConfigurationException&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.RuleRuntime&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.RuleServiceProvider&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.RuleServiceProviderManager&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.StatelessRuleSession&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.admin.LocalRuleExecutionSetProvider&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.admin.RuleAdministrator&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.admin.RuleExecutionSet&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.drools.jsr94.rules.RuleServiceProviderImpl&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;JSR94Sample&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;RuleServiceProvider&lt;/span&gt; &lt;span class="n"&gt;ruleProvider&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;initProvider&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;uri&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RuleServiceProviderImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;RULE_SERVICE_PROVIDER&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;Class&lt;/span&gt; &lt;span class="n"&gt;providerClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RuleServiceProviderImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//注册ruleProvider&lt;/span&gt;
            &lt;span class="n"&gt;RuleServiceProviderManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;registerRuleServiceProvider&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;providerClass&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//从RuleServiceProviderManager获取ruleProvider&lt;/span&gt;
            &lt;span class="n"&gt;ruleProvider&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RuleServiceProviderManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRuleServiceProvider&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ConfigurationException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;adminSample&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;


        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//获取RuleAdministrator实例&lt;/span&gt;
            &lt;span class="n"&gt;RuleAdministrator&lt;/span&gt; &lt;span class="n"&gt;admin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ruleProvider&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRuleAdministrator&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

            &lt;span class="c1"&gt;//获取RuleExectuionSetProvider&lt;/span&gt;
            &lt;span class="n"&gt;HashMap&lt;/span&gt; &lt;span class="n"&gt;properties&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;properties&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;My Rules&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;properties&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;A trivial rulebase&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;LocalRuleExecutionSetProvider&lt;/span&gt; &lt;span class="n"&gt;ruleExecutionSetProvider&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;admin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getLocalRuleExecutionSetProvider&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;properties&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//创建RuleExecutionSet&lt;/span&gt;
            &lt;span class="n"&gt;FileReader&lt;/span&gt; &lt;span class="n"&gt;reader&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FileReader&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bin/sample.drl&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;RuleExecutionSet&lt;/span&gt; &lt;span class="n"&gt;reSet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ruleExecutionSetProvider&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRuleExecutionSet&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reader&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;properties&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//注册RuleExecutionSet&lt;/span&gt;
            &lt;span class="n"&gt;admin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;registerRuleExecutionSet&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mysample&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;reSet&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;properties&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="o"&gt;}&lt;/span&gt;


    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;runtimeSampe&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//获取RuleRuntime, 创建会话&lt;/span&gt;
            &lt;span class="n"&gt;RuleRuntime&lt;/span&gt; &lt;span class="n"&gt;runtime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ruleProvider&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRuleRuntime&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;StatelessRuleSession&lt;/span&gt; &lt;span class="n"&gt;ruleSession&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StatelessRuleSession&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;runtime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRuleSession&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mysample&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;RuleRuntime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STATELESS_SESSION_TYPE&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//初始化输入数据&lt;/span&gt;
            &lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="n"&gt;message1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;message1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;message1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setStatus&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;HELLO&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="n"&gt;message2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;message2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Goodbye World&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;message2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setStatus&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;GOODBYE&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;


            &lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;inputs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;inputs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;inputs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//执行规则&lt;/span&gt;
            &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ruleSession&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeRules&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inputs&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;size&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++){&lt;/span&gt;
                &lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;message&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;


            &lt;span class="c1"&gt;//释放会话资源&lt;/span&gt;
            &lt;span class="n"&gt;ruleSession&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;release&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;


    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// TODO Auto-generated method stub&lt;/span&gt;
        &lt;span class="n"&gt;initProvider&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;adminSample&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;runtimeSampe&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;


    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Message&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;HELLO&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;GOODBYE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

        &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

        &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getMessage&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;message&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getStatus&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;status&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setStatus&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;规则文件使用的就是&lt;a href="/2012/12/06/rule_language.html"&gt;这里&lt;/a&gt;的例子。&lt;/p&gt;
&lt;h1&gt;实现JSR94的产品&lt;/h1&gt;
&lt;p&gt;主要的一些实现了JSR94的规则引擎产品如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.jboss.org/drools/"&gt;Drools&lt;/a&gt;:   开源  DRL,xDRL,DSL,Decision Table ReteOO  Eclipse,excel   文件系统    jar&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mandarax.sourceforge.net/"&gt;Mandarax&lt;/a&gt;:     开源  RuleML&lt;/li&gt;
&lt;li&gt;&lt;a href="http://openrules.com/"&gt;OpenRules&lt;/a&gt;:   开源  Decision Table  Rete    excel       war&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jlisa.sourceforge.net/"&gt;JLisa&lt;/a&gt;:   开源&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.fico.com/en/Products/DMTools/Pages/FICO-Blaze-Advisor-System.aspx"&gt;Blaze&lt;/a&gt;:    商业  SRL&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www-01.ibm.com/software/integration/business-rule-management/jrules-family/"&gt;WebSphere ILOG JRules&lt;/a&gt;:  商业&lt;/li&gt;
&lt;li&gt;&lt;a href="http://herzberg.ca.sandia.gov/"&gt;JESS&lt;/a&gt;:   商业&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;JSR94为规则引擎提供了公用标准API,为实现规则管理API和运行时API提供了指导规范, 目前已经获得很多开源/商业规则引擎产品的支持。 但是JSR94没有对&lt;a href="/2012/12/06/rule_language.html"&gt;规则的描述语言&lt;/a&gt;进行规范，导致各规则引擎产品大多采用自己私有的描述语言。&lt;/p&gt;</content><category term="规则引擎"></category><category term="Java"></category></entry><entry><title>Drools规则描述语言快速手册</title><link href="http://holbrook.github.io/2012/12/06/rule_language.html" rel="alternate"></link><published>2012-12-06T00:00:00+08:00</published><updated>2012-12-06T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-12-06:/2012/12/06/rule_language.html</id><summary type="html">&lt;p&gt;&lt;a href="/2012/03/20/rule_engine_1.html"&gt;在规则引擎中，通常会使用某种表述性的语言（而不是编程语言）来描述规则&lt;/a&gt;。
所以规则描述语言也是规则引擎的一个重要组成部分。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="/2012/03/20/rule_engine_1.html"&gt;在规则引擎中，通常会使用某种表述性的语言（而不是编程语言）来描述规则&lt;/a&gt;。
所以规则描述语言也是规则引擎的一个重要组成部分。&lt;/p&gt;
&lt;p&gt;目前在规则描述语言方面，并没有一个通用的标准获得规则引擎厂商的广泛支持，大部分规则描述语言都是厂商私有的。&lt;/p&gt;
&lt;p&gt;大体来说，规则语言可以分为结构化的（Structured)和基于标记的（Markup，通常为xml）。&lt;/p&gt;
&lt;p&gt;常见的规则描述语言包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;srl(Structured Rule Language) : Fair Isaac（以前是Blaze Software）定义的结构化规则描述语言&lt;/li&gt;
&lt;li&gt;drl(Drools Rule Language) : Jboss（以前是drools.org)定义的结构化规则描述语言&lt;/li&gt;
&lt;li&gt;RuleML(Rule Markup Language）: www.ruleml.org定义的xml规则描述语言&lt;/li&gt;
&lt;li&gt;SRML(Simple Rule Markup Language): xml规则描述语言&lt;/li&gt;
&lt;li&gt;BRML(Business Rules Markup Language):xml规则描述语言&lt;/li&gt;
&lt;li&gt;SWRL（A Semantic Web Rule Language):www.daml.org定义的xml规则描述语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不管是哪种规则描述语言，都需要描述一组条件以及在此条件下执行的操作（即规则）。&lt;/p&gt;
&lt;h1&gt;概览&lt;/h1&gt;
&lt;p&gt;下面是一个drl的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sample&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.sample.DroolsTest.Message&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;rule&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;when&lt;/span&gt;
        &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HELLO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;myMessage&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;then&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;myMessage&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setMessage&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Goodbye cruel world&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setStatus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GOODBYE&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;rule&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;GoodBye&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;when&lt;/span&gt;
        &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GOODBYE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;myMessage&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;then&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;myMessage&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完整的drl文件会包含以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;package 声明&lt;/li&gt;
&lt;li&gt;imports&lt;/li&gt;
&lt;li&gt;declares&lt;/li&gt;
&lt;li&gt;globals&lt;/li&gt;
&lt;li&gt;functions&lt;/li&gt;
&lt;li&gt;queries&lt;/li&gt;
&lt;li&gt;rules&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;package和import声明&lt;/h1&gt;
&lt;p&gt;与Java语言类似，drl的头部需要有package和import的声明。&lt;/p&gt;
&lt;p&gt;规则文件当中必须要有一个 &lt;strong&gt;package&lt;/strong&gt; 声明,同时 package 声明必须要放在规则文件的第一行。&lt;/p&gt;
&lt;h1&gt;规则定义&lt;/h1&gt;
&lt;p&gt;drl中，一个规则的标准结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;rule &amp;quot;name&amp;quot;
    attributes
    when
        LHS
    then
        RHS
end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个规则通常包括三个部分:属性部分(attribute)、条件 部分(LHS)和结果部分(RHS)。&lt;/p&gt;
&lt;h2&gt;条件部分(LHS)&lt;/h2&gt;
&lt;p&gt;在 LHS 当中,可以包含多个条件,如果 LHS 部分没空的话,那么引擎会自动添加一 个 eval(true)的条件。&lt;/p&gt;
&lt;p&gt;多个条件之间之间用可以使用 &lt;strong&gt;and&lt;/strong&gt; 或 &lt;strong&gt;or&lt;/strong&gt; 来进行连接。默认是 &lt;strong&gt;and&lt;/strong&gt; 关系。&lt;/p&gt;
&lt;p&gt;每个条件的语法为：&lt;/p&gt;
&lt;p&gt;[绑定变量名:]Object([field 约束])&lt;/p&gt;
&lt;p&gt;“绑定变量名”是可选的。绑定的变量可以在该LHS后续的条件中引用。&lt;/p&gt;
&lt;p&gt;“field 约束”是指当前对象里相关字段的条件限制, 多个约束之间可以用“&amp;amp;&amp;amp;”(and)、“||”(or)和“,”(and)来连接。&lt;/p&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;when&lt;/span&gt;
&lt;span class="x"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;customer&lt;/span&gt;&lt;span class="x"&gt;:Customer()&lt;/span&gt;
&lt;span class="x"&gt;then&lt;/span&gt;
&lt;span class="x"&gt;    ……&lt;/span&gt;


&lt;span class="x"&gt;when&lt;/span&gt;
&lt;span class="x"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;customer&lt;/span&gt;&lt;span class="x"&gt;:Customer(age&amp;gt;20,gender==􏰃male􏰃)&lt;/span&gt;
&lt;span class="x"&gt;    Order(customer==&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;customer&lt;/span&gt;&lt;span class="x"&gt;,price&amp;gt;1000)&lt;/span&gt;
&lt;span class="x"&gt;then&lt;/span&gt;
&lt;span class="x"&gt;    ……&lt;/span&gt;


&lt;span class="x"&gt;when&lt;/span&gt;
&lt;span class="x"&gt;    Customer(age&amp;gt;20 || (gender==&amp;#39;male&amp;#39; &amp;amp;&amp;amp; city==‘sh&amp;#39;))&lt;/span&gt;
&lt;span class="x"&gt;then&lt;/span&gt;
&lt;span class="x"&gt;    ……&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;约束中可以使用的比较操作符包括：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=、= =、!=、contains、not contains、 memberof、not memberof、matches、not matches
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;order&lt;/span&gt;&lt;span class="nd"&gt;:Order&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;age&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;orders&lt;/span&gt; &lt;span class="nt"&gt;contains&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;order&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="err"&gt;……&lt;/span&gt;


&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;order&lt;/span&gt;&lt;span class="nd"&gt;:Order&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt; &lt;span class="nt"&gt;memberOf&lt;/span&gt; &lt;span class="nt"&gt;orderNames&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;orderNames为数组或集合类型&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="err"&gt;……&lt;/span&gt;

&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt; &lt;span class="nt"&gt;matches&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;李.*&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;正则表达式匹配&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="err"&gt;……&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;结果部分(RHS)&lt;/h2&gt;
&lt;p&gt;RHS 部分定义了当LHS满足是要进行的操作。&lt;/p&gt;
&lt;p&gt;RHS中可以编写代码，可以使用 LHS 部分当中定义的绑定变量名以及drl头部定义的全局变量。&lt;/p&gt;
&lt;p&gt;在 RHS 当中虽然可以直接编写 Java 代码,但不建议在代码当中有条件判断,如果需要条件判断,那么请重新考虑将其放在 LHS 当中,否则就违背了使用规则的初衷。&lt;/p&gt;
&lt;h3&gt;使用宏函数&lt;/h3&gt;
&lt;p&gt;RHS中可以使用宏函数对工作空间(Working Memory)进行操作。当调用宏函数后，所有未设置“no-loop”属性的规则都会被重新匹配，符合条件的重新触发。&lt;/p&gt;
&lt;p&gt;宏函数包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert：将一个 Fact 对象插入到当前的 Working Memory&lt;/li&gt;
&lt;li&gt;update：对当前 Working Memory 中的 Fact 进行更新&lt;/li&gt;
&lt;li&gt;retract ：从 Working Memory 中删除某个 Fact 对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些宏函数都是StatefulSession中定义的方法。&lt;/p&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="err"&gt;……&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="nt"&gt;Customer&lt;/span&gt; &lt;span class="nt"&gt;cus&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;new&lt;/span&gt; &lt;span class="nt"&gt;Customer&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="nt"&gt;cus&lt;/span&gt;&lt;span class="nc"&gt;.setName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="nt"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;cus&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;


&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;age&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;10&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nc"&gt;.setAge&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nc"&gt;.getAge&lt;/span&gt;&lt;span class="o"&gt;()+&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="nt"&gt;update&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;


&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;age&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;10&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="nt"&gt;Customer&lt;/span&gt; &lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;new&lt;/span&gt; &lt;span class="nt"&gt;Customer&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nc"&gt;.setName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nc"&gt;.setAge&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nc"&gt;.getAge&lt;/span&gt;&lt;span class="o"&gt;()+&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;用新对象替换Working&lt;/span&gt; &lt;span class="nt"&gt;Memory中的旧对象&lt;/span&gt;
    &lt;span class="nt"&gt;update&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;drools&lt;/span&gt;&lt;span class="nc"&gt;.getWorkingMemory&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="nc"&gt;.getFactHandleByIdentity&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;


&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="nt"&gt;retract&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;modify代码块&lt;/h3&gt;
&lt;p&gt;modify代码块用于快速修改并更新(update)某个 Fact 对象的多个属性。语法及例子如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;modify&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;fact-expression&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;修改&lt;/span&gt; &lt;span class="n"&gt;Fact&lt;/span&gt; &lt;span class="err"&gt;属性的表达式&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;修改&lt;/span&gt; &lt;span class="nx"&gt;Fact&lt;/span&gt; &lt;span class="nx"&gt;属性的表达式&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;*&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;age&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nt"&gt;20&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="nt"&gt;modify&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;setId&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;super man&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;setAge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;drools宏对象&lt;/h3&gt;
&lt;p&gt;通过使用 drools 宏对象可以实现在规则文件里直接访问 Working Memory, 从而获取对当前的 Working Memory 的更多控制。&lt;/p&gt;
&lt;p&gt;drools 宏对象的常用方法包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;drools.getWorkingMemory()：获取当前的 WorkingMemory 对象&lt;/li&gt;
&lt;li&gt;drools.halt()：在当前规则执行完成后,不再执行 其它未执行的规则。&lt;/li&gt;
&lt;li&gt;drools.getRule()：得到当前的规则对象&lt;/li&gt;
&lt;li&gt;drools.insert(new Object)：向当前的 WorkingMemory 当中插入 指定的对象,功能与宏函数 insert 相同。&lt;/li&gt;
&lt;li&gt;drools.update(new Object)：更新当前的 WorkingMemory 中指定 的对象,功能与宏函数 update 相同。&lt;/li&gt;
&lt;li&gt;drools.update(FactHandle Object)：更新当前的 WorkingMemory 中指定 的对象,功能与宏函数 update 相同。&lt;/li&gt;
&lt;li&gt;drools.retract(new Object)：从当前的 WorkingMemory 中删除指 定的对象,功能与宏函数 retract 相 同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;when
    eval(true);
then
    Customer cus=new Customer();
    cus.setName(&amp;quot;张三&amp;quot;);
    drools.insert(cus)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;kcontext宏对象&lt;/h3&gt;
&lt;p&gt;kcontext 也是 Drools 提供的一个宏对象,它的作用主要是用来得到当前的 KnowledgeRuntime 对象,KnowledgeRuntime 对象可以实现与引擎的各种交互。&lt;/p&gt;
&lt;h2&gt;规则属性&lt;/h2&gt;
&lt;p&gt;主要的规则属性如下：&lt;/p&gt;
&lt;p&gt;13 个:  auto-focus、、lock-on-active、no-loop、 ruleflow-group、、when。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;salience&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置规则执行的优先级,数字越大越先执行，数字相同的使用随机顺序。默认值为0，可以设置为负数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no-loop&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认为false。设置为true时，表示该规则只会被引擎检查一次。引擎内部对Fact更新时，忽略本规则的再次检查。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;date-effective&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置规则的开始生效日期。默认接受“dd-MMM-yyyy”格式的字符串。可以用代码修改日期格式，如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.setProperty("drools.dateformat","yyyy-MM-dd")&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;date-expires&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置规则的过期日期。格式与&lt;code&gt;date-effective&lt;/code&gt;相同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;enabled&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认为true。设置规则是否可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dialect&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置规则中使用的编程语言。默认为java，还可以设置为mvel。通过drools.getRule().getDialect()可以获取该属性的设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;duration&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;延迟指定的时间后，在 &lt;strong&gt;另一个线程中&lt;/strong&gt; 触发规则。单位为毫秒。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;activation-group&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为规则划指定一个活动组（组名为字符串）。同一个活动组中的规则只执行一个，根据优先级(salience)来决定执行哪一个规则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;agenda-group 和 auto-focus&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为规则指定一个议程(agenda)组。指定了议程组的规则只有在该议程组得到焦点时才被触发。但如果规则同时指定了auto-focus属性为true，则该规则自动得到焦点。&lt;/p&gt;
&lt;p&gt;指定议程组焦点可以通过回话(session)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;session.getAgenda().getAgendaGroup("GROUP_NAME").setFocus();
  session.fireAllRules();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以实现org.drools.runtime.rule.AgendaFilter 接口：&lt;/p&gt;
&lt;p&gt;{% highlight java %}
    package test;
    import org.drools.runtime.rule.Activation;
    import org.drools.runtime.rule.AgendaFilter;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class TestAgendaFilter implements AgendaFilter {
    private String startName;
    public TestAgendaFilter(String startName){
        this.startName=startName;
    }
    public boolean accept(Activation activation) {
        String ruleName=activation.getRule().getName();
        if(ruleName.startsWith(this.startName)){
            return true;
        }else{
            return false;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ruleflow-group&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指定规则流组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lock-on-active&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当在规则上使用 ruleflow-group 属性或 agenda-group 属性的时候,将 lock-on-action 属性 的值设置为 true,可能避免因某些 Fact 对象被修改而使已经执行过的规则再次被激活执行。lock-on-active 是 no-loop 的增强版属性，在规则流中很有用。&lt;/p&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;rule &amp;quot;rule1&amp;quot;
    salience 1
    when
    ……
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;注释&lt;/h1&gt;
&lt;p&gt;Drools 当中注释的写法与编写 Java 类的注 释的写法完全相同,注释的写法分两种:单行注释与多行注释。&lt;/p&gt;
&lt;p&gt;单行注释可以采用“#”或者“//”来进行标记， 多行注释以“/&lt;em&gt;”开始,以“&lt;/em&gt;/”结束。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* 规则rule1的注释&lt;/span&gt;
&lt;span class="cm"&gt;这是一个测试用规则&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
rule&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rule1&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;when&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;eval&lt;span class="o"&gt;(&lt;/span&gt;true&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;#没有条件判断&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kr"&gt;then&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;System&lt;span class="o"&gt;.&lt;/span&gt;out&lt;span class="o"&gt;.&lt;/span&gt;println&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rule1 execute&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;仅仅是输出&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;类型声明&lt;/h1&gt;
&lt;p&gt;可以在规则文件中定义Fact类型，而不需要编写Java类。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;declare Address
    city : String
    addressName : String
end

declare Person
    name:String
    birthday:Date
    address:Address //使用declare声明的对象作为address属性类型
    order:Order //使用名为Order的JavaBean作为order属性类型
end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在KnowledgeBase中可以获取规则文件中定义的Fact类型，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//获取规则文件当中定义的Address对象并对其进行实例化
FactType addressType=knowledgeBase.getFactType(&amp;quot;test&amp;quot;,&amp;quot;Address&amp;quot;);
Object add=addressType.newInstance();
addressType.set(add, &amp;quot;city&amp;quot;,&amp;quot;Beijing&amp;quot;);
addressType.set(add, &amp;quot;addressName&amp;quot;,&amp;quot;Capital&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在声明中还可以定义元数据。可以为 Fact 对象、Fact对象的属性或者是规则来定义元数据,元数据定义采用的是“@”符号开头。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;declare User
    @createTime(2009-10-25)
    username : String @maxLenth(30)
    userid : String @key
    birthday : java.util.Date
end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;元数据的获取？(TODO)&lt;/p&gt;
&lt;h1&gt;全局变量（TODO）&lt;/h1&gt;
&lt;h1&gt;函数和import function&lt;/h1&gt;
&lt;h2&gt;函数的定义和使用&lt;/h2&gt;
&lt;p&gt;函数是定义在规则文件当中一代码块,作用是将在规则文件当中若干个规则都会用到的业务操作封装起来,实现业务代码的复用,减少规则编写的工作量。
函数的可见范围是函数所在的规则文件。&lt;/p&gt;
&lt;p&gt;函数以function定义，可以是void，也可以有返回值。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.List&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.ArrayList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;/*&lt;/span&gt;
&lt;span class="err"&gt;一个测试函数&lt;/span&gt;
&lt;span class="err"&gt;用来向&lt;/span&gt;&lt;span class="n"&gt;Customer对象当中添加指定数量的Order对象的函数&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;setOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Customer&lt;/span&gt; &lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;orderSize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;ls&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;orderSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;Order&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Order&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;ls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setOrders&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ls&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;/*&lt;/span&gt;
&lt;span class="err"&gt;测试规则&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;rule&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;rule1&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt;
    &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Customer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;setOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;rule 1 customer has order size:&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getOrders&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="o"&gt;/*&lt;/span&gt;
&lt;span class="err"&gt;测试规则&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;rule&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;rule2&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt;
    &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Customer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;setOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;rule 2 customer has order size:&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getOrders&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;引入静态方法&lt;/h2&gt;
&lt;p&gt;实际应用当中,可以考虑使用在 Java 类当中定义静态方法的办法来替代在规则文件当 中定义函数。&lt;/p&gt;
&lt;p&gt;Drools 提供了一个特殊的 import 语句:import function,通过该 import 语句,可以实现将一个 Java 类中静态方法引入到一个规则文件当中,使得该文件当中的规 则可以像使用普通的 Drools 函数一样来使用 Java 类中某个静态方法。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight java %}
package test;
public class RuleTools {
    public static void printInfo(String name){
        System.out.println("your name is :"+name);
    }
}&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;function&lt;/span&gt; &lt;span class="nn"&gt;test.RuleTools.printInfo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;/*&lt;/span&gt;
&lt;span class="err"&gt;测试规则&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;rule&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;rule1&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;when&lt;/span&gt;
        &lt;span class="nb"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;then&lt;/span&gt;
        &lt;span class="n"&gt;printInfo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;test import function&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;查询定义&lt;/h1&gt;
&lt;p&gt;查询用于根据条件在当前的 WorkingMemory 当中查找 Fact。Drools 当中查询可分为两种:一种是不需要外部传入参数;一种是需要外部传入参 数。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;query &amp;quot;testQuery&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    customer:Customer(age&amp;gt;30,orders.size &amp;gt;10)&lt;/span&gt;
&lt;span class="x"&gt;end&lt;/span&gt;

&lt;span class="x"&gt;query &amp;quot;testQuery2&amp;quot;(int &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;age&lt;/span&gt;&lt;span class="x"&gt;,String &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;gender&lt;/span&gt;&lt;span class="x"&gt;)&lt;/span&gt;
&lt;span class="x"&gt;    customer:Customer(age&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;age&lt;/span&gt;&lt;span class="x"&gt;,gender==&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;gender&lt;/span&gt;&lt;span class="x"&gt;)&lt;/span&gt;
&lt;span class="x"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过session可以在外部调用规则文件中的查询，比如：&lt;/p&gt;
&lt;p&gt;{% highlight java %}
……
QueryResults queryResults=statefulSession.getQueryResults("testQuery");
for(QueryResultsRow qr:queryResults){
    Customer cus=(Customer)qr.get("customer"); //打印查询结果
    System.out.println("customer name :"+cus.getName());
}&lt;/p&gt;
&lt;p&gt;QueryResults queryResults2=statefulSession.getQueryResults("testQuery2", new Object[]{new Integer(20),"F"});&lt;/p&gt;
&lt;p _="%" endhighlight&gt;……&lt;/p&gt;</content><category term="规则引擎"></category></entry><entry><title>规则引擎中常用的模式匹配算法</title><link href="http://holbrook.github.io/2012/12/05/algorithm_of_pattern_match.html" rel="alternate"></link><published>2012-12-05T00:00:00+08:00</published><updated>2012-12-05T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-12-05:/2012/12/05/algorithm_of_pattern_match.html</id><summary type="html">&lt;p&gt;规则引擎的核心是Pattern Matcher(模式匹配器)。不管是正向推理还是反向推理，首先要解决一个模式匹配的问题。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="/2012/03/20/rule_engine_1.html"&gt;前面&lt;/a&gt;提到，规则引擎的核心是Pattern Matcher(模式匹配器)。不管是正向推理还是反向推理，首先要解决一个模式匹配的问题。&lt;/p&gt;
&lt;p&gt;对于规则的模式匹配，可以定义为： 一个规则是一组模式的集合。如果事实/假设的状态符合该规则的所有模式，则称为该规则是可满足的。 模式匹配的任务就是将事实/假设的状态与规则库中的规则一一匹配，找到所有可满足的规则。&lt;/p&gt;
&lt;h1&gt;什么是模式匹配&lt;/h1&gt;
&lt;p&gt;对于模式匹配我们都应该不陌生，我们经常使用的正则表达式就是一种模式匹配。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正则表达式是一种“模式（pattern）”&lt;/li&gt;
&lt;li&gt;编程语言提供的“正则表达式引擎”就是Pattern Matcher。比如python中的re模块&lt;/li&gt;
&lt;li&gt;首先输入“知识”：re.compile(r'string')&lt;/li&gt;
&lt;li&gt;然后就可以让其匹配（match）事实（字符串）&lt;/li&gt;
&lt;li&gt;最后通过正则表达式引擎可以得到匹配后的结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于规则匹配，通常定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件部分，也称为LHS(left-hand side)&lt;/li&gt;
&lt;li&gt;事实部分，也称为RHS(right-hand side)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设系统中有N条规则，平均每个规则的条件部分有P个模式，在某个时点有M个事实需要处理。则规则匹配要做的事情就是： 对每一个规则r，判断当前的事实o是否满足LHS(r)=True,如果满足，则将规则r的实例r(o)，即规则+满足该规则的事实，加到冲突集中等待处理。 通常采取如下过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从N条规则中取出一条r；&lt;/li&gt;
&lt;li&gt;从M个事实中取出P个事实的一个组合c；&lt;/li&gt;
&lt;li&gt;用c测试LHS(r)，如果LHS(r（c）)=True，将RHS(r（c）)加入队列中；&lt;/li&gt;
&lt;li&gt;如果M个事实还存在其他的组合c，goto 3；&lt;/li&gt;
&lt;li&gt;取出下一条规则r，goto 2；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际的问题可能更复杂，在规则的执行过程中可能会改变RHS的数据，从而使得已经匹配的规则实例失效或者产生新的满足规则的匹配，形成一种“动态”的匹配链。&lt;/p&gt;
&lt;p&gt;上面的处理由于涉及到组合，过程很复杂。有必要通过特定的算法优化匹配的效率。目前常见的模式匹配算法包括Rete、Treat、Leaps，HAL，Matchbox等。&lt;/p&gt;
&lt;h1&gt;Rete算法&lt;/h1&gt;
&lt;p&gt;Rete算法是目前使用最广泛的规则匹配算法，由Charles L. Forgy博士在1979年发明。Rete算法是一种快速的Forward-Chaining推理算法，其匹配速度与规则的数量无关。 Rete的高效率主要来自两个重要的假设：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时间冗余性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设facts在推理过程中的变化是缓慢的, 即在每个执行周期中,只有少数的facts发生变化，因此影响到的规则也只占很小的比例。所以可以只考虑每个执行周期中已经匹配的facts.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结构相似性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设许多规则常常包含类似的模式和模式组。&lt;/p&gt;
&lt;p&gt;Rete算法的基本思想是保存过去匹配过程中留下的全部信息,以空间代价来换取执行效率 。对每一个模式 ,附加一个匹配元素表来记录WorkingMemory中所有能与之匹配的元素。当一个新元素加入到WorkingMemory时, 找出所有能与之匹配的模式, 并将该元素加入到匹配元素表中; 当一个无素从WorkingMemory中删除时,同样找出所有与该元素匹配的模式,并将元素从匹配元素表中删除。 Rete算法接受对工作存储器的修改操作描述 ,产生一个修改冲突集的动作 。&lt;/p&gt;
&lt;p&gt;Rete算法的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将初始数据（fact）输入Working Memory。&lt;/li&gt;
&lt;li&gt;使用Pattern Matcher比较规则（rule）和数据（fact）。&lt;/li&gt;
&lt;li&gt;如果执行规则存在冲突（conflict），即同时激活了多个规则，将冲突的规则放入冲突集合。&lt;/li&gt;
&lt;li&gt;解决冲突，将激活的规则按顺序放入Agenda。&lt;/li&gt;
&lt;li&gt;使用规则引擎执行Agenda中的规则。重复步骤2至5，直到执行完毕所有Agenda中的规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Tread算法&lt;/h1&gt;
&lt;p&gt;在 Rete算法中 ,同一规则连接结点上的寄存器保留了大量的冗余结果。实际上, 寄存器中大部分信息已经体现在冲突集的规则实例中。因此 ,如果在部分匹配过程中直接使用冲突集来限制模式之间的变量约束,不仅可以减少寄存器的数量 ,而且能够加快匹配处理效率 。这一思想称为 冲突集支撑策略 。&lt;/p&gt;
&lt;p&gt;考虑增删事实对匹配过程的影响，当向工作存储器增加一个事实时 ,冲突集中已有的规则实例仍然保留,只是将与该事实匹配的规则实例加入到冲突集中; 当从工作存储器删去一个事实时，不可能有新的规则实例产生, 只是将 包含该事实的规则实例从冲突集中删去。&lt;/p&gt;
&lt;p&gt;基于冲突集支撑策略和上述观察, Treat算法放弃了Rete算法中利用寄存器保存模式之间变量约束中间结果的思想,对于每一个模式 ,除保留原有 a寄存器的外 ,增加两个新链来记录与该模式匹配的增删事实,一个叫做增链 (addlist),另一个叫做删链 (deletelist)。当修改描述的操作符为 “+”时,临时执行部分连接任务;当修改描述的操作符为 “一”时,直接删去冲突集中包含该事实的规则实例。&lt;/p&gt;
&lt;p&gt;Treat算法的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;行动 :根据点火规则的 RHS,生成修改描述表 CHANGES;&lt;/li&gt;
&lt;li&gt;模式匹配:置每一模式的删链和增链为空,对 CHANGES的每一个修改描述 ,执行模式匹配。对于与修改描述中的事实匹配成功的模式,若修改描述的操作符为 “+”, 将该事实加入这一模式的增链;若修改描述的操作符为 “一”,将该事实加入这一模式的 删链。&lt;/li&gt;
&lt;li&gt;删去事实的处理:对于任一模式链中的每一个事实,找到冲突集中所有包含该事实 的规则实例,并将这一规则实例从冲突集中删去。相应地修改该模式的 a寄存器 。&lt;/li&gt;
&lt;li&gt;新增事实的处理:对 于 每 一 模 式 ,若 其 增 链 非 空 ,则 将 增 链 中 的 所 有 事 实 加 入 该 模 式的a寄存器 ,并对与新增事实相关的每一条规则临时执行部分匹配,寻找该规则新的实 例。具体做法为:首先将第一个模式增链中的事实集合与后一模式的 a寄存器进行连接 , 再将部分连接结果与第三个模式的a寄存器进行连接 ,一直到所有模式均连接完成为止。 其中 ,a寄存器 的内容包括新增 事实。若连接结果非空 ,则将找到 的规则 实例插入到冲突 集中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Leaps 算法&lt;/h1&gt;
&lt;p&gt;前向推理引擎，包括LEAPS，都包括了匹配-选择-执行（match-select-action）循环。即，确定可以匹配的规则，选择某个匹配的元 组，此元组相应的规则动作被执行。重复这一过程，直到某一状态（如没有更多的规则动作）。RETE和TREAT匹配算法速度慢的原因是，它们把满足规则条 件的元组都实例化。Leaps算法的最大的改进就是使用一种"lazy"的方法来评估条件（conditions），即仅当必要时才进行元组的实例化。这 一改进极大的减少了前向推理引擎的时空复杂度，极大提高了规则执行速度。&lt;/p&gt;
&lt;p&gt;Leaps算法将所有的 asserted 的 facts ，按照其被 asserted 在 Working Memory 中的顺序（ FIFO ），放在主堆栈中。它一个个的检查 facts ，通过迭代匹配 data type 的 facts 集合来找出每一个相关规则的匹配。当一个匹配的数据被发现时，系统记住此时的迭代位置以备待会的继续迭代，并且激发规则结果（ consequence ）。当结果（ consequence ）执行完成以后，系统就会继续处理处于主堆栈顶部的 fact 。如此反复。&lt;/p&gt;
&lt;p&gt;Leaps算法的效率可以比Rete算法和Tread算法高几个数量级。&lt;/p&gt;
&lt;h1&gt;其他算法&lt;/h1&gt;
&lt;p&gt;对于HAL算法和Matchbox算法，使用的范围不是很广，这里不做过多的介绍。&lt;/p&gt;</content><category term="规则引擎"></category></entry><entry><title>CEP：鱼与熊掌可以兼得</title><link href="http://holbrook.github.io/2012/11/06/cep_about.html" rel="alternate"></link><published>2012-11-06T00:00:00+08:00</published><updated>2012-11-06T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-11-06:/2012/11/06/cep_about.html</id><summary type="html">&lt;p&gt;简单的说，事件驱动模式包括三个参与者：事件产生者，事件分发器和事件处理器。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;从事件驱动编程（Event-driven Programming)开始&lt;/h1&gt;
&lt;p&gt;如果你写过GUI程序，对事件处理一定不陌生。事实上，事件驱动编程已经成为一种设计模式。大多数的GUI库都会采用这一模式。&lt;/p&gt;
&lt;p&gt;简单的说，事件驱动模式包括三个参与者：事件产生者，事件分发器和事件处理器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件产生者（Events Generator）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;决定是否需要产生事件。比如，GUI上的每个组件都是一个事件产生者，可以根据用户操作产生鼠标事件或者键盘事件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件分发器（Events Dispatcher）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;收集所有事件产生者发出的事件放入事件队列(Events Queue)，
并根据事件的类型将事件分发给已经注册的事件处理器。事件分发器通常由GUI框架实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件处理器（Events Handler)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据接收到的事件进行处理，需要GUI框架的使用者自行编写。&lt;/p&gt;
&lt;p&gt;事件驱动编程的核心价值在于：程序的执行流程不是预先定义好的，而是由程序的使用者决定的。这将极大增强程序的交互性。&lt;/p&gt;
&lt;p&gt;就好像DVD与RPG游戏的区别：前者的剧情是设定好的，你只能进行开始、暂停、快进、回退等有限的交互；后者可以决定主角的行为从而影响故事的结局。&lt;/p&gt;
&lt;h1&gt;事件驱动业务（Event-driven Business)&lt;/h1&gt;
&lt;p&gt;代码的世界不可能是现实世界的完整镜像，但一定是对现实世界的某种抽象，这种抽象能够简化代码世界中对问题的分析和处理。
同时，这种抽象还可以反向映射到现实世界，为我们解决现实问题提供思路。&lt;/p&gt;
&lt;p&gt;现代企业生存的外部环境处于剧烈的变化之中，“敏捷企业”已经成为生存之道，而事件驱动业务是敏捷企业的一个基本要求。&lt;/p&gt;
&lt;p&gt;事件驱动业务（Event-driven Business)，是在 连续
的业务过程中进行决策的一种业务管理方式，即根据不同时点上出现的一系列事件触发相关的任务，并调度可用的资源执行任务。
如果说事件驱动编程能够为软件带来更灵活的交互性和强大的功能，那么企业中的事件驱动业务能够大幅度提高业务的效率和灵活性。&lt;/p&gt;
&lt;p&gt;事件驱动业务依托于比较成熟的信息化建设。各个业务应用系统在产生连续不断的数据流的同时，根据定义好的条件产生一些“业务事件”，按照策略对这些业务事件进行分析处理，触发新的业务事件或者业务流程，即实现了业务的事件驱动。&lt;/p&gt;
&lt;p&gt;从上面的描述可以看出，事件驱动业务要求能够快速（毫秒级）、不间断的处理连续、海量的数据，具备灵活的规则或策略设置，从而具备迅速识别、捕获、响应实时业务数据的能力。
而传统的企业IT架构通常采用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在业务应用系统中处理业务操作&lt;/li&gt;
&lt;li&gt;遵循固定的业务流程（Business
    Process）处理跨系统事务，并且这些流程很少变化&lt;/li&gt;
&lt;li&gt;基于数据仓库进行海量数据的存储及事后分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种IT架构远远达不到事件驱动业务的要求。&lt;/p&gt;
&lt;p&gt;事件驱动业务能够应用的业务领域很多，凡是需要快速处理连续性数据、需要能够灵活制定策略的业务，都可以采用事件驱动的业务模式。如证券行业常见的风险分析预警（事前及事中风控）、投资决策（程序化交易）、经纪人绩效计算等。&lt;/p&gt;
&lt;h1&gt;业务事件处理的几个层次&lt;/h1&gt;
&lt;p&gt;其实在传统的IT架构中，我们已经实现了业务事件的处理。比如在传统的业务应用系统中，我们通常将业务数据存储在数据库中，通过应用系统的操作界面由人工发现和处理业务事件。&lt;/p&gt;
&lt;p&gt;这样的处理方式存在两个不足，一是速度慢，二是对于复杂的情况只靠人脑难以处理。于是有了两个技术方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息队列（MQ）
    对于速度慢的解决办法是用机器代替人工，为了在多个系统之间传递消息，发展出了消息队列（MQ）的技术&lt;/li&gt;
&lt;li&gt;商业智能（BI）
    为了应对复杂性，通过数据仓库将数据整合到一起，并用专门的工具在数据模型的基础上进行分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是上述两个方向是正交的：MQ不适合处理复杂性，而BI主要适应于对结构化的历史数据的分析，无法处理“现在”的情况。&lt;/p&gt;
&lt;h1&gt;CEP：鱼与熊掌可以兼得&lt;/h1&gt;
&lt;p&gt;CEP（Complex Event
Processing）的出现解决了上述两个方面的问题，在实时性和复杂性方面都得到了很好的解决。&lt;/p&gt;
&lt;h2&gt;处理数据流&lt;/h2&gt;
&lt;p&gt;不管是单独的应用系统，还是数据仓库，都是先将数据存储到数据库/数据仓库，然后再处理或查询。
而CEP与MQ类似的将数据看作是 数据流
。在连续数据的快速移动过程中进行分析处理。
这样的方式不需要很大的数据加载，完全可以在内存中进行，从而能够快速产生结果。&lt;/p&gt;
&lt;p&gt;&lt;img alt="数据流" src="./assets/images/rule_engine/cep.png"&gt;&lt;/p&gt;
&lt;h2&gt;处理复杂性&lt;/h2&gt;
&lt;p&gt;业务事件可能很复杂，在各种不同的数据流中源源不断产生各种类型的事件。需要对这些业务事件进行复杂的计算，如过滤、关联、聚合等，同时还需要考虑这些也是事件出现的时间序列。
最终才能产生有意义的事件，或触发业务流程。同时，这些计算的规则可能还会经常变化。&lt;/p&gt;
&lt;p&gt;这一类的问题通常通过基于规则的推理机（即规则引擎）来实现。&lt;/p&gt;
&lt;p&gt;&lt;img alt="复杂性" src="./assets/images/rule_engine/complex.png"&gt;&lt;/p&gt;
&lt;h2&gt;CEP的架构&lt;/h2&gt;
&lt;p&gt;&lt;img alt="CEP的架构" src="./assets/images/rule_engine/cep_architecture.png"&gt;&lt;/p&gt;
&lt;p&gt;综上所述，CEP在逻辑上应该包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件发生器
    通过应用系统、文件系统、数据库、互联网、人工、以及传感器产生事件&lt;/li&gt;
&lt;li&gt;事件处理器 模式的匹配、验证和改进，路由，转换以及编排&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件消费者
    与事件发生器类似，也可以是应用系统、文件系统、数据库、互联网、人工界面等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小结&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CEP是一种比较新的企业架构(EA,Enterprise
Architure)组件。CEP将数据看做一种数据流，基于规则引擎对业务过程中持续产生的各种事件进行复杂的处理，能够实现对连续数据的快速分析处理。可以应用在多种业务场景，如风险分析、程序化交易等。&lt;/p&gt;
&lt;p&gt;如果说BI实现了商业智能，那么CEP则实现了“持续智能（Continuous
Intelligence）“。&lt;/p&gt;</content><category term="CEP"></category></entry><entry><title>NoSQL数据库选型指引</title><link href="http://holbrook.github.io/2012/11/06/nosql_list.html" rel="alternate"></link><published>2012-11-06T00:00:00+08:00</published><updated>2012-11-06T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-11-06:/2012/11/06/nosql_list.html</id><summary type="html">&lt;p&gt;从设计原则上，NoSQL不再强调ACID（酸），而是强调BASE（碱）。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;什么是NoSQL&lt;/h1&gt;
&lt;p&gt;NoSQL可以有两种解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No SQL：“不使用SQL查询语言”。强调其轻量的特点&lt;/li&gt;
&lt;li&gt;Not Only SQL：”不仅仅是查询“。强调其高性能，分布式，大容量等传统关系数据库所不具备的特性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从设计原则上，NoSQL不再强调ACID（酸），而是强调BASE（碱）。&lt;/p&gt;
&lt;p&gt;ACID是指：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;atomicity（原子性）：一个事务中的所有操作，要么全部完成，要么全部不完成。如果中途发生错误需要回滚（Rollback）&lt;/li&gt;
&lt;li&gt;consistency(一致性)：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。這表示寫入的資料必須完全符合所有的預設規則，這包含資料的精確度、串聯性以及後續数据库可以自發性地完成預定的工作。&lt;/li&gt;
&lt;li&gt;isolation(隔離性)：当两个或者多个事务并发访问（此处访问指查询和修改的操作）数据库的同一数据时所表现出的相互关系。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）&lt;/li&gt;
&lt;li&gt;durability(持久性)：在事务完成以后，该事务对数据库所作的更改便持久地保存在数据库之中，并且是完全的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BASE是指：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Basically Available（基本可用）&lt;/li&gt;
&lt;li&gt;Soft-state（软状态/柔性事务）&lt;/li&gt;
&lt;li&gt;Eventually Consistent（最终一致性）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NoSQL与关系数据库的原则不同：NoSQL牺牲高一致性，换取获得可用性或可靠性。软状态意味着状态是异步的，在某些时段状态是不一致的；但最终一致保证数据早晚会一致。&lt;/p&gt;
&lt;h1&gt;NoSQL选型要素&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;存储结构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于NoSQL的目的和原则的不同，NoSQL中的数据不是按照表存储。根据NoSQL存储结构的不同，可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文档存储&lt;/li&gt;
&lt;li&gt;图存储&lt;/li&gt;
&lt;li&gt;key/value儲存&lt;/li&gt;
&lt;li&gt;列存储&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否持久化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有的NoSQL是纯内存存储，不支持持久化&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是否支持嵌入式&lt;/li&gt;
&lt;li&gt;是否支持集群部署&lt;/li&gt;
&lt;li&gt;操作接口的丰富程度&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;常见的NoSQL数据库&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;文档数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;th&gt;&lt;td&gt;名称&lt;/td&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;部署方式&lt;/td&gt;&lt;td&gt;操作接口&lt;/td&gt;&lt;td&gt;备注&lt;/td&gt;&lt;/th&gt;
&lt;tr&gt;&lt;td&gt;CouchDB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;分布式&lt;/td&gt;&lt;td&gt;JavaScript MapReduce, RESTful JSON API&lt;/td&gt;&lt;td&gt;HTTP访问，内置了Web管理控制台&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;JackRabbit&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Lotus Notes&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;LotusScript, Java&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;BaseX&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;XQuery, Java&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;MongoDB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;服务，集群&lt;/td&gt;&lt;td&gt;PHP，Python，Perl，Ruby，JavaScript，C++等&lt;/td&gt;&lt;td&gt;JSON数据库，支持全文索引，自动分片，跨LAN或WAN扩展&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;图形数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;th&gt;&lt;td&gt;名称&lt;/td&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;部署方式&lt;/td&gt;&lt;td&gt;操作接口&lt;/td&gt;&lt;td&gt;备注&lt;/td&gt;&lt;/th&gt;
&lt;tr&gt;&lt;td&gt;Neo4j&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DEX&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Java , C#&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;AllegroGraph&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;SPARQL&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FlockDB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Scala&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;key/value数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;th&gt;&lt;td&gt;名称&lt;/td&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;部署方式&lt;/td&gt;&lt;td&gt;操作接口&lt;/td&gt;&lt;td&gt;备注&lt;/td&gt;&lt;/th&gt;
&lt;tr&gt;&lt;td&gt;BigTable&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;memcached&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Redis&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Oracle Berkeley DB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;列数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;th&gt;&lt;td&gt;名称&lt;/td&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;部署方式&lt;/td&gt;&lt;td&gt;操作接口&lt;/td&gt;&lt;td&gt;备注&lt;/td&gt;&lt;/th&gt;
&lt;tr&gt;&lt;td&gt;Cassandra&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;HBase&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Hypertable&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;对象数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;th&gt;&lt;td&gt;名称&lt;/td&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;部署方式&lt;/td&gt;&lt;td&gt;操作接口&lt;/td&gt;&lt;td&gt;备注&lt;/td&gt;&lt;/th&gt;
&lt;tr&gt;&lt;td&gt;db4o&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;iBoxDB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;JADE&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ZODB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ObjectStore&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</content><category term="NoSQL"></category></entry><entry><title>如何规划blog的分类和标签</title><link href="http://holbrook.github.io/2012/11/05/2012-11-05-blog_design_categories_and_tags.html" rel="alternate"></link><published>2012-11-05T00:00:00+08:00</published><updated>2012-11-05T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-11-05:/2012/11/05/2012-11-05-blog_design_categories_and_tags.html</id><summary type="html">&lt;p&gt;使用知识地图的思想规划博客的标签(tags)和分类(categories)&lt;/p&gt;</summary><content type="html">&lt;p&gt;一篇旧的博文，原文发表在&lt;a href="http://www.cnblogs.com/holbrook/archive/2012/11/05/2755268.html"&gt;博客园&lt;/a&gt;。&lt;/p&gt;</content><category term="blog"></category><category term="知识管理"></category></entry><entry><title>QQ 餐厅与系统性能模型(续)：如何评价系统的性能</title><link href="http://holbrook.github.io/2012/10/29/2012-10-29-performance_test.html" rel="alternate"></link><published>2012-10-29T00:00:00+08:00</published><updated>2012-10-29T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-10-29:/2012/10/29/2012-10-29-performance_test.html</id><summary type="html">&lt;p&gt;作为QQ餐厅的客人，对餐厅效率的评价就是供餐“快”或者“慢”。但是对于餐厅的经营者，这样简单的考虑问题显然是不够的。
在《QQ餐厅与系统性能模型》 中提到了系统性能的很多指标，而客人感觉“快”或者“慢”仅仅对应其中的 响应时间 这一指标。本文讨论如何全面评价一个系统的性能"&lt;/p&gt;</summary><content type="html">&lt;p&gt;作为QQ餐厅的客人，对餐厅效率的评价就是供餐“快”或者“慢”。但是对于餐厅的经营者，这样简单的考虑问题显然是不够的。&lt;/p&gt;
&lt;p&gt;在&lt;a href="/2012/10/23/whats_performance.html"&gt;《QQ餐厅与系统性能模型》&lt;/a&gt; 中提到了系统性能的很多指标，而客人感觉“快”或者“慢”仅仅对应其中的 &lt;em&gt;响应时间&lt;/em&gt; 这一指标。&lt;/p&gt;
&lt;p&gt;对于QQ餐厅的经营者，应该如何考虑呢？&lt;/p&gt;
&lt;p&gt;在《QQ餐厅与系统性能模型》 中已经描述了客人数量增加时餐厅中发生的一系列“故事”，让我们回顾一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源利用率与负载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;资源利用率随负载的增加而增加，最终达到100%。此时再增加负载，资源利用率也不会增加。当然，这是对单一资源来说，现实中总是有某种资源最先达到100%而其他的资源仍有空闲。&lt;/p&gt;
&lt;p&gt;资源利用率达到100%时对应的并发用户数称为 &lt;strong&gt;最佳并发用户数&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应时间与负载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当并发用户数小于前面定义的“最大并发用户数”时，系统的响应时间是一个固定的值。如果继续增加系统的负载，用户等待时间就会增加从而延长响应时 间。假设用户有一个能容忍的最长等待时间，则负载增加到一定程度时系统对某些请求的响应时间就会超过用户的容忍度。在临界状态的负载称为 最大并发用户数 。&lt;/p&gt;
&lt;p&gt;在最大并发用户数的情况下，系统的吞吐量应该达到最大值。超过最大并发用户数的负载会导致资源浪费在超时的请求上，从而使吞吐量下降。&lt;/p&gt;
&lt;p&gt;（在系统负载略高于最大并发用户数时，可能吞吐量会有一定程度的增加，但此时的吞吐量已经没有意义。所以应该考量最大并发用户数下系统的吞吐量）&lt;/p&gt;
&lt;h1&gt;评价系统的性能&lt;/h1&gt;
&lt;p&gt;从系统建设者的角度来说，系统性能不仅仅是”快“或者”慢“，而是应该有一个全面的描述。比如对于”QQ餐厅系统“，至少要有如下的描述才能评价其性能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QQ餐厅的可用资源包括：2位厨师，6名服务员，30套座位&lt;/li&gt;
&lt;li&gt;QQ餐厅最理想情况是同时接待25位客人，此时2名厨师工作量饱和，服务员空闲1人，座位空闲5套&lt;/li&gt;
&lt;li&gt;在25人就餐的情况下，没小时可以卖出8道菜，客人评价就餐时间为10分钟，99%的客人可以在30分钟完成内用餐&lt;/li&gt;
&lt;li&gt;假设 客人能容忍的最长用餐时间为60分钟，则QQ餐厅最多能容纳35人就餐&lt;/li&gt;
&lt;li&gt;在35人就餐的情况下，每小时可以卖出10道菜，客人平均就餐时间为20分钟，99%的客人可以在50分钟内完成用餐&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;提高系统的性能&lt;/h1&gt;
&lt;p&gt;有了前面比较系统的性能描述，就很容易知道如何提高系统的性能。提高系统性能的目标有两个级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在现有的响应时间基础上，提高最佳并发用户数和最大并发用户数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个指标的现实意义在于：最佳并发用户数要不小于系统的平均负载，最大并发用户数要不小于系统的峰值负载（通常应该达到峰值的1.5–2倍）。&lt;/p&gt;
&lt;p&gt;实现这个级别的目标通常比较容易，主要是增加系统的可用资源。必要时还可以横向扩展（增加服务器数量）。比如对于前面的QQ餐厅性能情况，增加厨师数量就能够有效提高最佳并发数和最大并发数。&lt;/p&gt;
&lt;p&gt;当然，如果能够说服用户增加所能容忍的等待时间，也可以提高最大并发数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加系统整体的响应速度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户感受到的整体响应时间=请求传输时间+等待时间+处理时间+响应返回时间。针对这些不同的时间片段可以分别想办法提高速度。比如：&lt;/p&gt;
&lt;p&gt;提高网络带宽可以减小请求传输时间和响应返回时间； 增加处理单元可以减小等待时间； 优化算法可以减小处理时间。&lt;/p&gt;
&lt;p&gt;上面的几种办法实现起来难度都比较大，所以提高系统性能应该优先考虑第一个级别的办法。&lt;/p&gt;
&lt;h1&gt;最精简的性能测试的例子&lt;/h1&gt;
&lt;p&gt;使用Apache ab进行性能测试，访问NginX上面部署的静态页面。在不同并发下测试100万次请求，结果如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;并发数 失败请求数 每秒完成请求  平均响应时间ms  99%请求响应时间ms 吞吐量(kb/s)&lt;/p&gt;
&lt;p&gt;100 0 13005.97  7.689 10  24132.19&lt;/p&gt;
&lt;p&gt;500 0 24132.19  36.193  232 25632.78&lt;/p&gt;
&lt;p&gt;600 0 13948.85  43.014  296 25881.7&lt;/p&gt;
&lt;p&gt;700 0 14317.11  48.893  232 25632.78&lt;/p&gt;
&lt;p&gt;800 288 14264.21  56.084  2570  26461.06&lt;/p&gt;
&lt;p&gt;1000  390 14752.1 67.787  3013  27363.46&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在各轮测试中，Nginx均没有发生故障切换。&lt;/p&gt;
&lt;p&gt;从测试数据中可以得出以下结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前的性能瓶颈在于网络带宽&lt;/li&gt;
&lt;li&gt;当前系统的最佳并发数为500，最大并发为700&lt;/li&gt;
&lt;li&gt;在最佳并发下，系统每秒可以处理2.4万个请求，平均响应时间36ms，99%的请求在232ms内完成&lt;/li&gt;
&lt;li&gt;在最大并发下，系统每秒可以处理1.4万个请求，平均响应时间48ms，99%的请求在232ms内完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;负载均衡器的性能指标&lt;/h1&gt;
&lt;p&gt;对于负载均衡器，需要的性能指标与具体的应用服务器不太一样。更关注如下指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每秒的会话处理数，要区分4层和7层&lt;/li&gt;
&lt;li&gt;最多保持的连接数&lt;/li&gt;
&lt;li&gt;吞吐量，要区分4层和7层&lt;/li&gt;
&lt;li&gt;支持的虚拟服务器的个数&lt;/li&gt;
&lt;li&gt;支持的后端真实服务器的个数&lt;/li&gt;
&lt;/ul&gt;</content><category term="测试"></category></entry><entry><title>开发和部署JBoss FUSE中的路由(Route)</title><link href="http://holbrook.github.io/2012/04/14/fuse_develop_route.html" rel="alternate"></link><published>2012-04-14T00:00:00+08:00</published><updated>2012-04-14T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-04-14:/2012/04/14/fuse_develop_route.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;快速开始&lt;/h1&gt;
&lt;p&gt;因为&lt;em&gt;Fuse的核心组成部分是ServiceMix&lt;/em&gt;，而ServiceMix的核心组成部分是Apache
Camel，所以“用Fuse开发路由”也就是“开发Camel路由”。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://search.maven.org/#search%7Cga%7C1%7Corg.apache.camel.archetypes"&gt;Camel提供了大量的开发&lt;/a&gt;工具
，其中&lt;a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22camel-archetype-blueprint%22"&gt;camel-archetype-blueprint&lt;/a&gt;
是一个&lt;a href="http://maven.apache.org/guides/introduction/introduction-to-archetypes.html"&gt;maven
archetype&lt;/a&gt;，
可以基于&lt;em&gt;Blueprint&lt;/em&gt;，以依赖注入的方式配置CamelContext。下面快速创建一个demo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    mvn archetype:generate  &lt;span class="se"&gt;\&lt;/span&gt;
    -DarchetypeGroupId&lt;span class="o"&gt;=&lt;/span&gt;org.apache.camel.archetypes &lt;span class="se"&gt;\&lt;/span&gt;
    -DarchetypeArtifactId&lt;span class="o"&gt;=&lt;/span&gt;camel-archetype-blueprint &lt;span class="se"&gt;\&lt;/span&gt;
    -DarchetypeVersion&lt;span class="o"&gt;=&lt;/span&gt;2.12.2 &lt;span class="se"&gt;\&lt;/span&gt;
    -DgroupId&lt;span class="o"&gt;=&lt;/span&gt;thinkinside.demo.fuse &lt;span class="se"&gt;\&lt;/span&gt;
    -DartifactId&lt;span class="o"&gt;=&lt;/span&gt;route-demo &lt;span class="se"&gt;\&lt;/span&gt;
    -Dversion&lt;span class="o"&gt;=&lt;/span&gt;1.0.0-SNAPSHOT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会创建如下结构的一个工程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./assets/images/fuse/route-demo-structure.png"&gt;&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;pom.xml&lt;/code&gt;
来看，这是一个&lt;em&gt;使用maven-bundle-plugin构建的OSGibundle工程&lt;/em&gt;。&lt;/p&gt;
&lt;h1&gt;基于&lt;em&gt;Blueprint&lt;/em&gt;装配Camel&lt;/h1&gt;
&lt;p&gt;Context&lt;/p&gt;
&lt;p&gt;工程的`META-INF/blueprint/blueprint.xml'文件是一个Blueprint配置文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;      &lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;blueprint&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.osgi.org/xmlns/blueprint/v1.0.0&amp;quot;&lt;/span&gt;
             &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt;
             &lt;span class="na"&gt;xmlns:camel=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://camel.apache.org/schema/blueprint&amp;quot;&lt;/span&gt;
             &lt;span class="na"&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;             http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd&lt;/span&gt;
&lt;span class="s"&gt;             http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint.xsd&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

        &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;helloBean&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;thinkinside.demo.fuse.HelloBean&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;say&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hi from Camel&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

        &lt;span class="nt"&gt;&amp;lt;camelContext&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;blueprintContext&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;trace=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;false&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://camel.apache.org/schema/blueprint&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;route&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;timerToLog&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;from&lt;/span&gt; &lt;span class="na"&gt;uri=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;timer:foo?period=5000&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;setBody&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;method&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;helloBean&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/setBody&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;log&lt;/span&gt; &lt;span class="na"&gt;message=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;The message contains ${body}&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;to&lt;/span&gt; &lt;span class="na"&gt;uri=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mock:result&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/route&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/camelContext&amp;gt;&lt;/span&gt;

      &lt;span class="nt"&gt;&amp;lt;/blueprint&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该配置文件中，定义了一个id为 &lt;code&gt;blueprintContext&lt;/code&gt; 的Camel
Context。这个Context中定义了一个路由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;入口为一个Timer类型的Endpoint&lt;/li&gt;
&lt;li&gt;使用预定义的bean为Message设置body&lt;/li&gt;
&lt;li&gt;记录日志&lt;/li&gt;
&lt;li&gt;出口为一个Mock类型的Endpoint&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果使用FuseIDE，可以看到图形化的配置界面：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./assets/images/fuse/route-design.png"&gt;
部署到ServiceMix
================&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;mvn package&lt;/code&gt; 后，得到 &lt;code&gt;route-demo-1.0.0-SNAPSHOT.jar&lt;/code&gt;
，这是一个OSGi bundle。可以将jar文件部署到&lt;/p&gt;
&lt;p&gt;=\$SERVICEMIX~HOME~/deploy/=
目录中。正常情况下，bundle的依赖关系被满足，该bundle会被自动启动。&lt;/p&gt;
&lt;h1&gt;从ServiceMix到Fuse&lt;/h1&gt;
&lt;p&gt;上述的过程也适用于JBoss Fuse。&lt;/p&gt;
&lt;p&gt;但是Fuse对ServiceMix进行了再次封装，需要使用Fuse对应的版本。比如，=camel-archetype-blueprint=
的版本可能要使用 &lt;code&gt;2.10.0.redhat-60024&lt;/code&gt;
这样的“Fuse版本号”，否则在部署到Fuse是可能会发生版本不匹配的问题。&lt;/p&gt;
&lt;p&gt;Fuse提供了一个maven仓库，专门提供这种定制版本的组件，需要在maven中配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;fusesource&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://repo.fusesource.com/nexus/content/groups/public/&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;snapshots&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;enabled&amp;gt;&lt;/span&gt;false&lt;span class="nt"&gt;&amp;lt;/enabled&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/snapshots&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;releases&amp;gt;&lt;/span&gt;
                 &lt;span class="nt"&gt;&amp;lt;enabled&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/enabled&amp;gt;&lt;/span&gt;
             &lt;span class="nt"&gt;&amp;lt;/releases&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content></entry><entry><title>规则，推理机和规则引擎</title><link href="http://holbrook.github.io/2012/03/20/rule_engine_1.html" rel="alternate"></link><published>2012-03-20T00:00:00+08:00</published><updated>2012-03-20T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-03-20:/2012/03/20/rule_engine_1.html</id><summary type="html">&lt;p&gt;规则作为一种知识，其典型运用就是通过实际情况，根据给定的一组规则，得出结论。
这种规则的运用过程叫做推理。如果由程序来处理推理过程，那么这个程序就叫做推理机/推理引擎（Inference Engine）。
基于规则的推理机称为“规则引擎”。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;什么是规则&lt;/h1&gt;
&lt;p&gt;在现实生活中，规则无处不在。我们最长接触的是法律、法规和各种制度；对于企业级应用来说，第一步的业务调研中很重要的内容就是了解业务规则。在企业流程再造中，可能还会接触到流程规则。&lt;/p&gt;
&lt;p&gt;在IT技术领域，很多地方也应用了规则，比如路由表，防火墙策略，乃至角色权限控制(RBAC)，或者Web框架中的URL匹配。&lt;/p&gt;
&lt;p&gt;不管是哪种种规则，都规定了一组确定的条件和此条件所产生的结果。&lt;/p&gt;
&lt;p&gt;举一个例子，是纷繁复杂的保险费率计算中的一条规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IF&lt;/li&gt;
&lt;li&gt;汽车是红色&lt;/li&gt;
&lt;li&gt;车是运动型的&lt;/li&gt;
&lt;li&gt;驾驶员是男性&lt;/li&gt;
&lt;li&gt;驾驶员在16-25岁之间&lt;/li&gt;
&lt;li&gt;THEN&lt;/li&gt;
&lt;li&gt;保险费用增加20%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这个例子可以看出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每条规则都是一组条件决定的一系列结果&lt;/li&gt;
&lt;li&gt;一条规则可能与其他规则共同决定最终结果。比如例子中的规则只产生了增量，还需要与确定基数的规则共同作用才能决定最终的费率&lt;/li&gt;
&lt;li&gt;可能存在条件互相交叉的规则，此时有必要规定规则的优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;推理机与规则引擎&lt;/h1&gt;
&lt;p&gt;规则作为一种知识，其典型运用就是通过实际情况，根据给定的一组规则，得出结论。这个结论可能是某种静态的结果，也可能是需要进行的一组操作。
这种规则的运用过程叫做推理。如果由程序来处理推理过程，那么这个程序就叫做推理机/推理引擎（Inference Engine）。推理机是专家系统（专家系统是人工智能的一个分支）的核心模块。&lt;/p&gt;
&lt;p&gt;&lt;img alt="推理机" src="images/rule-engine/inference_engine.png"&gt;&lt;/p&gt;
&lt;p&gt;推理引擎根据知识表示的不同采取的控制策略也是不同的，常见的类型包括基于神经网络、基于案例和基于规则的推理机。其中，基于规则的推理机易于理解、易于获取、易于管理，被广泛采用。这种推理引擎被称为“规则引擎”。&lt;/p&gt;
&lt;p&gt;在规则引擎中，将知识表达为规则（rules），要分析的情况定义为事实（facts）。二者在内存中的存储分别称为Production Memory和Working Memory，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="规则引擎" src="images/rule-engine/rule_engine.png"&gt;&lt;/p&gt;
&lt;p&gt;rules和facts是规则引擎接受的输入参数，而规则引擎本身包括两个组成部分：Pattern Matcher和Agenda。Pattern Matcher根据facts找到匹配的rules，Agenda管理PatternMatcher挑选出来的规则的执行次序。在外围，还会有一个执行引擎（Execution Engine）负责根据Agenda输出的rules执行具体的操作。&lt;/p&gt;
&lt;p&gt;其中Pattern Matcher是规则引擎负责推理的核心。和人类的思维相对应，规则引擎中也存在两种推理方式：正向推理（Forward-Chaining）和反向推理（Backward-Chaining）。&lt;/p&gt;
&lt;p&gt;正向推理也叫演绎法，由事实驱动，从 一个初始的事实出发，不断地应用规则得出结论。首先在候选队列中选择一条规则作为启用规则进行推理，记录其结论作为下一步推理时的证据。如此重复这个过程，直到再无可用规则可被选用或者求得了所要求的解为止。&lt;/p&gt;
&lt;p&gt;反向推理也叫归纳法，由目标驱动，首先提出某个假设，然后寻找支持该假设的证据，若所需的证据都能找到，说明原假设是正确的；若无论如何都找不到所需要的证据，则说明原假设不成立，此时需要另做新的假设。&lt;/p&gt;
&lt;h1&gt;规则引擎的作用&lt;/h1&gt;
&lt;p&gt;规则引擎可以将规则的定义从代码中分离出来，将推理过程封装到规则引擎内部进行处理，这带来几个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;规则外部化，即有利于规则知识的复用，也可避免改变规则时带来的代码变更问题&lt;/li&gt;
&lt;li&gt;由规则引擎使用某种算法进行推理过程，不需要编写复杂晦涩的逻辑判断代码&lt;/li&gt;
&lt;li&gt;开发人员的不需要过多关注逻辑判断，可以专注于逻辑处理&lt;/li&gt;
&lt;/ol&gt;</content><category term="规则引擎"></category></entry><entry><title>多线程的基本概念</title><link href="http://holbrook.github.io/2012/02/23/multi_thread.html" rel="alternate"></link><published>2012-02-23T00:00:00+08:00</published><updated>2012-02-23T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-02-23:/2012/02/23/multi_thread.html</id><summary type="html"></summary><content type="html">&lt;p&gt;多线程编程必须理解的一些基本概念，适用于所有编程语言。内容：
并发式编程
多任务操作系统
多线程vs多进程
线程安全
线程的生命周期
线程的类型&lt;/p&gt;
&lt;h1&gt;并发式编程&lt;/h1&gt;
&lt;p&gt;不同的编程范式对软件有不同的视角。并发式编程将软件看做任务和资源的组合——任务之间竞争和共享资源，当资源满足时执行任务，否则等待资源。&lt;/p&gt;
&lt;p&gt;并发式编程使得软件易于理解和重用，在某些场景能够极大提高性能。&lt;/p&gt;
&lt;h1&gt;多任务操作系统&lt;/h1&gt;
&lt;p&gt;要实现并发，首先需要操作系统的支持。现在的操作系统大部分都是多任务操作系统，可以“同时”执行多个任务。&lt;/p&gt;
&lt;p&gt;多任务可以在进程或线程的层面执行。
进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间。多任务操作系统可以“并发”执行这些进程。
线程是指进程中乱序、多次执行的代码块，多个线程可以“同时”运行，所以认为多个线程是“并发”的。多线程的目的是为了最大限度的利用CPU资源。比如一个JVM进程中，所有的程序代码都以线程的方式运行。&lt;/p&gt;
&lt;p&gt;这里面的“同时”、“并发”只是一种宏观上的感受，实际上从微观层面看只是进程/线程的轮换执行，只不过切换的时间非常短，所以产生了“并行”的感觉。&lt;/p&gt;
&lt;h1&gt;多线程vs多进程&lt;/h1&gt;
&lt;p&gt;操作系统会为每个进程分配不同的内存块，而多个线程共享进程的内存块。这带来最直接的不同就是创建线程的开销远小于创建进程的开销。&lt;/p&gt;
&lt;p&gt;同时，由于内存块不同，所以进程之间的通信相对困难。需要采用pipe/named pipe，signal, message queue, shared memory,socket等手段；而线程间的通信简单快速，就是共享进程内的全局变量。&lt;/p&gt;
&lt;p&gt;但是，进程的调度由操作系统负责，线程的调度就需要我们自己来考虑，避免死锁，饥饿，活锁，资源枯竭等情况的发生，这会增加一定的复杂度。而且，由于线程之间共享内存，我们还需要考虑线程安全性的问题。&lt;/p&gt;
&lt;h1&gt;线程安全&lt;/h1&gt;
&lt;p&gt;因为线程间共享进程中的全局变量，所以当其他线程改变了共享的变量时，可能会对本线程产生影响。&lt;/p&gt;
&lt;p&gt;所谓线程安全的约束是指一个函数被多个并发线程反复调用时，要一直产生正确的结果。要保证线程安全，主要是通过加锁的方式保证共享变量的正确访问。&lt;/p&gt;
&lt;p&gt;比线程安全更严格的约束是"可重入性"，即函数在一个线程内执行的过程中被暂停，接下来又在另一个线程内被调用，之后在返回原线程继续执行。在整个过程中都能保证正确执行。保证可重入性，通常通过制作全局变量的本地拷贝来实现。&lt;/p&gt;
&lt;h1&gt;线程的生命周期&lt;/h1&gt;
&lt;p&gt;所谓的xx生命周期，其实就是某对象的包含产生和销毁的一张状态图。线程的生命周期如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="multi-thread-states" src="images/2013/multi_thread/thread_state.jpg"&gt;&lt;/p&gt;
&lt;p&gt;各状态的说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New新建。新创建的线程经过初始化后，进入Runnable状态。&lt;/li&gt;
&lt;li&gt;Runnable就绪。等待线程调度。调度后进入运行状态。&lt;/li&gt;
&lt;li&gt;Running运行。&lt;/li&gt;
&lt;li&gt;Blocked阻塞。暂停运行，解除阻塞后进入Runnable状态重新等待调度。&lt;/li&gt;
&lt;li&gt;Dead消亡。线程方法执行完毕返回或者异常终止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能有3种情况从Running进入Blocked：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步：线程中获取同步锁，但是资源已经被其他线程锁定时，进入Locked状态，直到该资源可获取（获取的顺序由Lock队列控制）&lt;/li&gt;
&lt;li&gt;睡眠：线程运行sleep()或join()方法后，线程进入Sleeping状态。区别在于sleep等待固定的时间，而join是等待子线程执行完。当然join也可以指定一个“超时时间”。从语义上来说，如果两个线程a,b, 在a中调用b.join()，相当于合并(join)成一个线程。最常见的情况是在主线程中join所有的子线程。&lt;/li&gt;
&lt;li&gt;等待：线程中执行wait()方法后，线程进入Waiting状态，等待其他线程的通知(notify）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;线程的类型&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;主线程：当一个程序启动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程（Main Thread）。每个进程至少都有一个主线程，主线程通常最后关闭。&lt;/li&gt;
&lt;li&gt;子线程：在程序中创建的其他线程，相对于主线程来说就是这个主线程的子线程。&lt;/li&gt;
&lt;li&gt;守护线程：daemon thread，对线程的一种标识。守护线程为其他线程提供服务，如JVM的垃圾回收线程。当剩下的全是守护线程时，进程退出。&lt;/li&gt;
&lt;li&gt;前台线程：相对于守护线程的其他线程称为前台线程。&lt;/li&gt;
&lt;/ul&gt;</content><category term="多线程"></category></entry><entry><title>My super title</title><link href="http://holbrook.github.io/2010/12/03/demo.html" rel="alternate"></link><published>2010-12-03T10:20:00+08:00</published><updated>2010-12-03T10:20:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2010-12-03:/2010/12/03/demo.html</id><summary type="html">&lt;p&gt;Short version for index and feeds&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is the content of my super blog post.&lt;/p&gt;</content><category term="pelican"></category></entry></feed>