<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>心内求法 - 软件开发</title><link href="http://holbrook.github.io/" rel="alternate"></link><link href="http://holbrook.github.io/feeds/ruan-jian-kai-fa.atom.xml" rel="self"></link><id>http://holbrook.github.io/</id><updated>2015-05-04T00:00:00+08:00</updated><entry><title>搭建一个“现代化”的web开发环境</title><link href="http://holbrook.github.io/2015/05/04/modern_web_dev_env.html" rel="alternate"></link><published>2015-05-04T00:00:00+08:00</published><updated>2015-05-04T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2015-05-04:/2015/05/04/modern_web_dev_env.html</id><summary type="html">&lt;p&gt;使用yoeman, bower, grunt等工具开发web。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;目标&lt;/h1&gt;
&lt;p&gt;将要开展的一个项目，使用Angularjs 和 Flask开发一个web界面，
作为saltstack和其他自行开发的python小工具的前端界面，
实现自己的“运维操作平台”。&lt;/p&gt;
&lt;p&gt;为了统一框架、工具和开发方式，在本文中描述了项目的一些约定。
这些约定具有通用性，应该是目前基于python的web开发技术中，
比较”主流“和”先进“的方式，所以也可以作为开发其他应用的参考。&lt;/p&gt;
&lt;h1&gt;工具和框架&lt;/h1&gt;
&lt;h2&gt;工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;版本管理
    基于&lt;a href="http://gogs.io/"&gt;gogs&lt;/a&gt; 的私有git&lt;/li&gt;
&lt;li&gt;问题管理、版本发布、资料共享
    &lt;a href="http://www.redmine.org/"&gt;redmine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;项目管理
    &lt;a href="http://www.redminebacklogs.net/"&gt;redmine的scrum插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nodejs包管理器
    &lt;a href="https://www.npmjs.com/"&gt;npm&lt;/a&gt;(node package manager)。&lt;/p&gt;
&lt;p&gt;本文中，npm仅作为安装yoeman, bower，grunt等的基础工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;js依赖管理: &lt;a href="http://bower.io/"&gt;bower&lt;/a&gt;
    npm可以安装js包，但是没有解决依赖的问题。而bower解决了js包的依赖管理。类似maven中的依赖管理功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端构建工具: &lt;a href="http://gruntjs.com/"&gt;grunt&lt;/a&gt;
    js开发中的项目构建工具，类似maven/ant/makefile，
    通过配置文件执行压缩,编译, 单元测试, 代码检查以及打包发布的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端脚手架工具
    &lt;a href=""&gt;yoeman&lt;/a&gt;。类似maven的archetypes。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python开发环境管理
    &lt;a href="http://virtualenv-chinese-docs.readthedocs.org/en/latest/"&gt;virtualenv&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;框架和插件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;样式库 &lt;a href="http://getbootstrap.com/"&gt;Bootstrap&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/nnnick/Chart.js/"&gt;chartjs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端框架：&lt;a href="https://angularjs.org/"&gt;AngularJS&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;后端框架：&lt;a href=""&gt;Flask&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Flask-SQLAlchemy&lt;/li&gt;
&lt;li&gt;Flask-RESTful&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;环境准备&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;本文中仅给出MacOS下的安装方法，其他系统可以阅读官方文档或参考资料。
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#安装npm&lt;/span&gt;
brew install npm

&lt;span class="c1"&gt;#全局安装工具&lt;/span&gt;
npm install -g yo grunt-cli grunt bower generator-angular

&lt;span class="c1"&gt;#安装virtualenv&lt;/span&gt;
sudo easy_install pip
sudo pip install virtualenv
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;搭建工程&lt;/h1&gt;
&lt;h2&gt;创建工程目录&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/web &lt;span class="se"&gt;\#&lt;/span&gt; 前端工程目录 mkdir -p
PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME &lt;span class="se"&gt;\#&lt;/span&gt; 后端工程目录 &lt;span class="se"&gt;\#&lt;/span&gt;+END
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;创建前端工程&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/web yo angular &lt;span class="se"&gt;\#&lt;/span&gt; 一些交互，按照自己的需要选择即可。 &lt;span class="se"&gt;\#&lt;/span&gt;...
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;配置前端工程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改IP地址&lt;/p&gt;
&lt;p&gt;将connect -&gt; hostname, 由'localhost' 改为 '0.0.0.0'&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改dist目录&lt;/p&gt;
&lt;p&gt;将appConfig -&gt; dist 有 'dist' 改为 '../app/APP_NAME/static'&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;virtualenv&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT
virtualenv venv
&lt;span class="nb"&gt;source&lt;/span&gt; venv/bin/activate
pip install flask
pip install sqlalchemy
pip install flask-sqlalchemy
...
pip freeze &amp;gt; app/requirements.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;构建Flask工程&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/common
mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/models
mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/static
mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/templates
mkdir -p PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/views

touch PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/common/__init__.py
touch PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/models/__init__.py
touch PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app/APP&lt;span class="se"&gt;\_&lt;/span&gt;NAME/views/__init__.py
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;配置git&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT
mv web/.gitattributes .
rm -f web/.gitignore
cat &amp;gt; .gitignore &lt;span class="s"&gt;&amp;lt;&amp;lt; EOF&lt;/span&gt;
&lt;span class="s"&gt;web/node_modules&lt;/span&gt;
&lt;span class="s"&gt;web/.tmp&lt;/span&gt;
&lt;span class="s"&gt;web/.sass-cache&lt;/span&gt;
&lt;span class="s"&gt;web/bower_components&lt;/span&gt;
&lt;span class="s"&gt;dist&lt;/span&gt;
&lt;span class="s"&gt;venv&lt;/span&gt;
&lt;span class="s"&gt;EOF&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;使用&lt;/h1&gt;
&lt;p&gt;以上是工程框架搭建的过程，对于开发人员，不需要要这么麻烦，只要从版本库中获取源代码后进行初始化即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone xxxx &lt;span class="nb"&gt;cd&lt;/span&gt; PROJ_ROOT
virtualenv venv
&lt;span class="nb"&gt;source&lt;/span&gt; venv/bin/activate
pip install -r app/requirements.txt
&lt;span class="nb"&gt;cd&lt;/span&gt; web
npm install
bower install
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;启动前端&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; PROJ_ROOT/web
grunt serve
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后通过http://0.0.0.0:9000可以访问前端界面。&lt;/p&gt;
&lt;h2&gt;启动后端&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; PROJ&lt;span class="se"&gt;\_&lt;/span&gt;ROOT/app
python run.py
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;然后通过http://127.0.0.1:5000/ 访问后端应用。
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;知识准备&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;在开始开发之前，开发人员最好熟悉以下内容：

- Bootstrap入门: http://v3.bootcss.com/getting-started/
- Angularjs入门教程: http://www.ituring.com.cn/article/13471
- Flask系列教程 :http://www.oschina.net/translate/the-flask-mega-tutorial-part-i-hello-world
- SQLAlchemy教程:
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;NPM小结 chyingp http://www.cnblogs.com/chyingp/p/npm.html&lt;/li&gt;
&lt;li&gt;bower解决js的依赖管理 | 粉丝日志
    http://blog.fens.me/nodejs-bower-intro/&lt;/li&gt;
&lt;li&gt;getting started with Yeoman http://yeoman.io/learning/index.html&lt;/li&gt;
&lt;li&gt;Yeoman自动构建js项目 | 粉丝日志
    http://blog.fens.me/nodejs-yeoman-intro/&lt;/li&gt;
&lt;li&gt;grunt让Nodejs规范起来 | 粉丝日志
    http://blog.fens.me/nodejs-grunt-intro/&lt;/li&gt;
&lt;li&gt;Bootstrap入门 http://v3.bootcss.com/getting-started/&lt;/li&gt;
&lt;li&gt;AngularJS入门教程 http://www.ituring.com.cn/article/13471&lt;/li&gt;
&lt;li&gt;Flask系列教程
    http://www.oschina.net/translate/the-flask-mega-tutorial-part-i-hello-world&lt;/li&gt;
&lt;li&gt;使用 Flask 和 AngularJS 构建博客 - 1
    http://segmentfault.com/a/1190000000654088&lt;/li&gt;
&lt;li&gt;使用 Flask 和 AngularJS 构建博客 - 2
    http://segmentfault.com/a/1190000000665636&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;references:
- id: fenner2012a
  title: One-click science marketing
    author:
      - family: Fenner
        given: Martin
        container-title: Nature Materials
        volume: 11
        URL: 'http://dx.doi.org/10.1038/nmat3283'
        DOI: 10.1038/nmat3283
        issue: 4
        publisher: Nature Publishing Group
        page: 261-263
        type: article-journal
        issued:
        year: 2012
        month: 3&lt;/p&gt;
&lt;hr&gt;</content><category term="web"></category></entry><entry><title>Apache Karaf：OSGi中间件</title><link href="http://holbrook.github.io/2014/02/20/apache_karaf.html" rel="alternate"></link><published>2014-02-20T00:00:00+08:00</published><updated>2014-02-20T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-02-20:/2014/02/20/apache_karaf.html</id><summary type="html">&lt;h1&gt;为什么需要“OSGi中间件”&lt;/h1&gt;
&lt;p&gt;尽管在OSGi Runtime(Felix, Equinox等)的基础上，OSGi组织又规定了&lt;a href="/2014/01/22/osgi_blueprint_container.html"&gt;Blueprint规范以实现OSGi环境下的依赖注入&lt;/a&gt;，
但这还不够——没有提供类似Web开发框架那样的一些“平台级”的功能。比如日志，控制台，配置文件等。&lt;/p&gt;
&lt;p&gt;很难想象没有Tomcat这样的Web中间件，开发Java Web应用的工作量有多大。同样的，OSGi应用也需要一种“中间件”，来实现各应用共性的一些功能，并管理应用的部署。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://karaf.apache.org/"&gt;Apache Karaf&lt;/a&gt;就是这样的一个"OSGi中间件"。最早，Karaf只是&lt;a href="http://servicemix.apache.org/"&gt;Apache ServiceMix&lt;/a&gt;的Kernel子项目，后来独立出来成为Apache的顶级项目。
目前，Apache Karaf已经用于Apache Geronimo, Apache ServiceMix, Fuse ESB等项目。&lt;/p&gt;
&lt;p&gt;Apache Karaf的主要竞争对手是&lt;a href="http://www.eclipse.org/virgo/"&gt;Eclipse Virgo&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;Apache Karaf的功能&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="images/fuse/Karaf.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Apache Karaf提供了如下 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;为什么需要“OSGi中间件”&lt;/h1&gt;
&lt;p&gt;尽管在OSGi Runtime(Felix, Equinox等)的基础上，OSGi组织又规定了&lt;a href="/2014/01/22/osgi_blueprint_container.html"&gt;Blueprint规范以实现OSGi环境下的依赖注入&lt;/a&gt;，
但这还不够——没有提供类似Web开发框架那样的一些“平台级”的功能。比如日志，控制台，配置文件等。&lt;/p&gt;
&lt;p&gt;很难想象没有Tomcat这样的Web中间件，开发Java Web应用的工作量有多大。同样的，OSGi应用也需要一种“中间件”，来实现各应用共性的一些功能，并管理应用的部署。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://karaf.apache.org/"&gt;Apache Karaf&lt;/a&gt;就是这样的一个"OSGi中间件"。最早，Karaf只是&lt;a href="http://servicemix.apache.org/"&gt;Apache ServiceMix&lt;/a&gt;的Kernel子项目，后来独立出来成为Apache的顶级项目。
目前，Apache Karaf已经用于Apache Geronimo, Apache ServiceMix, Fuse ESB等项目。&lt;/p&gt;
&lt;p&gt;Apache Karaf的主要竞争对手是&lt;a href="http://www.eclipse.org/virgo/"&gt;Eclipse Virgo&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;Apache Karaf的功能&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="images/fuse/Karaf.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Apache Karaf提供了如下“开箱即用”的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;热部署&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管OSGi支持热部署，但并不是自动热部署，需要调用一些API去执行插拔的动作。Karaf在运行时可以自动处理&lt;code&gt;[home]/deploy&lt;/code&gt;文件夹中的OSGi bundle，能够自动加载并在满足依赖关系时自动启动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Karaf在&lt;code&gt;$KARAF_HOME/etc&lt;/code&gt;文件夹中存储配置文件。这些配置内容可以在Karaf运行时动态修改。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于Log4J的日志系统，同时支持多种日志API，如JDK 1.4, JCL, SLF4J, Avalon, Tomcat, OSGi等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Karaf可以作为系统服务运行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制台&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以在控制台进行服务管理、安装bundle等操作。还可以扩展自己的控制台命令。&lt;/p&gt;
&lt;p&gt;可以通过SSH远程访问其他服务器上的Karaf控制台。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多实例管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个服务器上可以运行多个Karaf实例。对实例的管理可以在Karaf控制台中进行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bundle仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Karaf中内置了&lt;a href="https://ops4j1.jira.com/wiki/display/paxurl/Pax+URL"&gt;Pax URL&lt;/a&gt;的MVN协议，可以从Maven中央仓库安装bundle。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bundle集合(Feature)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似于Eclipse的Feature，Karaf中也支持Feature，即bundle的集合。使用Feature可以简化OSGi应用的部署。&lt;/p&gt;
&lt;h1&gt;Karaf初体验&lt;/h1&gt;
&lt;p&gt;安装好Java环境，加压缩Karaf，执行&lt;code&gt;$KARAF_HOME/bin/karaf&lt;/code&gt;，可以看到Karaf的启动界面：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/karaf/karaf1.png"&gt;&lt;/p&gt;
&lt;p&gt;如图的提示，使用&lt;code&gt;&amp;lt;tab&amp;gt;&lt;/code&gt;可以列出所有可用的命令，所有的命令支持&lt;code&gt;--help&lt;/code&gt;参数。&lt;/p&gt;
&lt;p&gt;如果执行&lt;code&gt;list&lt;/code&gt;命令，可以列出所有的bundles:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/karaf/karaf2.png"&gt;&lt;/p&gt;
&lt;p&gt;还有很多其他的命令，比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bundle:install&lt;/code&gt; 安装bundle&lt;/li&gt;
&lt;li&gt;&lt;code&gt;feature:repo-add&lt;/code&gt; 安装feature库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;feature:install&lt;/code&gt; 安装feature&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等。详情可以参考官方的&lt;a href="http://karaf.apache.org/manual/latest/quick-start.html"&gt;Quick Start&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果查看Karaf的目录，可以看到如下的目录结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/bin&lt;/code&gt;: 启动、停止、登录karaf控制台的脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc&lt;/code&gt;: 配置文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/data&lt;/code&gt;: 存放运行时的工作文件，清空这个目录可以使Karaf回到初始状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/cache&lt;/code&gt;: OSGi framework的bundle缓存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/generated-bundles&lt;/code&gt;: 开发用的临时目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/log&lt;/code&gt;: 日志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/deploy&lt;/code&gt;: 用于bundle的热部署&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/instances&lt;/code&gt;: 存放karaf的各个实例用到的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/lib&lt;/code&gt;: 启动Karaf时需要的一些库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/lib/ext&lt;/code&gt;: Karaf需要的扩展库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/lib/endorsed&lt;/code&gt;: Karaf对其他API的再封装(背书)的一些jar包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/system&lt;/code&gt;: OSGi bundles库，使用Maven 2仓库的结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Karaf启动模式和实例&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;常规模式(regular mode) 使用命令&lt;code&gt;bin/karaf&lt;/code&gt;，可以在前端启动Karaf并进入控制台&lt;/li&gt;
&lt;li&gt;服务模式(server mode) 使用命令&lt;code&gt;bin/karaf server&lt;/code&gt;，可以在前端启动Karaf，但不进入控制台&lt;/li&gt;
&lt;li&gt;后台模式(background mode) 使用命令&lt;code&gt;bin/start&lt;/code&gt;，可以在后台启动Karaf。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果安装了service-wrapper(可以在Karaf中执行&lt;code&gt;feature:install service-wrapper&lt;/code&gt;)，还可以将
Karaf安装为系统服务。&lt;/p&gt;
&lt;p&gt;一个Karaf节点可以运行多个"Karaf实例"。实际上，默认情况下Karaf会启动一个名为&lt;code&gt;root&lt;/code&gt;的实例。
实例是包含单独的配置文件、数据文件等信息的一个Karaf副本，每个实例可以单独启动或部署bundle。&lt;/p&gt;
&lt;p&gt;Karaf控制台中提供了一些管理实例的命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;instance:create&lt;/code&gt; 创建实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance:clone&lt;/code&gt; 从现有的实例克隆一个新的实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance:start&lt;/code&gt; 启动实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance:status&lt;/code&gt; 查看实例状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance:connect&lt;/code&gt; 连接(切换)到某个实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance:stop&lt;/code&gt; 停止实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance:destroy&lt;/code&gt; 删除实例&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ssh、客户端和Web控制台&lt;/h1&gt;
&lt;p&gt;Karaf内置了一个SSHd server，可以通过ssh远程访问Karaf控制台。
要启动远程控制台服务，需要在控制台中启动bundle: &lt;code&gt;bundle:restart -f org.apache.karaf.shell.ssh&lt;/code&gt;。此时，远端可以使用ssh远程访问控制台，比如: &lt;code&gt;ssh -p 8101 karaf@localhost&lt;/code&gt;。默认karaf用户的密码也是karaf。ssh的用户、密码、端口等都可以在&lt;code&gt;etc/org.apache.karaf.shell.cfg&lt;/code&gt;中配置。&lt;/p&gt;
&lt;p&gt;Karaf的客户端'bin/client'即可以连接本地控制台，也可以通过ssh连接远程控制台，甚至可以执行单个的命令。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bin/client -u karaf -p karaf -a 8101 hostname osgi:shutdown
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Karaf还可以安装Web控制台(&lt;code&gt;feature:install webconsole&lt;/code&gt;)。通过Web控制台能够管理
Karaf的bundle、feature、实例、配置以及查看日志。启动web控制台后，默认可以通过&lt;a href="http://localhost:8181/system/console"&gt;http://localhost:8181/system/console&lt;/a&gt;
访问web控制台，默认的用户名/密码为&lt;code&gt;karaf/karaf&lt;/code&gt;。Web控制台的配置文件位于&lt;code&gt;etc/org.ops4j.pax.web.cfg&lt;/code&gt;。&lt;/p&gt;
&lt;h1&gt;bundle URL和bundle仓库&lt;/h1&gt;
&lt;p&gt;Karaf在安装bundle时，可以使用多种URL来定位bundle，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;http &lt;code&gt;http://repo1.maven.org/maven2/org/apache/servicemix/nmr/org.apache.servicemix.nmr.api/1.0.0-m2/org.apache.servicemix.nmr.api-1.0.0-m2.jar&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;file &lt;code&gt;file:base/bundles/org.apache.servicemix.nmr.api-1.0.0-m2.jar&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;maven库 &lt;code&gt;mvn:org.apache.servicemix.nmr/org.apache.servicemix.nmr.api/1.0.0-m2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，maven库方式是使用maven库作为bundle仓库，从其中检索需要的bundle。与maven类似，可以自动解决bundle之间的依赖问题。
Karaf提供了OBR (OSGi Bundle Repository)，能够管理bundle仓库。在控制台使用命令&lt;code&gt;feature:install obr&lt;/code&gt;安装OBR之后，就可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加新的bundle仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;obr:url-add file:///user/.m2/repository/repository.xml&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看已安装的bundle仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;obr:url-list&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刷新仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;obr:url-refresh&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;obr:url-remove&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出所有可用的bundle&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;obr:list&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找bundle&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;obr:find&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;OSGi应用，Karaf Feature和KAR&lt;/h1&gt;
&lt;p&gt;OSGi运行的基本单元是bundle，bundle之间有依赖关系。一组满足依赖关系的bundle集合，加上相关的配置信息，称为一个“OSGi应用”。
将OSGi应用部署到Karaf的行为称为“provisioning”。&lt;/p&gt;
&lt;p&gt;为了简化OSGi应用的部署，Karaf定义了feature，用于描述OSGi应用的部署信息，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名称&lt;/li&gt;
&lt;li&gt;版本号&lt;/li&gt;
&lt;li&gt;描述信息&lt;/li&gt;
&lt;li&gt;bundle集合&lt;/li&gt;
&lt;li&gt;配置文件信息&lt;/li&gt;
&lt;li&gt;依赖的其他feature&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出，Karaf中的feature与Eclipse Feature非常类似。&lt;/p&gt;
&lt;p&gt;Karaf控制台中提供了一系列的feature和feature库的管理命令，包括：
- feature:info
- feature:install
- feature:list
- feature:repo-add
- feature:repo-list
- feature:repo-refresh
- feature:repo-remove
- feature:uninstall
- feature:version-list&lt;/p&gt;
&lt;p&gt;由于feature中可能使用远端的bundle，Karaf提出了&lt;code&gt;KAR&lt;/code&gt;格式，可以把一个bundle相关的所有资源打包在一起。
这类似于使用maven定义的web工程，和最终打包的war文件之间的关系。
Karaf控制台中，可以打包(&lt;code&gt;kar:create&lt;/code&gt;)、安装(&lt;code&gt;kar:install&lt;/code&gt;)、卸载(&lt;code&gt;kar:uninstall&lt;/code&gt;)或列出(&lt;code&gt;kar:list&lt;/code&gt;)KAR文件。&lt;/p&gt;
&lt;h1&gt;企业级特性&lt;/h1&gt;
&lt;p&gt;Karaf提供了一系列的功能，以支持企业级应用的开发，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Karaf提供了&lt;a href="http://karaf.apache.org/manual/latest/users-guide/log.html"&gt;灵活的日志系统&lt;/a&gt;，支持&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OSGi Log Service&lt;/li&gt;
&lt;li&gt;Log4j&lt;/li&gt;
&lt;li&gt;Commons Logging&lt;/li&gt;
&lt;li&gt;Logback&lt;/li&gt;
&lt;li&gt;SLF4J&lt;/li&gt;
&lt;li&gt;java Util Logging&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等日志框架。不管应用中使用了上述哪种日志框架，Karaf中都可以进行统一的管理，如log level, appender等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Karaf提供了基于JAAS(Java Authentication and Authorization Service)的&lt;a href="http://karaf.apache.org/manual/latest/users-guide/security.html"&gt;安全框架&lt;/a&gt;，可以控制对OSGi service、控制台命令、JMX、Web控制台等资源的访问。并且在应用中也可以使用Karaf的安全框架。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Karaf可以&lt;a href="http://karaf.apache.org/manual/latest/users-guide/webcontainer.html"&gt;作为Web容器&lt;/a&gt;使用，完全支持JSP/Servlet规范。
  Karaf的Web容器同时支持WAR和WAB的部署。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JNDI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Karaf&lt;a href="http://karaf.apache.org/manual/latest/users-guide/jndi.html"&gt;支持OSGi中的JNDI服务&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDBC、JPA和JTA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Karaf中即可以&lt;a href="http://karaf.apache.org/manual/latest/users-guide/jdbc.html"&gt;使用JDBC&lt;/a&gt;直接连接数据库，
  也可以&lt;a href="http://karaf.apache.org/manual/latest/users-guide/jpa.html"&gt;使用JPA&lt;/a&gt;作为持久层框架。Karaf可以通过Blueprint管理JPA的persist Unit。&lt;/p&gt;
&lt;p&gt;Karaf支持&lt;a href="http://karaf.apache.org/manual/latest/users-guide/jta.html"&gt;JTA&lt;/a&gt;，以实现容器管理的事务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Karaf还支持&lt;a href="http://karaf.apache.org/manual/latest/users-guide/ejb.html"&gt;EJB&lt;/a&gt;、&lt;a href="http://karaf.apache.org/manual/latest/users-guide/cdi.html"&gt;CDI&lt;/a&gt;、&lt;a href="http://karaf.apache.org/manual/latest/users-guide/monitoring.html"&gt;JMX&lt;/a&gt;、&lt;a href="http://karaf.apache.org/manual/latest/users-guide/jms.html"&gt;JMS&lt;/a&gt;等企业级特性。&lt;/p&gt;
&lt;p&gt;Karaf内置支持主备方式的部署，以保证高可用。使用&lt;a href="http://karaf.apache.org/index/subprojects/cellar.html"&gt;Apache Karaf Cellar&lt;/a&gt;可以实现Karaf的集群部署。&lt;/p&gt;</content><category term="OSGi"></category></entry><entry><title>命令行界面设计</title><link href="http://holbrook.github.io/2014/01/30/cli_design.html" rel="alternate"></link><published>2014-01-30T00:00:00+08:00</published><updated>2014-01-30T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-01-30:/2014/01/30/cli_design.html</id><summary type="html">&lt;p&gt;尽管8年后的1973年出现了图形界面程序，
16年后的1981年出现了图形界面的操作系统，
但是在此之后，至今三十几年过去了，图形界面(GUI)仍无法取代命令行界面(CLI)。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;命令行界面是否过时&lt;/h1&gt;
&lt;p&gt;答案是：不会的！&lt;/p&gt;
&lt;p&gt;1965年&lt;a href="http://en.wikipedia.org/wiki/OS/360_and_successors"&gt;OS/360&lt;/a&gt;的发布标志着与硬件分离的“通用”操作系统的出现。&lt;/p&gt;
&lt;p&gt;尽管8年后的1973年出现了&lt;a href="http://en.wikipedia.org/wiki/Xerox_Alto"&gt;图形界面程序&lt;/a&gt;，
16年后的1981年出现了&lt;a href="http://en.wikipedia.org/wiki/Xerox_Star"&gt;图形界面的操作系统&lt;/a&gt;，
但是在此之后，至今三十几年过去了，图形界面(GUI)仍无法取代命令行界面(CLI)。&lt;/p&gt;
&lt;p&gt;有什么理由可以说，图形界面终将取代命令行界面呢？&lt;/p&gt;
&lt;p&gt;不管是传统的linux“神器”，如find, grep, curl, netcat, xargs, rsync,
screen，awk, vi, emacs， 还是让人惊叹的新作，如maven, git,
salt，都有着强大的命令行界面。甚至你会有一种感觉：
为这些软件设计图形界面根本就是画蛇添足。&lt;/p&gt;
&lt;p&gt;命令行界面的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;效率高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鼠标操作是最简单，同时也是最笨拙的操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更专注&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鼠标操作容易分心&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速度快&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLI程序需要的资源少，启动和执行速度更快&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易远程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ssh、telnet的连接比vnc、remote desktop等更容易&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLI不仅可以给人使用，也适用于自动化脚本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zhuangbility&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;^o^&lt;/p&gt;
&lt;h1&gt;命令行界面的类型&lt;/h1&gt;
&lt;p&gt;按照复杂程度，命令行界面可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非交互式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一次性输入所有的参数，程序执行期间不需要用户的干预。这是最常见的命令行界面形式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于行的交互&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在执行过程中，需要用户输入一些内容，比如确认信息、路径参数等。&lt;/p&gt;
&lt;p&gt;由于用户交互会使程序难以用于自动化脚本，所以这种命令行界面并不多见，常用于基于命令行的安装程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本用户界面(TUI)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似于图形用户界面，没有明确的执行流程，完全由用户控制程序的执行步骤。比如vi和emacs。&lt;/p&gt;
&lt;h1&gt;CLI世界的潜规则&lt;/h1&gt;
&lt;p&gt;为了使你的CLI程序不会显得格格不入，在设计CLI程序时要遵守一些潜规则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;良好命名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容易理解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;名字要短&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容易记忆&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必备选项&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的命令行工具都应该提供=-v/--version=和=-h/--help=选项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持安静&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序的输出要"恰到好处"，让用户/其他程序明确知道必要的信息，又不过分“啰嗦”。过多的输出即会浪费系统资源和带宽，也会让用户感觉不舒服，更重要的是会使得其他程序的处理逻辑变得复杂。以下的原则有利于保持安静：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要输出无关的信息，比如版本号、作者名------除非用户要求&lt;/li&gt;
&lt;li&gt;对于很明确的结果，不需要再提醒用户。只应提示例外(exception)情况&lt;/li&gt;
&lt;li&gt;不需要告诉用户输出的是什么东西------用户会知道的&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如有必要，可以提供=-v/--verbose=和=-q/--quiet=选项，供用户选择&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;明确要求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在基于行的交互式CLI中，需要用户输入时要给出明确的提示，比如：&lt;/p&gt;
&lt;p&gt;=Do you really want to do this (y/n)?=&lt;/p&gt;
&lt;p&gt;=Enter a date (YYYY-MM-DD):=&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持管道&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序应该支持从管道或文件重定向中读取数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果文件名作为参数传递给程序，就读取文件的内容作为输入&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有提供这样的参数，就从标准输入中读取，一直到 CTRL+D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能单一&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UNIX哲学中重要的一条原则就是：每个程序只做一件事情，并把它做好。&lt;/p&gt;
&lt;p&gt;复杂的功能通过程序间的配合完成，而为了与其他的程序配合，要尽量支持管道和重定向。&lt;/p&gt;
&lt;p&gt;既然“只做一件事”，就要“做好一件事”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遵循惯例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UNIX中命令行参数会有一些惯例，比如=-=后面的单字母选项可以连用（如=ls -Al=),
=--=后面使用多字母选项等；此外，遵循已经被广泛使用的命令的参数，也会容易被接受。&lt;/p&gt;
&lt;h1&gt;CLI支持库&lt;/h1&gt;
&lt;p&gt;CLI是如此重要，以至于很多语言/平台都提供了开发CLI的支持库，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;python的optparse和argparse&lt;/p&gt;
&lt;p&gt;argparse更先进，旨在替代optparse，但是从python2.7开始才支持。如果希望在比较旧的linux上运行(通常支持python2.4)，最好还是使用optparse。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java的Apache Commons CLI&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Apache karaf的karaf-command-archetype&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;python的TUI支持库&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://urwid.org/index.html"&gt;Urwid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="CLI"></category></entry><entry><title>Blueprint: OSGi的依赖注入(DI)容器</title><link href="http://holbrook.github.io/2014/01/22/osgi_blueprint_container.html" rel="alternate"></link><published>2014-01-22T00:00:00+08:00</published><updated>2014-01-22T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-01-22:/2014/01/22/osgi_blueprint_container.html</id><summary type="html">&lt;p&gt;曾几何时，你在Spring和OSGi之间摇摆不定；曾几何时，你对SpringDM感到迷惑不解。你是否向往OSGi的动态特性，又为遗留代码（尤其是基于Spring的代码）感到不舍？现在，这些都不再是问题！&lt;/p&gt;</summary><content type="html">&lt;p&gt;曾几何时，你在Spring和OSGi之间摇摆不定；曾几何时，你对SpringDM感到迷惑不解。
你是否向往OSGi的动态特性，又为遗留代码（尤其是基于Spring的代码）感到不舍？&lt;/p&gt;
&lt;p&gt;现在，这些都不再是问题！&lt;/p&gt;
&lt;p&gt;在&lt;a href="http://www.osgi.org/Release4/HomePage"&gt;OSGi Service Platform Release 4&lt;/a&gt; V4.2中，
提到了很多的&lt;a href="http://www.osgi.org/download/r4v42/r4.enterprise.pdf"&gt;企业级规范(Enterprise Specification)&lt;/a&gt;，
其中包括了规范121：Blueprint容器规范(Container Specification)。&lt;/p&gt;
&lt;p&gt;Buleprint容器规范规定了一个OSGi容器(不是OSGi rumtime)的方方面面：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/fuse/Blueprint_Container_Specification_list.png"&gt;&lt;/p&gt;
&lt;p&gt;Buleprint(或者说，OSGi Enterprise)目前有两个主要的实现：&lt;a href="http://www.eclipse.org/gemini/"&gt;Eclipse Gemini&lt;/a&gt;和&lt;a href="http://aries.apache.org/"&gt;Apache Aries&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其中Gemini的代码最初来自Spring DM，其实Blueprint规范的最早版本也来自Spring；而Aries已经用在Apache的众多企业级产品中。&lt;/p&gt;
&lt;p&gt;在本文中，使用Aries Blueprint。&lt;/p&gt;
&lt;h1&gt;依赖注入&lt;/h1&gt;
&lt;p&gt;Blueprint Container 规范为 OSGi 定义了一个 依赖性注入（DI,Dependency Injection）框架，可以处理OSGi 的动态特性。
与&lt;a href="/2014/01/12/dependency_injection_in_e4.html#menuIndex2"&gt;OSGi服务&lt;/a&gt;或&lt;a href="/2014/01/12/dependency_injection_in_e4.html#menuIndex3"&gt;OSGi Declarative Service&lt;/a&gt;，不同，Blueprint依赖注入可以处理POJO对象的装配，使得POJO能够在OSGi中跨bundle访问。&lt;/p&gt;
&lt;p&gt;这与&lt;a href="http://thinkinside.tk/2013/12/31/jsr330.html"&gt;JSR330:Java依赖注入规范&lt;/a&gt;很像，是该规范在OSGi环境下的扩展。
这也就是Spring DM(Spring Dynamic Modules)干的事情。实际上，Buleprint容器规范最初就来自于Spring，
而其Gemini实现更是来自SpringDM的捐赠。&lt;/p&gt;
&lt;p&gt;无奈，如今&lt;a href="http://www.infoq.com/cn/news/2012/11/spring-osgi-gradle"&gt;Spring已经宣布放弃OSGi&lt;/a&gt;正所谓造化弄人，让人唏嘘不已。&lt;/p&gt;
&lt;h1&gt;Blueprint XML&lt;/h1&gt;
&lt;p&gt;Blueprint使用XML文件描述装配关系，下面是一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; standalone=&amp;quot;no&amp;quot;?&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;blueprint&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.osgi.org/xmlns/blueprint/v1.0.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

   &lt;span class="c"&gt;&amp;lt;!-- Bean Manager Examples --&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountOne&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.Account&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;argument&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;#1 account&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountTwo&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.StaticAccountFactory&amp;quot;&lt;/span&gt;
         &lt;span class="na"&gt;factory-method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;createAccount&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;argument&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;#2 account&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountFactory&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.AccountFactory&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;argument&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;account factory&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountThree&amp;quot;&lt;/span&gt;
         &lt;span class="na"&gt;factory-ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountFactory&amp;quot;&lt;/span&gt;
         &lt;span class="na"&gt;factory-method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;createAccount&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;argument&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;#3 account&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;prototypeAccount&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.Account&amp;quot;&lt;/span&gt;
         &lt;span class="na"&gt;scope=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;prototype&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;argument&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;4&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;singletonAccount&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.Account&amp;quot;&lt;/span&gt;
         &lt;span class="na"&gt;scope=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;singleton&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;argument&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;5&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountFour&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.Account&amp;quot;&lt;/span&gt;
         &lt;span class="na"&gt;init-method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;init&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;destroy-method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;destroy&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;argument&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;6&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;#6 account&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;



   &lt;span class="c"&gt;&amp;lt;!-- Service Manager Examples --&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myAccount&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.MyAccount&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;argument&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;7&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;MyAccount&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;service&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;serviceOne&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myAccount&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;interface=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;java.io.Serializable&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;service&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;serviceTwo&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myAccount&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;interfaces&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;java.io.Serializable&lt;span class="nt"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/interfaces&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/service&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;service&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;serviceThree&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myAccount&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;auto-export=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;all-classes&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;service&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;serviceFour&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myAccount&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;auto-export=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;all-classes&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;service-properties&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;entry&lt;/span&gt; &lt;span class="na"&gt;key=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mode&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;shared&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;entry&lt;/span&gt; &lt;span class="na"&gt;key=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;active&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;value&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;java.lang.Boolean&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/entry&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/service-properties&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/service&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;service&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;serviceFive&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myAccount&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;auto-export=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;all-classes&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;ranking=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;service&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;serviceSix&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myAccount&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;auto-export=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;all-classes&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;registration-listener&lt;/span&gt;
              &lt;span class="na"&gt;registration-method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;register&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;unregistration-method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unregister&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.RegistrationListener&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/registration-listener&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/service&amp;gt;&lt;/span&gt;



   &lt;span class="c"&gt;&amp;lt;!-- Service Reference Manager Examples --&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;reference-list&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;serviceReferenceListTwo&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;interface=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;java.io.Serializable&amp;quot;&lt;/span&gt;
                   &lt;span class="na"&gt;availability=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;optional&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;reference-listener&lt;/span&gt;
              &lt;span class="na"&gt;bind-method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bind&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;unbind-method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unbind&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.ReferenceListener&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/reference-listener&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/reference-list&amp;gt;&lt;/span&gt;



   &lt;span class="c"&gt;&amp;lt;!-- Environmental Manager Example --&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountManagerOne&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.AccountManager&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;managerBundle&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;blueprintBundle&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;



   &lt;span class="c"&gt;&amp;lt;!-- Object Values Examples --&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountManagerTwo&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.AccountManager&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;managedAccount&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
           &lt;span class="nt"&gt;&amp;lt;ref&lt;/span&gt; &lt;span class="na"&gt;component-id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountOne&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountManagerThree&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.AccountManager&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;managedAccount&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
           &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.Account&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
               &lt;span class="nt"&gt;&amp;lt;argument&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;10&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
               &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Inlined Account&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
           &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountManagerFour&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.apache.aries.samples.AccountManager&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accountNumbers&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
           &lt;span class="nt"&gt;&amp;lt;list&amp;gt;&lt;/span&gt;
               &lt;span class="nt"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;123&lt;span class="nt"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
               &lt;span class="nt"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;456&lt;span class="nt"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
               &lt;span class="nt"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;789&lt;span class="nt"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
           &lt;span class="nt"&gt;&amp;lt;/list&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

 &lt;span class="nt"&gt;&amp;lt;/blueprint&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出，这个文件与Spring的配置文件非常类似。&lt;/p&gt;
&lt;p&gt;Blueprint XML中可以标记&lt;code&gt;bean&lt;/code&gt;，&lt;code&gt;service&lt;/code&gt;、&lt;code&gt;reference-list&lt;/code&gt;等元素，用于bean管理、service管理和service引用管理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/fuse/blueprint_config.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bean管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过&lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;标签定义Bean，容器可以创建bean、设置属性。bean的创建可以基于构造函数、静态工厂或工厂方法；属性可以是基本类型，也可以引用其他的bean。可以设置bean的scope为singleton或prototype。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;bean只能在当前bundle中使用。要跨bundle引用，必须定义服务。服务可以依赖bean或其他服务。&lt;/p&gt;
&lt;p&gt;服务管理用于在OSGi服务注册表中注册服务。容器会根据服务的依赖关系是否满足，自动注册或注销服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service引用管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过&lt;code&gt;&amp;lt;reference&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;reference-list&amp;gt;&lt;/code&gt;标签可以引用其他bundle中发布的服务。两个标签分布用于引用单个服务和引用服务列表。&lt;/p&gt;
&lt;p&gt;一个bundle可以有一个或多个xml配置，通常位于&lt;code&gt;OSGI-INF/blueprint/&lt;/code&gt;目录下，也可以在&lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt;文件中通过
&lt;code&gt;Bundle-Blueprint&lt;/code&gt;属性进行指定。&lt;/p&gt;
&lt;p&gt;更多关于Blueprint XML配置的内容和例子，可以参考&lt;a href="http://aries.apache.org/documentation/tutorials/blueprinthelloworldtutorial.html"&gt;Apache Aries官方的例子&lt;/a&gt;，以及&lt;a href="https://www.ibm.com/developerworks/cn/opensource/os-osgiblueprint/"&gt;developerWorks上的这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;工作原理&lt;/h1&gt;
&lt;p&gt;Blueprint Container 使用扩展器（extender）模式，监视OSGi框架中的bundle的状态。当新的bundle被激活时，
Blueprint根据该bundle是否有Blueprint XML配置文件判断是否需要容器进行处理。&lt;/p&gt;
&lt;p&gt;处理的过程是为该bundle创建一个容器，通过容器解析XML文件，并将组件装配到一起。如果bundle中的服务依赖得到满足，容器还会调用&lt;a href="/2014/01/12/dependency_injection_in_e4.html#menuIndex3"&gt;OSGi DS&lt;/a&gt;发布服务。&lt;/p&gt;
&lt;p&gt;在停止bundle时，也会进行相反的销毁过程。&lt;/p&gt;
&lt;h1&gt;在Eclipse中运行和调试&lt;/h1&gt;
&lt;p&gt;可以在前面&lt;a href="/2014/01/21/tycho_vs_maven_bundle_plugin.html#menuIndex2"&gt;通过maven手工创建Felix运行环境&lt;/a&gt;的基础上，
增加Blueprint需要的bundle:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c"&gt;&amp;lt;!-- for aries blueprint --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactItem&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.aries.blueprint&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;org.apache.aries.blueprint&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/artifactItem&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactItem&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.aries.proxy&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;org.apache.aries.proxy&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/artifactItem&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactItem&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.aries&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;org.apache.aries.util&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/artifactItem&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactItem&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.felix&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;org.apache.felix.configadmin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.2.4&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/artifactItem&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactItem&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.ops4j.pax.logging&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;pax-logging-api&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.4&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/artifactItem&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactItem&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.ops4j.pax.logging&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;pax-logging-service&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.4&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/artifactItem&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;使用Apache Felix Karaf&lt;/h1&gt;
&lt;p&gt;自己搭建的Felix+Blueprint环境功能很有限，比如缺失了很多必要的基础组件和管理功能。更好的选择是使用&lt;a href="http://karaf.apache.org/"&gt;Apache Felix Karaf&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Karaf在Felix和Blueprint的基础上，还增加了一些插件，以提供认证和登录、热部署、动态配置、控制台以及一些管理功能。&lt;/p&gt;
&lt;p&gt;更贴心的是，Karaf还提供了Eclipse插件：&lt;a href="http://karaf.apache.org/index/subprojects/eik.html"&gt;Eclipse Integration for Karaf (EIK)&lt;/a&gt;，从而可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Custom Eclipse perspective for Apache Karaf development:&lt;/li&gt;
&lt;li&gt;places valuable Karaf runtime information in one location&lt;/li&gt;
&lt;li&gt;Apache Karaf installation management in your workspace:&lt;/li&gt;
&lt;li&gt;Karaf installations are managed as workspace projects giving the developer visibility in to the runtime&lt;/li&gt;
&lt;li&gt;each Karaf installation is automatically synchronized with your workspace, including additional bundles, configuration files&lt;/li&gt;
&lt;li&gt;Run and debug Karaf installations with a single Eclipse Launcher:&lt;/li&gt;
&lt;li&gt;the launch configuration allows developers to fine tune how Karaf will launch&lt;/li&gt;
&lt;li&gt;Automatic deployment of workspace plugin projects:&lt;/li&gt;
&lt;li&gt;create plugin-projects and have them deployed automatically&lt;/li&gt;
&lt;li&gt;Advanced instrumentation of the running Karaf instance:&lt;/li&gt;
&lt;li&gt;watch bundles deploy in real time and examine the OSGi service registry from within the Eclipse IDE&lt;/li&gt;
&lt;li&gt;Access Eclipse platform IDE plugins from within a running Karaf instance:&lt;/li&gt;
&lt;li&gt;all Eclipse plugins are presented as an OBR&lt;/li&gt;
&lt;/ul&gt;</content><category term="OSGi"></category><category term="java"></category></entry><entry><title>OSGi构建工具：Tycho还是Maven-Bundle-Plugin？</title><link href="http://holbrook.github.io/2014/01/21/tycho_vs_maven_bundle_plugin.html" rel="alternate"></link><published>2014-01-21T00:00:00+08:00</published><updated>2014-01-21T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-01-21:/2014/01/21/tycho_vs_maven_bundle_plugin.html</id><summary type="html">&lt;h1&gt;Tycho与Maven-Bundle-Plugin的对比&lt;/h1&gt;
&lt;p&gt;Maven与OSGi天生就是冤家：Maven通过&lt;code&gt;pom.xml&lt;/code&gt;描述一个产物的全部，而OSGi将这项工作交给了&lt;code&gt;MANIFEST.MF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果仅仅是一些定义信息还好说，但是Maven和OSGi都希望能够描述产物的依赖关系，在使用Maven开发OSGi bundle的时候，就导致了一个问题：&lt;/p&gt;
&lt;p&gt;依赖关系到底是在&lt;code&gt;pom.xml&lt;/code&gt;中描述，还是在&lt;code&gt;MANIFEST.MF&lt;/code&gt;中描述？&lt;/p&gt;
&lt;p&gt;&lt;a href="/2014/01/08/build_osgi_bundle_with_tycho_maven_plugin.html"&gt;前面提到的Tycho&lt;/a&gt;的思路是由&lt;code&gt;MANIFEST.MF&lt;/code&gt;自行管理bundle的依赖关系，&lt;code&gt;pom.xml&lt;/code&gt;只记录使用maven进行构建时需要的信息，比如maven工程的父子关系、打包时需要的bundle仓库及要发布的目标平台等。&lt;/p&gt;
&lt;p&gt;Tycho的这种机制对Eclipse IDE比较友好，在开发期间完全使用IDE的机制进行开发和调试，只有在打包部署时才依赖maven。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://felix.apache.org/site/apache-felix-maven-bundle-plugin-bnd.html"&gt;Apache Felix Maven-Bundle-Plugin&lt;/a&gt;
则使用另一套机制：使用Maven-Bundle-Plugin，在开发时可以没有&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件！Maven-Bundle-Plugin在&lt;code&gt;pom.xml&lt;/code&gt;中复制了一套&lt;code&gt;MANIFEST …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Tycho与Maven-Bundle-Plugin的对比&lt;/h1&gt;
&lt;p&gt;Maven与OSGi天生就是冤家：Maven通过&lt;code&gt;pom.xml&lt;/code&gt;描述一个产物的全部，而OSGi将这项工作交给了&lt;code&gt;MANIFEST.MF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果仅仅是一些定义信息还好说，但是Maven和OSGi都希望能够描述产物的依赖关系，在使用Maven开发OSGi bundle的时候，就导致了一个问题：&lt;/p&gt;
&lt;p&gt;依赖关系到底是在&lt;code&gt;pom.xml&lt;/code&gt;中描述，还是在&lt;code&gt;MANIFEST.MF&lt;/code&gt;中描述？&lt;/p&gt;
&lt;p&gt;&lt;a href="/2014/01/08/build_osgi_bundle_with_tycho_maven_plugin.html"&gt;前面提到的Tycho&lt;/a&gt;的思路是由&lt;code&gt;MANIFEST.MF&lt;/code&gt;自行管理bundle的依赖关系，&lt;code&gt;pom.xml&lt;/code&gt;只记录使用maven进行构建时需要的信息，比如maven工程的父子关系、打包时需要的bundle仓库及要发布的目标平台等。&lt;/p&gt;
&lt;p&gt;Tycho的这种机制对Eclipse IDE比较友好，在开发期间完全使用IDE的机制进行开发和调试，只有在打包部署时才依赖maven。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://felix.apache.org/site/apache-felix-maven-bundle-plugin-bnd.html"&gt;Apache Felix Maven-Bundle-Plugin&lt;/a&gt;
则使用另一套机制：使用Maven-Bundle-Plugin，在开发时可以没有&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件！Maven-Bundle-Plugin在&lt;code&gt;pom.xml&lt;/code&gt;中复制了一套&lt;code&gt;MANIFEST.MF&lt;/code&gt;的元数据，完全可以通过&lt;code&gt;pom.xml&lt;/code&gt;文件中的定义生成出完整的&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;Maven-Bundle-Plugin的这种机制使得工程完全的”maven化”，更适合传统非OSGi开发人员的使用习惯。但是无法很好的利用IDE的开发和调试功能，比如，你可能需要自己搭建一个运行环境从IDE中调用。&lt;/p&gt;
&lt;p&gt;两种方式可谓各有千秋。但是Tycho明显基于Equniox和Eclipse，比如，Tycho可以配置Eclipse p2站点作为bundle库。如果要使用Tycho开发和调试Felix，需要搭建一个Eclipse风格的p2站点，将Felix runtime和需要的各种bundle都放到该站点中并发布，然后&lt;a href="/2014/01/08/build_osgi_bundle_with_tycho_maven_plugin.html#menuIndex2"&gt;在Tycho中引用该站点&lt;/a&gt;。更详细的说明可以参考&lt;a href="http://vzurczak.wordpress.com/2013/02/27/a-target-platform-based-on-apache-felix/"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;而Felix Maven-Bundle-Plugin对于各种OSGi runtime的支持是相同的，由于完全基于maven，使用任何IDE开发bundle的效果都差不多。通常，Felix系的平台，如Karaf、Geronimo、Camel、ServiceMix、Fuse等，其例子都是使用Maven-Bundle-Plugin构建的。&lt;/p&gt;
&lt;p&gt;由于&lt;a href="/2014/01/08/build_osgi_bundle_with_tycho_maven_plugin.html"&gt;前文已经说明了如何用Tycho开发OSGi&lt;/a&gt;，下面只给出使用Maven-Bundle-Plugin的例子。&lt;/p&gt;
&lt;h1&gt;Maven-Bundle-Plugin的pom例子&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;project&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;thinkinside.demo.osgi&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;simple-bundle&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;


    &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.felix&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-bundle-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;generate-resources&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;manifest&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;

                        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;instructions&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;Bundle&lt;/span&gt;&lt;span class="err"&gt;-Name&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/Bundle-Name&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;Bundle&lt;/span&gt;&lt;span class="err"&gt;-SymbolicName&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;artifactId&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/Bundle-SymbolicName&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;Bundle&lt;/span&gt;&lt;span class="err"&gt;-Activator&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;test.bundle.internal.Activator&lt;span class="nt"&gt;&amp;lt;/Bundle-Activator&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;Export&lt;/span&gt;&lt;span class="err"&gt;-Package&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;***&lt;span class="nt"&gt;&amp;lt;/Export-Package&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;Import&lt;/span&gt;&lt;span class="err"&gt;-Package&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;***&lt;span class="nt"&gt;&amp;lt;/Import-Package&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;Private&lt;/span&gt;&lt;span class="err"&gt;-Package&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;***&lt;span class="nt"&gt;&amp;lt;/Private-Package&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;/instructions&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;

            &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-jar-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.3.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;archive&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;manifestFile&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;outputDirectory&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/META-INF/MANIFEST.MF&lt;span class="nt"&gt;&amp;lt;/manifestFile&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;/archive&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;

    &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.felix&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;org.osgi.core&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.4.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用Maven-Bundle-Plugin构建bundle，就是构建一个简单的jar。不同之处在于：要通过pom.xml中的信息生成符合OSGi要求的&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件并打包到jar中。这通过两个插件来完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;org.apache.felix:maven-bundle-plugin&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在项目生命周期的"generate-resources"阶段，根据&lt;code&gt;&amp;lt;instructions&amp;gt;&lt;/code&gt;标签内定义的信息生成&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件。这里可以配置OSGi所需要的全部元数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;org.apache.maven.plugins:maven-jar-plugin&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置其在打包是使用前面生成的&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;由于OSGi bundle通常会使用OSGi API，这里添加了org.apache.felix:org.osgi.core的依赖。当然也可以换成其他的OSGi运行时，比如Equinox。&lt;/p&gt;
&lt;p&gt;此时，使用&lt;code&gt;mvn package&lt;/code&gt;生成的jar包中，&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件内已经添加了配置好的bundle信息。&lt;/p&gt;
&lt;p&gt;当然，使用&lt;a href="http://svn.apache.org/repos/asf/felix/releases/maven-bundle-plugin-2.3.7/doc/site/index.html"&gt;maven-bundle-plugin的目标(Goals)&lt;/a&gt;
可以进行更细致的控制。&lt;/p&gt;
&lt;h1&gt;在Eclipse中运行和调试&lt;/h1&gt;
&lt;p&gt;本来，传说中的&lt;a href="http://wiki.ops4j.org/confluence/display/ops4j/Pax%20Cursor"&gt;Pax Cursor&lt;/a&gt;可以在Eclipse中基于各种OSGi runtime运行和调试bundle，但是天朝的网络中似乎不存在&lt;code&gt;ops4j.org&lt;/code&gt;这个域名。&lt;/p&gt;
&lt;p&gt;好在我们可用一个Java Project的方式建立起Felix的环境，通过Eclipse对bundle进行运行和调试。
由于&lt;a href="http://felix.apache.org/site/integrating-felix-with-eclipse.html"&gt;这里&lt;/a&gt;有非常详细的说明，故不再赘述。&lt;/p&gt;
&lt;p&gt;其实，我们还可以基于maven构建，而不是使用Java Project的方式。使用maven的好处是这种方法可以用于任何支持maven的IDE。&lt;/p&gt;
&lt;p&gt;Felix runtime的主要内容包括：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/fuse/felix-tree.png"&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bin/felix.jar  启动的jar, MainClass是&lt;code&gt;org.apache.felix.main.Main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;bundle/   存放可用的bundle，Felix runtime中内置了4个必需的bundle&lt;/li&gt;
&lt;li&gt;conf/conf.properties 启动配置。类似于Eclipse的&lt;code&gt;configuration/config.ini&lt;/code&gt;。Felix配置项可以参考&lt;a href="http://felix.apache.org/site/apache-felix-framework-configuration-properties.html"&gt;官方网站中的内容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;知道了Felix runtime的构成，就可以用maven构建出相同的结构，并插入到项目周期的适当位置。pom如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;project&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;thinkinside.demo.fuse&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;felix-launcher&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Felix Launcher&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;felix.bundlerepository.version&amp;gt;&lt;/span&gt;1.6.4&lt;span class="nt"&gt;&amp;lt;/felix.bundlerepository.version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;felix.gogo.version&amp;gt;&lt;/span&gt;0.10.0&lt;span class="nt"&gt;&amp;lt;/felix.gogo.version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;felix.framework.version&amp;gt;&lt;/span&gt;4.2.1&lt;span class="nt"&gt;&amp;lt;/felix.framework.version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;

    &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-clean-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.4.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;filesets&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;fileset&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;bundle&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;/fileset&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;/filesets&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;

            &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-dependency-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;copy&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;phase&amp;gt;&lt;/span&gt;generate-resources&lt;span class="nt"&gt;&amp;lt;/phase&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;copy&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;artifactItems&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;artifactItem&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.felix&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;org.apache.felix.gogo.command&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;felix&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gogo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;/artifactItem&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;artifactItem&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.felix&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;org.apache.felix.gogo.runtime&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;felix&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gogo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;/artifactItem&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;artifactItem&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.felix&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;org.apache.felix.gogo.shell&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;felix&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gogo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;/artifactItem&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;artifactItem&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.osgi&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;org.osgi.compendium&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;4.2.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;/artifactItem&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;/artifactItems&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;outputDirectory&amp;gt;&lt;/span&gt;bundle&lt;span class="nt"&gt;&amp;lt;/outputDirectory&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;

    &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;

    &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.felix&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;org.apache.felix.main&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;felix&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;framework&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;

        &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.ops4j.pax.url&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;pax-url-assembly&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.6.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该pom在标准的生命周期中增加了两项工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;generate-resources&lt;/code&gt;阶段，创建bundle文件夹，复制必需的4个bundle&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;clean&lt;/code&gt;阶段，清除bundle文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，还需要一个配置文件。在工程目录建立&lt;code&gt;/conf/config.properties&lt;/code&gt;文件，并进行基本配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;felix.auto.deploy.action=install,start
felix.log.level=1

org.osgi.framework.storage.clean=onFirstInit
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置完成了，先执行&lt;code&gt;mvn compile&lt;/code&gt;生成需要的资源。此时使用命令&lt;code&gt;mvn exec:java -Dexec.mainClass="org.apache.felix.main.Main"&lt;/code&gt;即可以启动Felix runtime：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/fuse/felix_launch_from_maven.png"&gt;&lt;/p&gt;
&lt;p&gt;在Eclipse中，将这个工程作为&lt;code&gt;Java Application&lt;/code&gt;运行，选择&lt;code&gt;org.apache.felix.main.Main&lt;/code&gt;作为Main Class，就可以进行运行和调试。&lt;/p&gt;</content><category term="OSGi"></category><category term="java"></category></entry><entry><title>在SWT中用JFreeChart实现K线图</title><link href="http://holbrook.github.io/2014/01/18/swt_jfreechart_candlestick.html" rel="alternate"></link><published>2014-01-18T00:00:00+08:00</published><updated>2014-01-18T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-01-18:/2014/01/18/swt_jfreechart_candlestick.html</id><summary type="html">&lt;h1&gt;目标&lt;/h1&gt;
&lt;p&gt;在&lt;a href="/2013/05/03/r_notes_1_what.html"&gt;R学习笔记&lt;/a&gt;中，展示了这样一张图表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/2013/r_notes/2.png"&gt;&lt;/p&gt;
&lt;p&gt;现在需要在Eclipse e4应用中实现这样的图表。&lt;/p&gt;
&lt;h1&gt;SWT图表组件的选择&lt;/h1&gt;
&lt;p&gt;在RCP/JFace/SWT中，可以选择的图表组件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eclipse BIRT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://www.eclipse.org/birt/phoenix/"&gt;Eclipse BIRT&lt;/a&gt;是Eclipse平台下的报表框架。其中的图表组件可以单独使用。
  由于BIRT依赖于GEF、EMF等Eclipse插件，所以非常重，不适合简单轻量的应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SWT Chart&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从名字就可以看出，&lt;a href="http://www.swtchart.org/"&gt;SWT Chart&lt;/a&gt;是专为SWT环境开发的报表组件。设计很清晰，使用起来也方便。但是目前支持的图表类型比较少。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JFreeChart&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://www.jfree.org/jfreechart/"&gt;JFreeChart&lt;/a&gt;是Java世界的老牌图表组件，其强大无以言表。JFreeChart支持AWT、Swing等
GUI环境，也可以生成图片在Web环境中使用。后来又增加了对SWT环境的支持，从此不再需要SWT_AWT的桥接方式。&lt;/p&gt;
&lt;p&gt;综上所述，这里选择JFreeChart作为绘图组件。&lt;/p&gt;
&lt;h1&gt;获取股票数据&lt;/h1&gt;
&lt;p&gt;由于需要的数据量比较大，不能再使用&lt;a href=""&gt;前面&lt;/a&gt;的模拟数据方法了。这里使用&lt;a href="http://finance.yahoo.com/"&gt;雅虎财经 …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;h1&gt;目标&lt;/h1&gt;
&lt;p&gt;在&lt;a href="/2013/05/03/r_notes_1_what.html"&gt;R学习笔记&lt;/a&gt;中，展示了这样一张图表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/2013/r_notes/2.png"&gt;&lt;/p&gt;
&lt;p&gt;现在需要在Eclipse e4应用中实现这样的图表。&lt;/p&gt;
&lt;h1&gt;SWT图表组件的选择&lt;/h1&gt;
&lt;p&gt;在RCP/JFace/SWT中，可以选择的图表组件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eclipse BIRT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://www.eclipse.org/birt/phoenix/"&gt;Eclipse BIRT&lt;/a&gt;是Eclipse平台下的报表框架。其中的图表组件可以单独使用。
  由于BIRT依赖于GEF、EMF等Eclipse插件，所以非常重，不适合简单轻量的应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SWT Chart&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从名字就可以看出，&lt;a href="http://www.swtchart.org/"&gt;SWT Chart&lt;/a&gt;是专为SWT环境开发的报表组件。设计很清晰，使用起来也方便。但是目前支持的图表类型比较少。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JFreeChart&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://www.jfree.org/jfreechart/"&gt;JFreeChart&lt;/a&gt;是Java世界的老牌图表组件，其强大无以言表。JFreeChart支持AWT、Swing等
GUI环境，也可以生成图片在Web环境中使用。后来又增加了对SWT环境的支持，从此不再需要SWT_AWT的桥接方式。&lt;/p&gt;
&lt;p&gt;综上所述，这里选择JFreeChart作为绘图组件。&lt;/p&gt;
&lt;h1&gt;获取股票数据&lt;/h1&gt;
&lt;p&gt;由于需要的数据量比较大，不能再使用&lt;a href=""&gt;前面&lt;/a&gt;的模拟数据方法了。这里使用&lt;a href="http://finance.yahoo.com/"&gt;雅虎财经&lt;/a&gt;的数据。&lt;/p&gt;
&lt;p&gt;雅虎财经提供了查询股票历史数据的接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  http://table.finance.yahoo.com/table.csv?ignore=.csv&amp;amp;....
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s: 股票代码/名称。对于国内的股票，使用类似&lt;code&gt;000001.ss&lt;/code&gt;的编码&lt;/li&gt;
&lt;li&gt;a、b、c: 开始时间的月、日、年&lt;/li&gt;
&lt;li&gt;d、e、f: 结束时间的月、日、年&lt;/li&gt;
&lt;li&gt;g：时间周期，分别为&lt;code&gt;d&lt;/code&gt;:日， &lt;code&gt;w&lt;/code&gt;:周，&lt;code&gt;m&lt;/code&gt;：月， &lt;code&gt;v&lt;/code&gt;:dividends only&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，月份是从0开始。比如，9月数据写为08。&lt;/p&gt;
&lt;p&gt;本文中使用2013年上证综合指数的日线数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  http://table.finance.yahoo.com/table.csv?ignore=.csv&amp;amp;s=000001.ss&amp;amp;a=00&amp;amp;b=01&amp;amp;c=2013&amp;amp;d=11&amp;amp;e=31&amp;amp;f=2013&amp;amp;g=d
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获取到的CSV文件包含的数据列为&lt;code&gt;Date,Open,High,Low,Close,Volume,Adj Close&lt;/code&gt;，其中Date的格式为&lt;code&gt;yyyy-MM-dd&lt;/code&gt;。数据按照日期倒序排列。&lt;/p&gt;
&lt;p&gt;处理代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;OHLCSeries&lt;/span&gt; &lt;span class="nt"&gt;ohlcSeries&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;new&lt;/span&gt; &lt;span class="nt"&gt;OHLCSeries&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="nt"&gt;TimeSeries&lt;/span&gt; &lt;span class="nt"&gt;volumeSeries&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;new&lt;/span&gt; &lt;span class="nt"&gt;TimeSeries&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="nt"&gt;try&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;URL&lt;/span&gt; &lt;span class="nb"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;http://table.finance.yahoo.com/table.csv?ignore=.csv&amp;amp;s=000001.ss&amp;amp;a=00&amp;amp;b=01&amp;amp;c=2013&amp;amp;d=11&amp;amp;e=31&amp;amp;f=2013&amp;amp;g=d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;InputStream&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;url&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;openStream&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;InputStreamReader&lt;/span&gt; &lt;span class="n"&gt;reader&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;InputStreamReader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;is&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;UTF-8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;BufferedReader&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BufferedReader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reader&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;


        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;newLine&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readLine&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;标题行&lt;/span&gt;


        &lt;span class="n"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;newLine&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readLine&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newLine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trim&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Float&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="nb"&gt;high&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Float&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="nb"&gt;low&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Float&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="n"&gt;close&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Float&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="nb"&gt;volume&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Float&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="n"&gt;adj_close&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Float&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;ohlcSeries&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;high&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;low&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;volumeSeries&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;volume&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;Exception&lt;/span&gt; &lt;span class="nt"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;联合图表&lt;/h1&gt;
&lt;p&gt;目标中的图表是一种联合图表(Combined Chart)：多个图表共用横坐标或纵坐标。JFreeChart中提供了&lt;code&gt;CombinedDomainXYPlot&lt;/code&gt;和&lt;code&gt;CombinedRangeXYPlot&lt;/code&gt;，分别用于联合横坐标和联合纵坐标的图表。&lt;/p&gt;
&lt;p&gt;由于各种图表类型都有可能组成联合图表，JFreeChart没有在&lt;code&gt;ChartFactory&lt;/code&gt;中提供工厂方法进行创建，
只能按照&lt;a href="/2014/01/17/jfreechart.html#menuIndex1"&gt;JFreeChart中的图表模型&lt;/a&gt;进行手工创建。下面是例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  //创建横坐标轴，作为联合坐标
  DateAxis timeAxis = new DateAxis();

  //创建两个纵坐标，用于上下两个Plot
  NumberAxis ohlcAxis = new NumberAxis();
  NumberAxis volumeAxis = new NumberAxis();

  //创建两个Plot对应的Renderer
  CandlestickRenderer ohlcRenderer = new CandlestickRenderer();
  XYBarRenderer volumeRenderer = new XYBarRenderer();

  //创建K线图的Plot，使用“数据”一节中的ohlcSeries
  ////其中横坐标设为&amp;quot;null&amp;quot;，以使用联合横坐标
  OHLCSeriesCollection ohlcDataset = new OHLCSeriesCollection();
  ohlcDataset.addSeries(ohlcSeries);
  XYPlot ohlcPlot = new XYPlot(ohlcDataset,timeAxis,ohlcAxis,ohlcRenderer);

  //创建成交量柱状图的Plot，使用“数据”一节中的volumeSeries
  //其中横坐标设为&amp;quot;null&amp;quot;，以使用联合横坐标
  TimeSeriesCollection volumeDataset = new TimeSeriesCollection();
  volumeDataset.addSeries(timeSeries);
  XYPlot volumePlot=new XYPlot(volumeDataset,null,volumeAxis,volumeRenderer;

  //创建联合图表
  CombinedDomainXYPlot combineddomainxyplot = new CombinedDomainXYPlot(timeAxis());

  //上下两个图表占据的高度比例为2:1，间隔为10
  combineddomainxyplot.add(ohlcPlot, 2);
  combineddomainxyplot.add(volumePlot, 1);
  combineddomainxyplot.setGap(10);
  JFreeChart chart = new JFreeChart(&amp;quot;xx股票&amp;quot;, JFreeChart.DEFAULT_TITLE_FONT, combineddomainxyplot, false);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;创建的图表如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/chart/sample1.png"&gt;&lt;/p&gt;
&lt;h1&gt;设置样式&lt;/h1&gt;
&lt;p&gt;上面的图表默认样式与国内的习惯不大一样。不过JFreeChart提供了丰富的API进行样式的设置。下面对样式进行简单调整(目前对SWT的支持不够完全。比如，颜色值仍需要使用AWT的&lt;code&gt;Color&lt;/code&gt;类)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//图表
chart.setBackgroundPaint(Color.BLACK);
chart.getTitle().setPaint(Color.WHITE);
chart.setBorderVisible(false);

//Plot
combineddomainxyplot.setBackgroundPaint(Color.BLACK);
ohlcPlot.setBackgroundPaint(Color.BLACK);
volumePlot.setBackgroundPaint(Color.BLACK);

//渲染
ohlcRenderer.setUpPaint(Color.RED);
ohlcRenderer.setDownPaint(Color.GREEN);

volumeRenderer.setShadowVisible(false);

//坐标轴
timeAxis.setTickLabelPaint(Color.GRAY);
ohlcAxis.setTickLabelPaint(Color.GRAY);
volumeAxis.setTickLabelPaint(Color.GRAY);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调整后的图表如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/chart/sample2.png"&gt;&lt;/p&gt;
&lt;h1&gt;去除非交易时段&lt;/h1&gt;
&lt;p&gt;前面的例子中，K线是不连续的，因为会有非交易日的存在。如果是小时、分钟级别的K线图，该问题会更加明显。&lt;/p&gt;
&lt;p&gt;要去除非交易时段，使得K线连续，大体有两个思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现一个自定义的&lt;code&gt;DateAxis&lt;/code&gt;，根据数据的序号产生坐标，根据实际时间产生标签&lt;/li&gt;
&lt;li&gt;实现一个&lt;code&gt;Timeline&lt;/code&gt;，并设置给&lt;code&gt;DateAxis&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更改Renderer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看起来方法1更容易，但由于没有相关的文档，需要自己分析&lt;code&gt;DateAxis&lt;/code&gt;的代码，类似一种“Hack”的模式，很难保证向后兼容；
方法2是官方指定的方法，可行性更高，但是要同时支持日线、小时线、分钟/5分钟线，实现起来有点难度。
此外，&lt;a href="http://www.jfree.org/jfreechart/api/javadoc/org/jfree/chart/axis/Timeline.html"&gt;Timeline的接口说明&lt;/a&gt;读起来有些费解；方法3需要改变数据源(Dataset)，使用序号作为数据，设置Renderer的&lt;code&gt;ItemLabelGenerator&lt;/code&gt;，根据序号产生时间格式的坐标标签。&lt;/p&gt;
&lt;p&gt;这里采用方法3，实例代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//TODO
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;修正高度和宽度(TODO)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;固定每根K线的宽度，根据图表宽度决定显示多少根K线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用“时间窗口”作为数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;横向滚动和实时曲线(TODO)&lt;/h1&gt;</content><category term="图表"></category><category term="GUI"></category><category term="java"></category></entry><entry><title>Eclipse e4：从OSGi-DS到依赖注入</title><link href="http://holbrook.github.io/2014/01/12/dependency_injection_in_e4.html" rel="alternate"></link><published>2014-01-12T00:00:00+08:00</published><updated>2014-01-12T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-01-12:/2014/01/12/dependency_injection_in_e4.html</id><summary type="html">&lt;p&gt;e4开始，可以不使用代码或xml进行服务注册和寻找，而使用依赖注入进行装配&lt;/p&gt;</summary><content type="html">&lt;h1&gt;MANIFEST.MF&lt;/h1&gt;
&lt;p&gt;为了管理一组Java类和资源，通常我们会将其打包为JAR(Java Archive File，java存档文件)，该文件以ZIP格式进行打包。
在JAR文件中，会包含一个&lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt;文件，作为该JAR包的清单文件，设置执行入口类和支持库的路径等信息。
主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Manifest-Version&lt;/li&gt;
&lt;li&gt;Class-Path&lt;/li&gt;
&lt;li&gt;Created-By&lt;/li&gt;
&lt;li&gt;Main-Class&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;OSGi bundle&lt;/h1&gt;
&lt;p&gt;OSGi的目标是实现Java应用的模块化，其目标是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将程序封装成一个个的模块(在OSGi中叫做bundle)&lt;/li&gt;
&lt;li&gt;模块向外只暴露特定的接口，内部实现对外不可见&lt;/li&gt;
&lt;li&gt;OSGi容器管理模块的接口，包括服务发布、寻找和版本管理等&lt;/li&gt;
&lt;li&gt;OSGi容器管理模块的生命周期，比如启动、停止、热插拔等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OSGi将每个模块打包为一个JAR文件。为了实现上述目标，
OSGi规范利用了&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件，在其中增加了一些bundle的描述信息，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bundle-ManifestVersion&lt;/li&gt;
&lt;li&gt;Bundle-Name&lt;/li&gt;
&lt;li&gt;Bundle-SymbolicName&lt;/li&gt;
&lt;li&gt;Bundle-Version&lt;/li&gt;
&lt;li&gt;Bundle-ClassPath&lt;/li&gt;
&lt;li&gt;Bundle-Vendor&lt;/li&gt;
&lt;li&gt;Bundle-Localization&lt;/li&gt;
&lt;li&gt;Bundle-RequiredExecutionEnvironment&lt;/li&gt;
&lt;li&gt;Export-Package&lt;/li&gt;
&lt;li&gt;Require-Bundle&lt;/li&gt;
&lt;li&gt;Bundle-Activator&lt;/li&gt;
&lt;li&gt;Bundle-ActivationPolicy&lt;/li&gt;
&lt;li&gt;Import-Package&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;OSGi服务的注册和寻找&lt;/h1&gt;
&lt;p&gt;OSGi模块中，只有&lt;code&gt;Export-Package&lt;/code&gt;中声明的包才可以被其他模块访问。为了避免一个模块对其他模块的直接引用，
通常会实现一个“接口定义”模块和多个“接口实现”模块。通过服务注册和发现的方式进行服务的使用。&lt;/p&gt;
&lt;p&gt;OSGi还可以为模块指定一个"激活类(&lt;code&gt;Bundle-Activator&lt;/code&gt;)“，
这个类会在模块启动时被执行，通常在这里进行本模块的接口实现(服务)的发布，以及向本模块内的类注入其他模块实现的接口(服务).
比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class MyActivator implements org.osgi.framework.BundleActivator{

    @Override
    public void start(BundleContext context) throws Exception {
        context.registerService(MyService.class.getName(), new MyServiceImpl(), null);
        System.out.println(MyService.class.getName() + &amp;quot; has been registred as a service&amp;quot;);
    }
    ……
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，其他使用该服务的模块可以寻找服务。通常，也是在"激活类(&lt;code&gt;Bundle-Activator&lt;/code&gt;)“中进行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class ClientActivator implements BundleActivator{
    public static MyService helloService;

    @Override
    public void start(BundleContext context) throws Exception {
        ServiceReference ref = context.getServiceReference(MyService.class.getName());
        MyService service = (MyService) context.getService(ref);
        MyClient.setService(service);
    }
    ……
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Declarative Service&lt;/h1&gt;
&lt;p&gt;上面通过代码的方式进行服务的注册和寻找，实现起来比较繁琐。为了简化编码，从OSGi4.0版本开始，提出了”Declarative Service“标准，
使用xml文件进行服务发布和引用的描述。&lt;/p&gt;
&lt;p&gt;首先，在&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件中增加一个新的属性&lt;code&gt;Service-Component&lt;/code&gt;，用来指定服务声明文件的路径，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Service-Component: OSGI-INF/component.xml
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后编写服务声明配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;scr:component&lt;/span&gt; &lt;span class="na"&gt;xmlns:scr=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.osgi.org/xmlns/scr/v1.1.0&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myservice&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;implementation&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;MyServiceImpl&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;service&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;provide&lt;/span&gt; &lt;span class="na"&gt;interface=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;MyService&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/service&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/component&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该文件中也可以配置服务引用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &amp;lt;reference bind=&amp;quot;setMyService&amp;quot; cardinality=&amp;quot;1..1&amp;quot; interface=&amp;quot;MyService&amp;quot; name=&amp;quot;myservice&amp;quot; policy=&amp;quot;static&amp;quot; unbind=&amp;quot;unsetMyService&amp;quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以用如下的代码使用所引用的服务：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// Method will be used by DS to set the service
  public synchronized void setMyService(MyService service) {
    System.out.println(&amp;quot;Service was set. Thank you DS!&amp;quot;);
    this.service = service;
  }

  // Method will be used by DS to unset the service
  public synchronized void unsetMyService(MyService service) {
    System.out.println(&amp;quot;Service was unset.&amp;quot;);
    if (this.service == service) {
      this.service = null;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;e4中的依赖注入&lt;/h1&gt;
&lt;p&gt;Declarative Service的方式与Spring的服务组装很类似。但是Spring中已经开始&lt;a href="/2014/01/05/spring_annotations.html"&gt;使用注解代替繁琐的XML配置&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;从Eclipse e4开始，已经支持使用&lt;a href="/2013/12/31/jsr330.html"&gt;JSR330:依赖注入规范&lt;/a&gt;实现服务的注入。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_inject.png"&gt;&lt;/p&gt;
&lt;p&gt;在e4增加的服务编程模型中，引入了上下文（context），所有的依赖对象都被上下文管理并通过上下文获取：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_context.png"&gt;&lt;/p&gt;
&lt;p&gt;在Eclipse e4中，将全局的上下文分成了多个层次：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_context_hierarchy.png"&gt;&lt;/p&gt;
&lt;p&gt;下层的context可以获取上层context中定义的对象，比如：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_context_hierarchy_example.png"&gt;&lt;/p&gt;
&lt;p&gt;e4中，可以使用&lt;a href="/2013/12/31/jsr330.html#menuIndex3"&gt;JSR330中基本的&lt;code&gt;@Inject&lt;/code&gt;、&lt;code&gt;@Named&lt;/code&gt;等注解&lt;/a&gt;,用于构造器、方法和属性。同时,e4在&lt;code&gt;org.eclipse.e4.core.di.annotations&lt;/code&gt;包中也定义了一些扩展的注解，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Optional&lt;/code&gt;：声明一个注入(&lt;code&gt;@Inject&lt;/code&gt;)为可选&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@GroupUpdates&lt;/code&gt;：声明一个注入的对象是批量更新的，使用这个注解对于RCP应用的性能有很大好处&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Execute&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@CanExecute&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Creatable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是e4中依赖注入的一些例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// Tracks the active part
@Inject
@Optional
public void receiveActivePart(@Named(IServiceConstants.ACTIVE_PART) MPart activePart) {
  if (activePart != null) {
  System.out.println(&amp;quot;Active part changed &amp;quot;
    + activePart.getLabel());
  }
}


// tracks the active shell
@Inject
@Optional
public void receiveActiveShell(@Named(IServiceConstants.ACTIVE_SHELL) Shell shell) {
  if (shell != null) {
    System.out.println(&amp;quot;Active shell (Window) changed&amp;quot;);
  }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;org.eclipse.e4.core.contexts&lt;/code&gt;包中定义的&lt;code&gt;@Active&lt;/code&gt;注解可以获取活动(actived)组件。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class MyOwnClass {
  @Inject
  void setChildValue(@Optional @Named(&amp;quot;key_of_child_value&amp;quot;) @Active String value) {
    this.childValue = value;
  }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;创建自己的可注入对象&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;@Creatable&lt;/code&gt;&lt;/p&gt;</content><category term="OSGi"></category><category term="java"></category><category term="GUI"></category></entry><entry><title>Eclipse e4中的平台服务</title><link href="http://holbrook.github.io/2014/01/12/e4_platform_services.html" rel="alternate"></link><published>2014-01-12T00:00:00+08:00</published><updated>2014-01-12T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-01-12:/2014/01/12/e4_platform_services.html</id><summary type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;a href="/2014/01/12/dependency_injection_in_e4.html"&gt;前面&lt;/a&gt;提到，e4中可以通过依赖注入进行服务的发布和获取。并且，”在Eclipse e4中，将全局的上下文分成了多个层次“：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_context_hierarchy.png"&gt;&lt;/p&gt;
&lt;p&gt;e4提供了很多平台级的服务，注册于OSGi context之上的其他各个context层。这些服务提供了开发应用的很多通用的功能。一些常用的服务包括：&lt;/p&gt;
&lt;p&gt;展现层MVC的视图、模型、控制器相关的服务，以及逻辑层服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;视图相关服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EPartService&lt;/p&gt;
&lt;p&gt;访问和修改Part，使用Part模板，切换perspectives，支持Edit方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ESelectionService&lt;/p&gt;
&lt;p&gt;处理GUI界面中的”选中“&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EMenuService&lt;/p&gt;
&lt;p&gt;Registers a popup menu (MPopupMenu) for an SWT control.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;org.eclipse.jface.window.IShellProvider&lt;/p&gt;
&lt;p&gt;在SWT环境中访问Shell&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IThemeEngine&lt;/p&gt;
&lt;p&gt;Allows to switch the styling of the …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;a href="/2014/01/12/dependency_injection_in_e4.html"&gt;前面&lt;/a&gt;提到，e4中可以通过依赖注入进行服务的发布和获取。并且，”在Eclipse e4中，将全局的上下文分成了多个层次“：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_context_hierarchy.png"&gt;&lt;/p&gt;
&lt;p&gt;e4提供了很多平台级的服务，注册于OSGi context之上的其他各个context层。这些服务提供了开发应用的很多通用的功能。一些常用的服务包括：&lt;/p&gt;
&lt;p&gt;展现层MVC的视图、模型、控制器相关的服务，以及逻辑层服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;视图相关服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EPartService&lt;/p&gt;
&lt;p&gt;访问和修改Part，使用Part模板，切换perspectives，支持Edit方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ESelectionService&lt;/p&gt;
&lt;p&gt;处理GUI界面中的”选中“&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EMenuService&lt;/p&gt;
&lt;p&gt;Registers a popup menu (MPopupMenu) for an SWT control.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;org.eclipse.jface.window.IShellProvider&lt;/p&gt;
&lt;p&gt;在SWT环境中访问Shell&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IThemeEngine&lt;/p&gt;
&lt;p&gt;Allows to switch the styling of the application at runtime.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模型相关服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EModelService&lt;/p&gt;
&lt;p&gt;在运行时访问或更改e4的&lt;a href="/2014/01/07/eclipse_e4_RCP_quickstart.html#menuIndex1"&gt;应用模型&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制器相关服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MDirtyable&lt;/p&gt;
&lt;p&gt;用于标记Part中的内容是否被修改过&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ECommandService&lt;/p&gt;
&lt;p&gt;访问、创建和更改应用模型中的command对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EHandlerService&lt;/p&gt;
&lt;p&gt;访问、更改或触发(trigger)应用模型中的handler对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑层相关服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IEventBroker&lt;/p&gt;
&lt;p&gt;提供基于发布、订阅机制的事件处理功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;StatusReporter&lt;/p&gt;
&lt;p&gt;Allows you to report Status objects.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EContextService&lt;/p&gt;
&lt;p&gt;Activate and deactivate key bindings defined as BindingContext in the application model. The content referred to in this service is the BindingContext and not the IEclipseContext.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Logger&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.eclipse.e4.core.services&lt;/code&gt;插件中的&lt;code&gt;Logger&lt;/code&gt;提供了日志功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Adapter&lt;/p&gt;
&lt;p&gt;An adapter can adapt an object to the specified type, allowing clients to request domain-specific behavior for an object. It integrates IAdaptable and IAdapterManager&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;视图相关服务&lt;/h1&gt;
&lt;h2&gt;EPartService&lt;/h2&gt;
&lt;p&gt;在应用模型中，可以定义PartDescriptors。PartDescriptors可以作为创建Part的模板。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/PartDescriptors.png"&gt;&lt;/p&gt;
&lt;p&gt;通过EPartService可以访问这些模板，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  @Inject private EPartService partService;

  // Showing and hiding parts
  detailsTodoPart = partService.findPart(&amp;quot;com.example.todo.rcp.parts.tododetails&amp;quot;);
  partService.hidePart(detailsTodoPart);
  ……
  detailsTodoPart.setVisible(true);
  partService.showPart(detailsTodoPart, PartState.VISIBLE);

  //Switching perspectives
  @Execute
    public void execute(MApplication app, EPartService partService,
        EModelService modelService) {
      MPerspective element =
          (MPerspective) modelService.find(&amp;quot;secondperspective&amp;quot;, app);
      // now switch perspective
      partService.switchPerspective(element);
    }


  // creating parts dynamically
  @Execute
    public void execute(EPartService partService) {

      // create a new Part based on a PartDescriptor
      // in the application model
      // assume the ID is used for the PartDescriptor
      MPart part = partService
          .createPart(&amp;quot;com.example.e4.rcp.todo.partdescriptor.fileeditor&amp;quot;);
      part.setLabel(&amp;quot;New Dynamic Part&amp;quot;);

      // If multiple parts of this type are now allowed
      // in the application model,
      // then the provided part will be shown
      // and returned
      partService.showPart(part, PartState.ACTIVATE);
    }

  //switch perspective
  @Execute
    public void execute(MApplication app, EPartService partService,
        EModelService modelService) {
      MPerspective element =
          (MPerspective) modelService.find(&amp;quot;secondperspective&amp;quot;, app);
      partService.switchPerspective(element);
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;ESelectionService&lt;/h2&gt;
&lt;p&gt;e4的应用模型中，MWindow对象可以保持选中的Part。e4在IEclipseContext中注册了&lt;code&gt;ESelectionService&lt;/code&gt;，可以设置或获取选中的组件。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;setSelection()&lt;/code&gt;方法可以设置选中状态：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  // use field injection for the service
  @Inject ESelectionService selectionService;

  // viewer is a JFace Viewer
  viewer.addSelectionChangedListener(new ISelectionChangedListener() {
    @Override
    public void selectionChanged(SelectionChangedEvent event) {
      IStructuredSelection selection = (IStructuredSelection)
          viewer.getSelection();
      selectionService.setSelection(selection.getFirstElement());
    }
  });
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用&lt;code&gt;getSelection(partId)&lt;/code&gt;方法可以获取选中的组件，更常用的做法是使用&lt;code&gt;IServiceConstants.ACTIVE_SELECTION&lt;/code&gt;作为&lt;code&gt;@Named&lt;/code&gt;注解的参数，自动注入选中的组件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  @Inject
  public void setTodo(@Optional
      @Named(IServiceConstants.ACTIVE_SELECTION) Todo todo) {
    if (todo != null) {
      // do something with the value
    }
  }
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;模型相关服务EModelService&lt;/h1&gt;
&lt;p&gt;使用&lt;code&gt;EModelService&lt;/code&gt;可以在运行时访问或更改e4的&lt;a href="/2014/01/07/eclipse_e4_RCP_quickstart.html#menuIndex1"&gt;应用模型&lt;/a&gt;，比如增加或删除模型元素。EModelService中一些常用的方法包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cloneElement()&lt;/code&gt;和&lt;code&gt;cloneSnippet()&lt;/code&gt;：克隆元素或模型片段&lt;/li&gt;
&lt;li&gt;&lt;code&gt;findElements()&lt;/code&gt;：通过ID、类型、或标签(tags)搜索元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用举例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  //search by type
    private void findParts(MApplication application,
        EModelService service) {
      List&amp;lt;MPart&amp;gt; parts = service.findElements(application, null,
          MPart.class, null);
      System.out.println(&amp;quot;Found parts(s) : &amp;quot; + parts.size());

    }

  //Dynamically create a new window
  MWindow window = modelService.createModelElement(MWindow.class);
  window.setWidth(200);
  window.setHeight(300);

  // add new Window to the application
  application.getChildren().add(window);
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;控制器相关服务&lt;/h1&gt;
&lt;h2&gt;MDirtyable和@Persist注解&lt;/h2&gt;
&lt;p&gt;e4中不再区分ViewPart和EditPart，而是统一使用Part。通过MDirtyable可以标记Part中的内容是否被修改过；使用&lt;code&gt;@Persist&lt;/code&gt;注解可以标记持久化Part内容的方法。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  public class MyEditPart {

    @Inject
    MDirtyable dirty;

    @PostConstruct
    public void createControls(Composite parent) {
      Button button = new Button(parent, SWT.PUSH);
      button.addSelectionListener(new SelectionAdapter() {
        @Override
        public void widgetSelected(SelectionEvent e) {
          dirty.setDirty(true);
        }
      });
    }

    @Persist
    public void save(MDirtyable dirty, ITodoService todoService) {
      // save changes via ITodoService for example
      todoService.saveTodo(todo);
      // save was successful
      dirty.setDirty(false);
    }
  }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在上面的例子中，看起来&lt;code&gt;@Persist&lt;/code&gt;注解没有多大用处。其实，该注解主要用于EPartService的&lt;code&gt;saveAll()&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  public class SaveHandler {

    @Execute
    void execute(EPartService partService) {
      partService.saveAll(false);
    }
  }
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;ECommandService和EHandlerService&lt;/h2&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  Command command = commandService.getCommand(&amp;quot;com.example.mycommand&amp;quot;);

  // check if the command is defined
  System.out.println(command.isDefined());

  // activate Handler, assume AboutHandler() class exists already
  handlerService.activateHandler(&amp;quot;com.example.mycommand&amp;quot;,
      new AboutHandler());

  ParameterizedCommand cmd =
    commandService.createCommand(&amp;quot;com.example.mycommand&amp;quot;, null);

  // check if the command can get executed
  System.out.println(handlerService.canExecute(cmd));

  // execute the command
  handlerService.executeHandler(cmd);
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;逻辑层相关服务&lt;/h1&gt;
&lt;h2&gt;IEventBroker&lt;/h2&gt;
&lt;p&gt;Eclipse 3.x中，事件处理使用Observer模式：事件接收者实现事件发布者指定的Listener接口，并注册到事件发布者。
这带来两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个Listener接口要写很多个实现，这些实现中的代码有重复&lt;/li&gt;
&lt;li&gt;事件发布者和接收者的生命周期紧耦合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Eclipse e4中，将OSGi的&lt;code&gt;EventAdmin&lt;/code&gt;API封装为事件服务，提供了基于发布、订阅机制的事件处理功能：&lt;code&gt;EventBroker&lt;/code&gt;作为事件总线，通过&lt;code&gt;EventBroker&lt;/code&gt;可以发布和订阅事件。&lt;/p&gt;
&lt;p&gt;要使用e4事件服务，需要增加依赖插件：
    * org.eclipse.e4.core.services
    * org.eclipse.osgi.services&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取EventBroker&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;e4中定义了&lt;code&gt;org.eclipse.e4.core.services.events.IEventBroker&lt;/code&gt;接口，可以通过依赖注入、e4上下文等方式获取：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  @Inject
  IEventBroker eventBroker;

  @Inject
  private IEclipseContext eclipseContext;
  ……
  IEventBroker eventBroker = eclipseContext.get(IEventBroker.class);

- 发布事件

可以用`IEventBroker`的`post()`或`send()`方法，进行同步(synchronous)或异步(asynchronous)事件的发布：
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;boolean IEventBroker.post(String topic, Object data) // synchronous delivery&lt;/p&gt;
&lt;p&gt;boolean IEventBroker.send(String topic, Object data) // asynchronous delivery&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;返回值为是否发生成功。


- 订阅事件

可以通过依赖注入或者`IEventBroker`的`subscribe()`方法订阅事件：
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;@Inject
  @Optional
  private void closeHandler(@UIEventTopic(''TOPIC_STRING'') foo.Bar payload) {
    //do something with payload
  }&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;@Inject
  IEventBroker eventBroker;&lt;/p&gt;
&lt;p&gt;org.osgi.service.event.EventHandler closeHandler = new EventHandler() {
    public void handleEvent(Event event) {
        foo.Bar payload = (foo.Bar) event.getProperty(IEventBroker.DATA);
    }
  }&lt;/p&gt;
&lt;p&gt;eventBroker.subscribe(TOPIC_STRING, closeHandler);
  ……
  eventBroker.unsubscribe(closeHandler);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;消息对象(payload)作为附件存储在`IEventBroker.DATA`属性中。对于`Dictionary`或`Map`等集合类型的消息，会将其中所有的值按照KEY添加为属性。

## Logger

Eclipse 3.x中，Log的接口和实现类分别为`org.eclipse.core.runtime.ILog`和`org.osgi.service.log.LogService`，可以使用`ServiceTracker`获取：
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;LogService getLog() {
  fLogServiceTracker = new ServiceTracker(fBundleContext, LogService.class.getName(), null);
  return (LogService) fLogServiceTracker.getService();
}&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;为了方便，在`Plugin`的基类中实现了`getLog()`方法，所有的`Plugin`子类可以直接使用。

在`org.eclipse.e4.core.services`插件中提供了`org.eclipse.e4.core.services.Logger`类，可以通过`@Inject`注解或使用`IEclipseContext`接口获取：
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;@Inject
private Logger logger;&lt;/p&gt;
&lt;p&gt;//or use code:
Logger log = (Logger) context.get(Logger.class.getName());&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;h1&gt;实现自己的服务&lt;/h1&gt;
&lt;p&gt;Usually services have two parts: the interface definition and the implementation. How these two are linked is defined by a context function , an OSGi service or plain context value setting (IEclipseContext). Please note that there can be more than one service implementation for an interface.&lt;/p&gt;</content><category term="OSGi"></category><category term="java"></category><category term="GUI"></category></entry><entry><title>Tycho：用Maven构建Eclipse Plugin项目</title><link href="http://holbrook.github.io/2014/01/08/build_osgi_bundle_with_tycho_maven_plugin.html" rel="alternate"></link><published>2014-01-08T00:00:00+08:00</published><updated>2014-01-08T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-01-08:/2014/01/08/build_osgi_bundle_with_tycho_maven_plugin.html</id><summary type="html">&lt;p&gt;Tycho以一组maven插件的形式，支持Eclipse的plug-ins, features, update sites (based on p2) 、products等类型工程的构建。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://www.sonatype.org/tycho"&gt;Tycho&lt;/a&gt;是一个Maven插件，目标是使用Maven构建Eclipse插件，OSGI Bundle等工程。&lt;/p&gt;
&lt;p&gt;如果说&lt;a href="http://maven.apache.org/"&gt;Maven&lt;/a&gt;的出现是一群Java程序员受不了繁琐的插件依赖管理，受不了冗长的ant build.xml文件而创造出来的，
那Tycho则是一群Eclipse、OSGi插件开发人员受不了重复地配置类似的Maven pom.xml而创造出来的。&lt;/p&gt;
&lt;p&gt;Tycho以一组maven插件的形式，支持Eclipse的plug-ins, features, update sites (based on p2) 、products等类型的工程，
表现为不同的maven打包类型(packaging):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eclipse-plugin&lt;/li&gt;
&lt;li&gt;eclipse-feature&lt;/li&gt;
&lt;li&gt;eclipse-test-plugin&lt;/li&gt;
&lt;li&gt;eclipse-repository&lt;/li&gt;
&lt;li&gt;eclipse-target-definition&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;父工程&lt;/h1&gt;
&lt;p&gt;基于OSGi的工程通常会划分很多模块，对于Maven来说，一般通过一个父工程（parent）来管理所有模块的构建。父工程的&lt;code&gt;packaging&lt;/code&gt;类型为&lt;code&gt;pom&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;为了使用Tycho，需要在父工程的pom文件中增加一些配置。&lt;/p&gt;
&lt;h2&gt;增加Tycho插件&lt;/h2&gt;
&lt;p&gt;父工程中定义的插件可以在所有子工程中使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="nt"&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;tycho&lt;/span&gt;&lt;span class="err"&gt;-version&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;0.16.0&lt;span class="nt"&gt;&amp;lt;/tycho-version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;

  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.eclipse.tycho&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;tycho-maven-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;tycho&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;extensions&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/extensions&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;定义bundle仓库&lt;/h2&gt;
&lt;p&gt;比如，基于Eclipse 4.3(Kepler)的RCP应用，使用了Texo、GeminiJPA等插件，需要如下的仓库定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="nt"&gt;&amp;lt;repositories&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;Kepler&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://download.eclipse.org/releases/kepler&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;layout&amp;gt;&lt;/span&gt;p2&lt;span class="nt"&gt;&amp;lt;/layout&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;Texo&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://download.eclipse.org/modeling/emft/texo/updates/interim&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;layout&amp;gt;&lt;/span&gt;p2&lt;span class="nt"&gt;&amp;lt;/layout&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;GeminiJPA&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://download.eclipse.org/gemini/jpa/updates&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;layout&amp;gt;&lt;/span&gt;p2&lt;span class="nt"&gt;&amp;lt;/layout&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;EclipseLink&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://download.eclipse.org/rt/eclipselink/updates/&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;layout&amp;gt;&lt;/span&gt;p2&lt;span class="nt"&gt;&amp;lt;/layout&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/repositories&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;定义目标&lt;/h2&gt;
&lt;p&gt;定义不同的目标平台：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.eclipse.tycho&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;target-platform-configuration&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;environments&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;environment&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;os&amp;gt;&lt;/span&gt;linux&lt;span class="nt"&gt;&amp;lt;/os&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;ws&amp;gt;&lt;/span&gt;gtk&lt;span class="nt"&gt;&amp;lt;/ws&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;arch&amp;gt;&lt;/span&gt;x86&lt;span class="nt"&gt;&amp;lt;/arch&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;environment&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;os&amp;gt;&lt;/span&gt;macosx&lt;span class="nt"&gt;&amp;lt;/os&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;ws&amp;gt;&lt;/span&gt;cocoa&lt;span class="nt"&gt;&amp;lt;/ws&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;arch&amp;gt;&lt;/span&gt;x86_64&lt;span class="nt"&gt;&amp;lt;/arch&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/environments&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果要发布比较复杂的目标，比如Eclipse Product的发布，需要单独构建&lt;code&gt;eclipse-target-definition&lt;/code&gt;类型的子工程。&lt;/p&gt;
&lt;h1&gt;为现有工程生成pom&lt;/h1&gt;
&lt;p&gt;Tycho提供了一个工具，可以为现有的Eclipse Plugin、Feature等工程生成pom文件，从而将其整合到Tycho的管理之下。&lt;/p&gt;
&lt;p&gt;该工具也是基于maven的，只需要在工程文件夹执行命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    mvn org.eclipse.tycho:tycho-pomgenerator-plugin:generate-poms -DgroupId=thinkinside.tangle
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;生成的pom文件举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;project&lt;/span&gt; &lt;span class="na"&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;  http://maven.apache.org/POM/4.0.0&amp;quot;&lt;/span&gt;
      &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;thinkinside.tangle&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;tangle-app&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;eclipse-plugin&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于种种原因，Eclipse Plugin工程的配置内容分散在多个文件中，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OSGi的配置文件：MANIFEST.MF&lt;/li&gt;
&lt;li&gt;插件工程构建文件：build.properties&lt;/li&gt;
&lt;li&gt;插件定义文件：plugin.xml&lt;/li&gt;
&lt;li&gt;产品描述文件：.product&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些文件中的配置项有重复，开发人员要保证各文件中的相关配置的一致性。&lt;/p&gt;
&lt;p&gt;Tycho在生成pom文件时，会检查这些配置文件，将其中的配置项写入pom文件中。&lt;/p&gt;
&lt;p&gt;Tycho的逻辑是以上述标准的配置文件优先。比如，在pom文件中没有定义依赖关系，而是以&lt;code&gt;MANIFEST.MF&lt;/code&gt;中定义的依赖为准。&lt;/p&gt;
&lt;p&gt;如果现有工程已经有了pom文件，还可以使用Tycho进行更新：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  mvn org.eclipse.tycho:tycho-versions-plugin:update-pom -Dtycho.mode=maven
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;"目标定义"子工程&lt;/h1&gt;
&lt;p&gt;前面提到，如果要发布比较复杂的目标，比如Eclipse Product的发布，需要单独构建&lt;code&gt;eclipse-target-definition&lt;/code&gt;类型的子工程。&lt;/p&gt;
&lt;p&gt;在"目标定义"子工程中创建&lt;code&gt;.product&lt;/code&gt;文件，然后在pom文件中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.eclipse.tycho&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;tycho-p2-director-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;tycho&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
            &lt;span class="c"&gt;&amp;lt;!-- install the product for all configured os/ws/arch environments&lt;/span&gt;
&lt;span class="c"&gt;              using p2 director --&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;materialize-products&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;materialize-products&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
          &lt;span class="c"&gt;&amp;lt;!-- (optional) create product zips (one per os/ws/arch) --&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;archive-products&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;archive-products&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;



        &lt;span class="nt"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;"目标定义"子工程中还可以使用”目标定义文件（Target Definition, *.target）“进行复杂的配置。
可以参考&lt;a href="http://wiki.eclipse.org/Tycho/Target_Platform"&gt;这里&lt;/a&gt;的说明，也可以查看&lt;a href="https://github.com/toedter/e4-tutorial"&gt;GitHub上的例子&lt;/a&gt;的例子。&lt;/p&gt;
&lt;h1&gt;Test工程&lt;/h1&gt;
&lt;p&gt;与专门的测试工具&lt;a href=""&gt;Pax Exam&lt;/a&gt;相比，Tycho test使用起来会更简单。当然前提是测试由Tycho构建的OSGi应用。&lt;/p&gt;
&lt;p&gt;Tycho将一个"Fragment"工程包装成Maven工程，可以在其中编写测试代码，然后使用"JUnit Plug-in Test"执行测试。&lt;/p&gt;
&lt;h1&gt;对比Maven-Bundle-Plugin&lt;/h1&gt;
&lt;p&gt;Maven-Bundle-Plugin提供了与Tycho不同风格的另一种构建OSGi的maven插件。关于二者的对比，可以参考&lt;a href="/2014/01/21/tycho_vs_maven_bundle_plugin.html"&gt;这里&lt;/a&gt;&lt;/p&gt;</content><category term="OSGi"></category><category term="java"></category><category term="GUI"></category></entry><entry><title>Eclipse e4 概览</title><link href="http://holbrook.github.io/2014/01/07/eclipse_e4_RCP_quickstart.html" rel="alternate"></link><published>2014-01-07T00:00:00+08:00</published><updated>2014-01-07T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2014-01-07:/2014/01/07/eclipse_e4_RCP_quickstart.html</id><summary type="html">&lt;p&gt;尽管至今为止，仍然处于孵化器阶段(Incubation Phase)，但是e4代表了Eclipse的未来。e4提供的新特性包括：&lt;/p&gt;</summary><content type="html">&lt;p&gt;基于EMF的应用模型(Application Model)；依赖注入；基于CSS定义外观&lt;/p&gt;
&lt;p&gt;尽管至今为止，&lt;a href="http://www.eclipse.org/e4/"&gt;Eclipse e4&lt;/a&gt;仍然处于孵化器阶段(Incubation Phase)，但是e4代表了Eclipse的未来。&lt;/p&gt;
&lt;p&gt;e4是位于底层的Equinox、EMF、SWT/JFace和上层的Eclipse应用(Plugin、RCP、RAP等)之间的一个应用开发平台。
从RCP的角度来说，e4的一个主要目标就是更轻松地编写和重用组件。
为了实现这个目标，与之前的Eclipse平台相比，e4带来的新特性主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于EMF的应用模型(Application Model)&lt;/li&gt;
&lt;li&gt;依赖注入&lt;/li&gt;
&lt;li&gt;基于CSS定义外观&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;快速开始&lt;/h1&gt;
&lt;p&gt;需要的环境和工具包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java &amp;gt;= 1.7&lt;/li&gt;
&lt;li&gt;Eclipse &amp;gt;= 4.3&lt;/li&gt;
&lt;li&gt;&lt;a href="https://marketplace.eclipse.org/content/enide-eclipse-boostrap-e4"&gt;Enide - Eclipse bootstrap e4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.eclipse.org/windowbuilder/"&gt;WindowBuilder&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装了Eclipse bootstrap e4插件之后，可以创建Eclipse 4 --&amp;gt; Eclipse 4 Application Project。&lt;/p&gt;
&lt;p&gt;生成的目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_project.png"&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;*.product&lt;/code&gt;文件是Eclipse插件项目的产品配置文件，可以以“E4Application”的方式运行：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_product.png"&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;*.product&lt;/code&gt;文件上右键--&amp;gt;Run As--&amp;gt;Eclipse Application，就可以启动一个e4应用：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_application.png"&gt;&lt;/p&gt;
&lt;p&gt;整个工程可以导出(Export)为"Eclipse Product"，称为一个可以脱离Eclipse独立运行的、跨平台的RCP应用。&lt;/p&gt;
&lt;h1&gt;应用模型&lt;/h1&gt;
&lt;p&gt;好吧，到目前为止，e4所表现出来的功能与Eclipse 3.x相比没什么区别。但是请关注一下上面生成的&lt;code&gt;Application.e4xmi&lt;/code&gt;文件。
该文件是e4中的应用模型文件。&lt;/p&gt;
&lt;p&gt;在 Eclipse 平台 UI 的早期版本中，workbench 被显式地硬编码来布局 workbench 窗口、workbench 页面、编辑器区域或视图堆栈。e4 引入了额外的一层，可将UI元素提取和抽象成一个模型。应用程序可以重新配置或扩展这个模型来制作不同的外观。这个模型也可被动态操纵；模型的改变可以立即反映出 UI 的变化。&lt;/p&gt;
&lt;p&gt;e4的模型的特性为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于抽象描述&lt;/li&gt;
&lt;li&gt;可以在运行时(runtime)更改&lt;/li&gt;
&lt;li&gt;支持扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;抽象描述&lt;/h2&gt;
&lt;p&gt;e4的应用模型基于抽象描述——应用模型只定义了需要哪些组件，而不关注这些组件是如何实现的。e4应用模型实现了应用模型和实际视图(Views)的分离。&lt;/p&gt;
&lt;p&gt;由于应用模型没有绑定的具体实现，这意味着一种可能：同一个应用模型可以用各种界面技术（如SWT/JFace, Swing甚至web，Flash）来实现。&lt;/p&gt;
&lt;p&gt;模型中即描述了可视的组件，如 windows, parts (views 和 editors), menus, toolbars等，也可以描述非可视化组件如handlers, commands , key bindings等。所有能够在模型中描述的组件（包括可视化组件和非可视化组件），都实现了MApplicationElement接口，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_MApplicationElement.png"&gt;&lt;/p&gt;
&lt;p&gt;用Eclipse 4 model editor打开&lt;code&gt;Application.e4xmi&lt;/code&gt;，可以看到如下的视图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_app_model.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Application.e4xmi&lt;/code&gt;是基于EMF定义的。其定义文件(.ecore）位于 org.eclipse.e4.ui.model.workbench 插件的model文件夹中。&lt;/p&gt;
&lt;h2&gt;常用的可视化组件&lt;/h2&gt;
&lt;p&gt;e4中的可视化组件描述类都来自&lt;code&gt;MUIElement&lt;/code&gt;，该接口当然也继承了&lt;code&gt;MApplicationElement&lt;/code&gt;接口。
常用的可视化组件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Window&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;窗口。一个Eclipse 应用可以包含一个或多个窗口。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/elements/window.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parts&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;e4中不区分Views和editors，而是统一定义为Parts。Part能够放置在用户界面的任何位置，每个Part可以有自己的菜单、工具条，可以出来自己的模型数据。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/elements/part.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Perspective&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Perspective是Parts的容器，可以管理内部Part的布局。一个应用可以有多个不同的Perspective(不能同时出现)，以适应不同的应用场景。
  比如，Eclipse IDE提供了Java、Java EE、Debug等Perspective。&lt;/p&gt;
&lt;p&gt;在应用模型中，为了管理方便，还可以将Perspective放置到Perspective Stack中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PartStack 和 PartSashContainer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Part可以直接用于Window或Perspective中，也可以将其分组。使用PartStack 和 PartSashContainer可以实现Part的分组和布局管理。&lt;/p&gt;
&lt;p&gt;PartStack可以容纳多个Part，每次只能显示其中一个Part，以页签(tab)的形式进行切换，而PartSashContainer以水平或竖直布局的方式同时显示多个Part。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/elements/partstack.png"&gt;&lt;/p&gt;
&lt;p&gt;通过PartStack和PartSashContainer的组合，能够创建出非常复杂的布局：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/elements/partsashcontainer.png"&gt;&lt;/p&gt;
&lt;p&gt;PartStack 和 PartSashContainer中的子组件，可以设置“容器数据(Container Data)”，作为决定自己在容器中布局的参数。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/elements/containerdata.png"&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，容器中的所有元素要么都设置容器数据，要么都不设置，否则会出现异常。&lt;/p&gt;
&lt;h1&gt;依赖注入&lt;/h1&gt;
&lt;p&gt;基于上一节的内容，我们可以脱离UI组件的实现，直接定义出应用模型。&lt;/p&gt;
&lt;p&gt;同样的，当我们实现一个UI组件的时候，也完全无需考虑应用模型的存在。在e4中，View甚至无需实现任何接口，而是通过依赖注入的方式获取UI组件的上下文环境。可以使用&lt;a href="/2013/12/31/jsr330.html"&gt;JSR330&lt;/a&gt;中定义的&lt;code&gt;@Inject&lt;/code&gt;注解，也可以使用e4的&lt;code&gt;org.eclipse.e4.ui.di&lt;/code&gt;包中定义的&lt;code&gt;@Focus&lt;/code&gt;、&lt;code&gt;@Persist&lt;/code&gt;等注解。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class SamplePart {
    private Text txtInput;
    private TableViewer tableViewer;

    @Inject
    private MDirtyable dirty;

    @PostConstruct
    public void createComposite(Composite parent) {
        parent.setLayout(new GridLayout(1, false));

        txtInput = new Text(parent, SWT.BORDER);
        txtInput.setMessage(&amp;quot;Enter text to mark part as dirty&amp;quot;);
        txtInput.addModifyListener(new ModifyListener() {
            @Override
            public void modifyText(ModifyEvent e) {
                dirty.setDirty(true);
            }
        });
        txtInput.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));

        tableViewer = new TableViewer(parent);

        tableViewer.add(&amp;quot;Sample item 1&amp;quot;);
        tableViewer.add(&amp;quot;Sample item 2&amp;quot;);
        tableViewer.add(&amp;quot;Sample item 3&amp;quot;);
        tableViewer.add(&amp;quot;Sample item 4&amp;quot;);
        tableViewer.add(&amp;quot;Sample item 5&amp;quot;);
        tableViewer.getTable().setLayoutData(new GridData(GridData.FILL_BOTH));
    }

    @Focus
    public void setFocus() {
        tableViewer.getTable().setFocus();
    }

    @Persist
    public void save() {
        dirty.setDirty(false);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于UI组件与应用模型完全解耦，可以对UI组件单独进行测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public static void main(String[] args) {
    Display display = new Display();
      Shell shell = new Shell(display);
      shell.setLayout(new FillLayout());
      SamplePart part = new SamplePart();
      part.createComposite(shell);
      shell.open();
      while( !shell.isDisposed() ) {
          if( ! display.readAndDispatch() ) {
            display.sleep();
          }
      }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;向模型注入资源&lt;/h1&gt;
&lt;p&gt;前面两节分别介绍了创建应用模型和UI组件，接下来就是将二者结合起来。&lt;/p&gt;
&lt;p&gt;在应用模型中，使用URI注入外部资源。比如，一个Part的Icon、Class都是通过URI注入的。这些资源是延迟加载(lazy loaded)的——只有显示某个可视化组件时，才加载其需要的资源。&lt;/p&gt;
&lt;p&gt;模型使用的资源即可以在运行时注入或更改，也可以在Eclipse 4 model editor中指定初始的资源：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4/e4_app_model.png"&gt;&lt;/p&gt;
&lt;p&gt;任何形式的URI都可以作为资源使用。比如：&lt;code&gt;http://thinkinside.tk/assets/ico/favicon.png&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于Eclipse的插件环境，可以使用应用模型所在的插件(bundle)或来自其他插件的资源，分别使用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bundleclass://Bundle-SymbolicName/ package.classname&lt;/code&gt; 和&lt;/p&gt;
&lt;p&gt;&lt;code&gt;platform:/plugin/Bundle-SymbolicName/ path/filename.extension&lt;/code&gt;的形式。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bundleclass://tangle-app/parts.SamplePart

platform:/plugin/test/icons/save_edit.gif
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;定义行为&lt;/h1&gt;
&lt;p&gt;e4的应用模型中，通过&lt;code&gt;Handler&lt;/code&gt;定义行为。可视化组件和&lt;code&gt;Handler&lt;/code&gt;之间通过&lt;code&gt;Command&lt;/code&gt;关联。&lt;/p&gt;
&lt;p&gt;与GUI组件一样，Handler的定义和实现也是分离的。在应用模型中定义的&lt;code&gt;Handler&lt;/code&gt;通过Class URI关联到具体的实现类。我们可以单独编写一个&lt;code&gt;Handler&lt;/code&gt;，无需实现任何接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class MyHandler {
    @Execute
    public void execute(Shell shell) {
        MessageDialog.openInformation(shell, &amp;quot;&amp;quot;, &amp;quot;Hello World!&amp;quot;);
    }


    @CanExecute
    public boolean canExecute() {

        return true;
    }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，&lt;code&gt;canExecute()&lt;/code&gt;方法是可选的。该方法定义了&lt;code&gt;execute()&lt;/code&gt;方法是否可以被执行的一个开关。&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;Handler&lt;/code&gt;与应用模型完全解耦，可以单独对&lt;code&gt;Handler&lt;/code&gt;进行测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public static void main(String[] args) {
  Display display = new Display();
  Shell shell = new Shell(display);
  shell.open();
  MyHandler.execute(shell);
  while( !shell.isDisposed() ) {
      if( ! display.readAndDispatch() ) {
        display.sleep();
      }
  }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最简单的事件处理是菜单/工具条的处理。使用模型编辑器，可以在图形界面中很容易的将&lt;code&gt;Handler&lt;/code&gt;和菜单项都关联到同一个&lt;code&gt;Commnad&lt;/code&gt;，
即实现了行为的定义。这里不做截图，定义好的&lt;code&gt;Application.e4xmi&lt;/code&gt;中相关内容可能是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c"&gt;&amp;lt;!--定义一个Command--&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;commands&lt;/span&gt; &lt;span class="na"&gt;xmi:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_4mWoMHcyEeOYmvSF-9z33Q&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;elementId=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;holbrook.tangle.demo.myCommand&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;commandName=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;测试Cmd&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!--定义一个Handler，并关联到Command--&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;handlers&lt;/span&gt; &lt;span class="na"&gt;xmi:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_J-fYsHczEeOYmvSF-9z33Q&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;elementId=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;holbrook.tangle.demo.myHandler&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;contributionURI=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bundleclass://tangle-app/handlers.MyHandler&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;command=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_4mWoMHcyEeOYmvSF-9z33Q&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!--定义一个菜单项，也关联到Command--&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;mainMenu&lt;/span&gt; &lt;span class="na"&gt;xmi:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_FfY8UHbUEeOYmvSF-9z33Q&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;elementId=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tangle-app.menu.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;children&lt;/span&gt; &lt;span class="na"&gt;xsi:type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;menu:Menu&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;xmi:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_OwboQHc0EeOYmvSF-9z33Q&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;elementId=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tangle-app.menu.1&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;label=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;测试菜单&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;children&lt;/span&gt; &lt;span class="na"&gt;xsi:type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;menu:HandledMenuItem&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;xmi:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_TwOjEHc0EeOYmvSF-9z33Q&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;elementId=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tangle-app.handledmenuitem.0&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;label=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;测试Cmd&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;command=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_4mWoMHcyEeOYmvSF-9z33Q&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/children&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/mainMenu&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;CSS样式&lt;/h1&gt;
&lt;p&gt;e4将桌面应用和Web应用的一些特性融合在了一起，比如，可以通过CSS定义桌面应用的外观。&lt;/p&gt;
&lt;p&gt;使用Eclipse bootstrap e4创建的Eclipse 4 Application Project，会包含一个&lt;code&gt;css/default.css&lt;/code&gt;的空文件。
编辑这个文件就可以修改应用的外观。&lt;/p&gt;
&lt;p&gt;在e4中，CSS选择器使用&lt;code&gt;type#id.class&lt;/code&gt;的格式。其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;type：对应SWT组件类（如Button、Composite等）&lt;/li&gt;
&lt;li&gt;id：对应应用模型中的&lt;code&gt;elementId&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些映射关系可以参考&lt;a href="http://wiki.eclipse.org/E4/CSS/SWT_Mapping"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是一个CSS的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;Text&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;font&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Verdana&lt;/span&gt; &lt;span class="m"&gt;15px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;color&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;red&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;background-color&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;green&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认情况下，该CSS就会生效。因为在&lt;code&gt;plugin.xml&lt;/code&gt;中，已经指定了CSS的扩展点：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="images/e4e4_css_extension.png"&gt;&lt;/p&gt;
&lt;p&gt;更灵活的使用CSS是通过主题管理器。&lt;/p&gt;</content><category term="GUI"></category><category term="java"></category></entry><entry><title>Java依赖注入规范：JSR330</title><link href="http://holbrook.github.io/2013/12/31/jsr330.html" rel="alternate"></link><published>2013-12-31T00:00:00+08:00</published><updated>2013-12-31T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-12-31:/2013/12/31/jsr330.html</id><summary type="html">&lt;p&gt;Java World似乎总会出现一些接口规范，这样做的好处是可以面向接口编程，可以在实现了该接口的产品/组件之间自由切换，避免被厂商绑架。 本文要介绍的JSR330:Dependency Injection for Java，Java依赖注入规范。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;依赖关系&lt;/h1&gt;
&lt;p&gt;在面向对象编程中，我们常常处理依赖。比如ClassA依赖ClassB，通常需要：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ClassA a = new ClassA();
ClassB b = new ClassB();

a.setB(b);
a.xxx();
……
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大量这样的依赖处理会导致高耦合度，并且由于通过硬编码组织对象和资源，代码不具有灵活性。&lt;/p&gt;
&lt;h1&gt;DI和IoC&lt;/h1&gt;
&lt;p&gt;一种更好的处理方式是 &lt;strong&gt;依赖注入&lt;/strong&gt; 。比如上面的例子中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过某种方式声明“ClassA &lt;strong&gt;依赖&lt;/strong&gt; ClassB”&lt;/li&gt;
&lt;li&gt;使用ClassA时，有某种机制自动创建ClassB并将其 &lt;strong&gt;注入&lt;/strong&gt; 到ClassA&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里面，“某种机制”需要一个容器来实现。这个容器叫做"IoC(Inversion of Control)容器"。
之所以叫做“控制反转”，是说不在对象中直接控制，而是由容器控制创建对象、为对象注入其他对象和资源等行为。&lt;/p&gt;
&lt;p&gt;IoC是一种思想，实际上我们遇到的大多数“容器”都有对其内容的控制功能。&lt;/p&gt;
&lt;p&gt;对于前一节的例子，IoC容器可能会有这样一个处理过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建ClassA&lt;/li&gt;
&lt;li&gt;分析ClassA的依赖项，得出其依赖ClassB&lt;/li&gt;
&lt;li&gt;创建ClassB&lt;/li&gt;
&lt;li&gt;将ClassB注入到ClassA&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之后，我们可以直接从容器中获取创建并组装好的ClassA对象，无需任何处理即可使用。&lt;/p&gt;
&lt;p&gt;关于DI和IoC，可以参考Martin Fowler的经典文章：&lt;a href="http://www.martinfowler.com/articles/injection.html"&gt;《Inversion of Control Containers and the Dependency Injection pattern》&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;依赖的描述&lt;/h1&gt;
&lt;p&gt;在DI和IoC的历史上，&lt;a href="http://spring.io/"&gt;Spring&lt;/a&gt;功不可没。可以说，Spring使得DI和IoC称为Java应用开发的主流方式。&lt;/p&gt;
&lt;p&gt;2004年3月，&lt;a href="https://spring.io/blog/2004/03/24/spring-framework-1-0-final-released"&gt;Spring 1.0&lt;/a&gt;
使用外部配置文件(xml)描述对象之间的依赖关系。&lt;/p&gt;
&lt;p&gt;2004年10月，JDK1.5开始支持注解(Annotations)语法。&lt;/p&gt;
&lt;p&gt;2007年3月， &lt;a href="https://code.google.com/p/google-guice/"&gt;Google Guice&lt;/a&gt; 1.0发布，使用annotations作为依赖描述的方式。&lt;/p&gt;
&lt;p&gt;2007年11月，&lt;a href="https://spring.io/blog/2007/11/19/spring-framework-2-5-released"&gt;Spring 2.5&lt;/a&gt;也开始支持annotation。&lt;/p&gt;
&lt;h1&gt;JSR330&lt;/h1&gt;
&lt;p&gt;随着各种IoC容器的出现，依赖的描述方式也五花八门。为了规范和统一，JCP(Java Community Process)于2009年10月发布了
&lt;a href="https://jcp.org/en/jsr/detail?id=330"&gt;JSR330&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;JSR330在javax.inject中规定了依赖注入的标准注解(Annotations)。包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Inject&lt;/code&gt; : 标记为“可注入”。可用于构造器(constructors), 方法(methods)或字段(fields)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Qualifier&lt;/code&gt; : 限定器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Scope&lt;/code&gt; : 标记作用域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Named&lt;/code&gt; : 基于 String 的限定器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Singleton&lt;/code&gt; : 标记为单例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JSR330只规定了依赖注入的描述，对于容器实现未作要求。目前 Spring 、Guice 、Eclipse e4等常用框架已经开始兼容该规范。
JSR-299（Contexts and Dependency Injection for Java EE platform，参考实现 Weld ）在依赖注入上也使用该规范。&lt;/p&gt;
&lt;p&gt;比如，定义两个接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;interface MessageRenderer {
    public void render();

    public void setMessageProvider(MessageProvider provider);

    public MessageProvider getMessageProvider();
}

interface MessageProvider {
    public String getMessage();
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很明显，一个MessageRenderer依赖一个MessageProvider。&lt;/p&gt;
&lt;p&gt;在实现类中，可以使用依赖注入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;StandardOutMessageRenderer&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;MessageRenderer&lt;/span&gt; {

    &lt;span class="nv"&gt;@Inject&lt;/span&gt;
    &lt;span class="nv"&gt;@Named&lt;/span&gt;(&lt;span class="s"&gt;&amp;quot;messageProvider&amp;quot;&lt;/span&gt;)
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;MessageProvider&lt;/span&gt; &lt;span class="n"&gt;messageProvider&lt;/span&gt; = &lt;span class="n"&gt;null&lt;/span&gt;;

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="n"&gt;render&lt;/span&gt;() {
        &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;messageProvider&lt;/span&gt; == &lt;span class="n"&gt;null&lt;/span&gt;) {
            &lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;RuntimeException&lt;/span&gt;(
                    &lt;span class="s"&gt;&amp;quot;You must set the property messageProvider of class:&amp;quot;&lt;/span&gt;
                            + &lt;span class="n"&gt;StandardOutMessageRenderer&lt;/span&gt;.&lt;span class="k"&gt;class&lt;/span&gt;.&lt;span class="n"&gt;getName&lt;/span&gt;());
        }

        &lt;span class="n"&gt;System&lt;/span&gt;.&lt;span class="n"&gt;out&lt;/span&gt;.&lt;span class="n"&gt;println&lt;/span&gt;(&lt;span class="n"&gt;messageProvider&lt;/span&gt;.&lt;span class="n"&gt;getMessage&lt;/span&gt;());
        }

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="n"&gt;setMessageProvider&lt;/span&gt;(&lt;span class="n"&gt;MessageProvider&lt;/span&gt; &lt;span class="n"&gt;provider&lt;/span&gt;) {
        &lt;span class="n"&gt;this&lt;/span&gt;.&lt;span class="n"&gt;messageProvider&lt;/span&gt; = &lt;span class="n"&gt;provider&lt;/span&gt;;
        }

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;MessageProvider&lt;/span&gt; &lt;span class="n"&gt;getMessageProvider&lt;/span&gt;() {
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;.&lt;span class="n"&gt;messageProvider&lt;/span&gt;;
        }

}


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ConfigurableMessageProvider&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;MessageProvider&lt;/span&gt; {

        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; = &lt;span class="s"&gt;&amp;quot;Default message&amp;quot;&lt;/span&gt;;

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;ConfigurableMessageProvider&lt;/span&gt;() {
        }

        &lt;span class="nv"&gt;@Inject&lt;/span&gt;
        &lt;span class="nv"&gt;@Named&lt;/span&gt;(&lt;span class="s"&gt;&amp;quot;message&amp;quot;&lt;/span&gt;)
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;ConfigurableMessageProvider&lt;/span&gt;(&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;) {
                &lt;span class="n"&gt;this&lt;/span&gt;.&lt;span class="n"&gt;message&lt;/span&gt; = &lt;span class="n"&gt;message&lt;/span&gt;;
        }

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="n"&gt;setMessage&lt;/span&gt;(&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;) {
                &lt;span class="n"&gt;this&lt;/span&gt;.&lt;span class="n"&gt;message&lt;/span&gt; = &lt;span class="n"&gt;message&lt;/span&gt;;
        }

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;getMessage&lt;/span&gt;() {
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;;
        }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，ConfigurableMessageProvider的构造函数中依赖一个&lt;code&gt;String&lt;/code&gt;类型的参数。&lt;/p&gt;
&lt;h1&gt;spring实现&lt;/h1&gt;
&lt;p&gt;Spring 3.0开始支持JSR330。下面的例子中，使用spring的classpath scanning功能
(&lt;a href="http://www.infoq.com/articles/spring-2.5-part-1"&gt;从spring2.5开始支持&lt;/a&gt;)，
会自动组装bean。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;beans&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.springframework.org/schema/beans&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;xmlns:context=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.springframework.org/schema/context&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&lt;/span&gt;
&lt;span class="s"&gt;                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

    &lt;span class="nt"&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class="na"&gt;base-package=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;demo&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;bean&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;message&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;java.lang.String&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;constructor-arg&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;You are running JSR330!&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;static&lt;/span&gt; &lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;String&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt; &lt;span class="nt"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;GenericXmlApplicationContext&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;GenericXmlApplicationContext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;classpath:jsr330.xml&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;refresh&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MessageRenderer&lt;/span&gt; &lt;span class="n"&gt;renderer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBean&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;messageRenderer&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;MessageRenderer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;renderer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;render&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="Java"></category></entry><entry><title>Drools规则引擎API概述</title><link href="http://holbrook.github.io/2013/12/20/drools_API.html" rel="alternate"></link><published>2013-12-20T00:00:00+08:00</published><updated>2013-12-20T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-12-20:/2013/12/20/drools_API.html</id><summary type="html">&lt;p&gt;规则引擎中，将知识表达为规则（rules），要分析的情况定义为事实（facts）。二者在内存中的存储分别称为Production Memory和Working Memory。在外围，还会有一个执行引擎（Execution Engine）。
与此对应，规则引擎API也分成三个部分。在Drools中，分别叫做Knowledge API，Fact API和Execution API。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="/2012/03/20/rule_engine_1.html"&gt;如前所述&lt;/a&gt;，
规则引擎中，将知识表达为规则（rules），要分析的情况定义为事实（facts）。二者在内存中的存储分别称为Production Memory和Working Memory。在外围，还会有一个执行引擎（Execution Engine）。&lt;/p&gt;
&lt;p&gt;与此对应，规则引擎API也分成三个部分。在Drools中，分别叫做Knowledge API，Fact API和Execution API。&lt;/p&gt;
&lt;h1&gt;Knowledge API&lt;/h1&gt;
&lt;p&gt;Drools将知识库(KnowledgeBase)作为&lt;a href="/2012/12/07/jsr94.html"&gt;JSR94&lt;/a&gt;中的规则执行集(RuleExecutionSet)。知识库中的知识以包(KnowledgePackage)为单位组合而成。每个包中聚合多个规则(Rule)。&lt;/p&gt;
&lt;p&gt;通常，一个包中的内容会在一个或多个资源(Resource)中保存。资源的类型可以有很多种,如.drl 文件、.dslr 文件或 xls 文件等。&lt;/p&gt;
&lt;p&gt;规则包还可以从规则流(rule flow) 文件中获取。&lt;/p&gt;
&lt;p&gt;&lt;img alt="KnowledgeBase" src="images/rule-engine/KnowledgeBase.png"&gt;&lt;/p&gt;
&lt;p&gt;与此对应，Drools定义了一组Knowledge API来操作知识库。&lt;/p&gt;
&lt;p&gt;&lt;img alt="KnowledgeBase" src="images/rule-engine/KnowledgeAPI.png"&gt;&lt;/p&gt;
&lt;p&gt;构建知识库的一般过程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过ResourceFactory获取资源。可以从Classpath、URL、File、ByteArray、Reader等输入源中获取&lt;/li&gt;
&lt;li&gt;构建KnowledgeBuilder，将资源添加到KnowledgeBuilder中。KnowledgeBuilder通常由KnowledgeBuilderFactory创建&lt;/li&gt;
&lt;li&gt;从KnowledgeBuilder中获取规则包&lt;/li&gt;
&lt;li&gt;创建KnowledgeBase，可以通过KnowledgeBaseConfiguration定义KnowledgeBase的一些属性，默认的配置位于drools-core-VERSION.jar 包下 META-INF/drools.default.rulebase.conf 文件中&lt;/li&gt;
&lt;li&gt;将规则包添加到KnowledgeBase&lt;/li&gt;
&lt;li&gt;为KnowledgeBase添加KnowledgeBaseEventListener，可以监控KnowledgeBase中的事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;p&gt;{% highlight java %}&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;KnowledgeBase&lt;/span&gt; &lt;span class="nt"&gt;buildKBase&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;Resource&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ResourceFactory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newClassPathResource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello.drl&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Demo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;KnowledgeBuilder&lt;/span&gt; &lt;span class="n"&gt;kbuilder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;KnowledgeBuilderFactory&lt;/span&gt;
            &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newKnowledgeBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;kbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ResourceType&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DRL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;validate&lt;/span&gt;
    &lt;span class="n"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hasErrors&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;规则中存在错误,错误消息如下:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;KnowledgeBuilderErrors&lt;/span&gt; &lt;span class="n"&gt;kbuidlerErrors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getErrors&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kbuidlerErrors&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hasNext&lt;/span&gt;&lt;span class="p"&gt;();)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;

    &lt;span class="nt"&gt;Collection&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;KnowledgePackage&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;kpackages&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;kbuilder&lt;/span&gt;&lt;span class="nc"&gt;.getKnowledgePackages&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="nt"&gt;KnowledgeBaseConfiguration&lt;/span&gt; &lt;span class="nt"&gt;kbConf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
            &lt;span class="nt"&gt;KnowledgeBaseFactory&lt;/span&gt;&lt;span class="nc"&gt;.newKnowledgeBaseConfiguration&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="nt"&gt;kbConf&lt;/span&gt;&lt;span class="nc"&gt;.setProperty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;org.drools.sequential&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;KnowledgeBase&lt;/span&gt; &lt;span class="nt"&gt;kbase&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;KnowledgeBaseFactory&lt;/span&gt;&lt;span class="nc"&gt;.newKnowledgeBase&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="nt"&gt;KnowledgeBase&lt;/span&gt; &lt;span class="nt"&gt;kbase&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
            &lt;span class="nt"&gt;KnowledgeBaseFactory&lt;/span&gt;&lt;span class="nc"&gt;.newKnowledgeBase&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;kbConf&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="nt"&gt;kbase&lt;/span&gt;&lt;span class="nc"&gt;.addKnowledgePackages&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;kpackages&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="nt"&gt;return&lt;/span&gt; &lt;span class="nt"&gt;kbase&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;Fact API&lt;/h1&gt;
&lt;p&gt;要操作Working Memory，首先要建立规则引擎的一个会话。Drools中的有状态会话和无状态会话分别为StatefulKnowledgeSession和StatelessKnowledgeSession，都可以由KnowledgeBase建立。&lt;/p&gt;
&lt;p&gt;通过会话可以进行操作Fact对象，执行规则等交互，例如：&lt;/p&gt;
&lt;p&gt;{% highlight java %}&lt;/p&gt;
&lt;p&gt;KnowledgeBase kbase = buildKBase();&lt;/p&gt;
&lt;p&gt;StatefulKnowledgeSession statefulKSession=kbase.newStatefulKnowledgeSession();
statefulKSession.setGlobal("globalTest", new Object());&lt;/p&gt;
&lt;p&gt;statefulKSession.insert(new Object());
statefulKSession.fireAllRules();
statefulKSession.dispose();&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;StatefulKnowledgeSession中，insert()方法、fireAllRules()方法和 dispose()方法是分开执行的，这个过程中可以进行一定的控制，
而StatelessKnowledgeSession不同，在无状态会话中，上述三个方法被合并为execute()方法，不能分开调用。如果要插入多个Fact对象，只能使用集合，比如：&lt;/p&gt;
&lt;p&gt;{% highlight java %}
StatelessKnowledgeSession statelessKSession=kbase.newStatelessKnowledgeSession();
ArrayList list=new ArrayList();
list.add(new Object());
list.add(new Object());
statelessKSession.execute(list);&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;这样的特点决定了，无状态会话适合推演和分析，需要事先知道所有的事实(Fact)；而有状态会话可以随时增加事实并进行批评，适合实际应用。&lt;/p&gt;
&lt;p&gt;无状态会话中还可以使用execute(Command cmd)方法。比如，如果要在无状态会话中插入一个List，可以用CommandFactory生成一个关于List的Command:&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight java %}
statelessKSession.execute(CommandFactory.newInsert(list));&lt;/p&gt;
&lt;p&gt;同样，无状态会话中如果要设置global，也需要使用Command:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
ArrayList&lt;Command&gt; list=new ArrayList&lt;Command&gt;();&lt;/p&gt;
&lt;p&gt;list.add(CommandFactory.newInsert(new Object()));
list.add(CommandFactory.newInsert(new Object()));&lt;/p&gt;
&lt;p&gt;list.add(CommandFactory.newSetGlobal("key1", new Object()));
list.add(CommandFactory.newSetGlobal("key2", new Object()));&lt;/p&gt;
&lt;p _="%" endhighlight&gt;statelessKSession.execute(CommandFactory.newBatchExecution(list)) ;&lt;/p&gt;
&lt;h1&gt;Execution API&lt;/h1&gt;
&lt;p&gt;插入到WorkingMemory中的对象，并不是克隆，而是对原对象的引用。这就意味着引擎中可以改变外部的对象，这是引擎与外部数据交互的一个通道。&lt;/p&gt;
&lt;p&gt;此外，insert()方法还会返回一个FactHandler，作为引擎中该Fact对象的一个句柄。&lt;/p&gt;
&lt;p&gt;最后，session上可以注册AgendaEventListener、ProcessEventListener和WorkingMemoryEventListener，这也是常用的交互方式。
比如WorkingMemoryEventListener可以监听Fact对象变化的事件：&lt;/p&gt;
&lt;p&gt;{% highlight java %}
public interface WorkingMemoryEventListener
    extends
    EventListener {
    void objectInserted(ObjectInsertedEvent event);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void objectUpdated(ObjectUpdatedEvent event);

void objectRetracted(ObjectRetractedEvent event);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;</content><category term="规则引擎"></category></entry><entry><title>用Ganglia监控集群的性能</title><link href="http://holbrook.github.io/2013/07/30/ganglia.html" rel="alternate"></link><published>2013-07-30T00:00:00+08:00</published><updated>2013-07-30T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-07-30:/2013/07/30/ganglia.html</id><summary type="html">&lt;p&gt;对基础设施的监控主要包括三个方面：状态，性能和可用性。通俗的讲就是：是否在干活，干了多少活，还能干多少。与Cacti、Nagios、Zabbix等工具相比，Ganglia更关注整个集群的性能和可用性。可以用于集群的性能监控、分析和优化。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Ganglia简介&lt;/h1&gt;
&lt;p&gt;对基础设施的监控主要包括三个方面：状态，性能和可用性。通俗的讲就是：是否在干活，干了多少活，还能干多少。&lt;/p&gt;
&lt;p&gt;有很多开源的强大工具可以用于监控，比如
&lt;a href="http://www.cacti.net/"&gt;Cacti&lt;/a&gt;，
&lt;a href="http://www.nagios.org"&gt;Nagios&lt;/a&gt;
以及比较新的
&lt;a href="http://www.shinken-monitoring.org/"&gt;Shinken&lt;/a&gt;和
&lt;a href="http://www.zabbix.com"&gt;Zabbix&lt;/a&gt;。
这些工具的主要功能是状态监控和报警——就像一个合格的监工，随时掌握基础设施是否在干活，发现谁没干活马上报告。&lt;/p&gt;
&lt;p&gt;如果是传统的运维工作，有这些工具就足够强大了。但是对于分布式系统的开发+运维人员（DevOps?），更关心的是掌握分布式系统的性能和可用性，根据数据做出性能调整、升级、扩容等的决策，从而保证基础设施服务能够满足不断增长的业务需求。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ganglia.sourceforge.net/"&gt;Ganglia&lt;/a&gt;就是这样一种工具。Ganglia 是 UC Berkeley 发起的一个开源监视项目，设计用于测量数以千计的节点。Ganglia主要监控集群的性能指标，如cpu 、mem、硬盘利用率， I/O负载、网络流量情况等，
也可以监控自定义的性能指标。通过Ganglia绘制的曲线很容易见到每个节点的工作状态，对合理调整、分配系统资源，提高系统整体性能起到重要作用。&lt;/p&gt;
&lt;p&gt;gmond 带来的系统负载非常少，这使得它成为在集群中各台计算机上运行的一段代码，而不会影响用户性能。&lt;/p&gt;
&lt;h1&gt;Ganglia架构&lt;/h1&gt;
&lt;p&gt;Ganglia的整体架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Ganglia-architecture" src="images/2013/ganglia/ganglia_architecture.gif"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个被检测的节点或集群运行一个gmond进程，进行监控数据的收集、汇总和发送。gmond即可以作为发送者（收集本机数据），也可以作为接收者（汇总多个节点的数据）。&lt;/li&gt;
&lt;li&gt;通常在整个监控体系中只有一个gmetad进程。该进程定期检查所有的gmonds，主动收集数据，并存储在RRD存储引擎中。&lt;/li&gt;
&lt;li&gt;ganglia-web是使用php编写的web界面，以图表的方式展现存储在RRD中的数据。通常与gmetad进程运行在一起。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，&lt;a href="http://oss.oetiker.ch/rrdtool/"&gt;RRDtool&lt;/a&gt;(Round Robin Database tool,环状数据库工具)是一组操作RRD数据的API，支持数据图形化。RRD是一种环状数据库技术，只存储固定数量的数据，新的数据会覆盖最旧的数据。
更多信息可以参考&lt;a href="http://bbs.chinaunix.net/forum.php?mod=viewthread&amp;amp;tid=864861&amp;amp;page=1"&gt;RRDtool简体中文教程 v1.01&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;Ganglia规划&lt;/h1&gt;
&lt;p&gt;在动手部署Ganglia之前，首先要对监控体系进行初步的规划。主要考虑两方面的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单集群 or 多集群&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果节点较少，使用单集群配置起来更容易；
   如果节点很多，使用多集群可以避免广播风暴。但是需要为每个集群配置不同的组播通道（通过端口区分），同时要配置gmetad同时监听这多个通道。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组播模式 or 单播模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;组播模式是ganglia的默认模式，同一集群的多个gmond之间互相交换数据，gmetad中可以指定集群中的任意一个或多个节点作为"data_source"；&lt;/p&gt;
&lt;p&gt;组播模式可能会带来网络的 “抖动（Jitter）”。据说设置节点的时钟同步可以避免抖动的问题； 但如果网络环境不支持组播（比如Amazon’s AWS EC2），就需要使用单播模式。单播模式时，将大部分节点的gmond.conf中,global的deaf设置改为"yes"，则这些节点只发生数据，不接收其他节点的数据，同样也不能作为gmetad中的"data_source"。&lt;/p&gt;
&lt;p&gt;单播模式中还需要设置“send_metadata_interval”，比如30秒。以强制发送元数据。&lt;/p&gt;
&lt;p&gt;ganglia将一个gmetad覆盖的所有集群/节点称为一个grid。可以在/etc/ganglia/gmetad.conf中通过&lt;code&gt;gridname&lt;/code&gt;指定其名称。多个grid的数据也可以聚合到一个上级gmetad中。&lt;/p&gt;
&lt;h1&gt;安装和配置&lt;/h1&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;在RHEL/CentOS上如果配置了EPEL源，则安装变得非常简单。用yum可以查到如下软件包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ganglia.i686 : Ganglia Distributed Monitoring System&lt;/li&gt;
&lt;li&gt;ganglia.x86_64 : Ganglia Distributed Monitoring System&lt;/li&gt;
&lt;li&gt;ganglia-devel.i686 : Ganglia Library&lt;/li&gt;
&lt;li&gt;ganglia-devel.x86_64 : Ganglia Library&lt;/li&gt;
&lt;li&gt;ganglia-gmetad.x86_64 : Ganglia Metadata collection daemon&lt;/li&gt;
&lt;li&gt;ganglia-gmond.x86_64 : Ganglia Monitoring daemon&lt;/li&gt;
&lt;li&gt;ganglia-gmond-python.x86_64 : Ganglia Monitor daemon python DSO and metric modules&lt;/li&gt;
&lt;li&gt;ganglia-web.x86_64 : Ganglia Web Frontend&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在不同的节点选择对应的软件包安装即可。&lt;/p&gt;
&lt;h2&gt;配置防火墙规则&lt;/h2&gt;
&lt;p&gt;gmond和gmetad之间默认使用UDP的8649端口进行通信，如果配置多个集群，还会有其他端口。要保证这些端口畅通。&lt;/p&gt;
&lt;h2&gt;配置被监控节点(/etc/ganglia/gmond.conf)&lt;/h2&gt;
&lt;p&gt;最重要的配置是集群名称(cluster.name)。&lt;/p&gt;
&lt;p&gt;如果要配置多个集群，每个集群要使用不同的端口。共三个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;udp_send_channel.port&lt;/li&gt;
&lt;li&gt;udp_recv_channel.port&lt;/li&gt;
&lt;li&gt;tcp_accept_channel.port&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;配置中心节点(/etc/ganglia/gmetad.conf)&lt;/h2&gt;
&lt;p&gt;最重要的是配置数据源。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;data_source &amp;quot;NginX&amp;quot; a.a.a.101:8661 a.a.a.102:8661
data_source &amp;quot;LVS&amp;quot;   b.b.b.101 b.b.b.102
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;配置web&lt;/h2&gt;
&lt;p&gt;默认启动httpd服务后，就可以通过&lt;code&gt;http://IP/ganglia&lt;/code&gt;访问。如果提示权限问题，需要检查：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;selinux设置&lt;/li&gt;
&lt;li&gt;防火墙设置&lt;/li&gt;
&lt;li&gt;/etc/httpd/conf.d/ganglia.conf中的&lt;code&gt;Deny from all&lt;/code&gt;限制&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;扩展监控功能&lt;/h1&gt;
&lt;p&gt;Ganglia默认只监控一些通用的性能指标，如果要监控自定义的指标，就需要对Ganglia进行扩展。&lt;/p&gt;
&lt;h2&gt;插件机制&lt;/h2&gt;
&lt;p&gt;从Ganglia 3.1开始，可以使用python开发的插件对Ganglia进行扩展。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/ganglia/gmond.conf&lt;/code&gt;配置中通常会包含：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;include (&amp;#39;/etc/ganglia/conf.d/*.conf&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果安装了&lt;code&gt;ganglia-gmond-python&lt;/code&gt;软件包，会创建一个&lt;code&gt;/etc/ganglia/conf.d/modpython.conf&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;{% highlight nginx %}
modules {
  module {
    name = "python_module"
    path = "modpython.so"
    params = "/usr/lib64/ganglia/python_modules"
  }
}&lt;/p&gt;
&lt;p _="%" endhighlight&gt;include ('/etc/ganglia/conf.d/*.pyconf')&lt;/p&gt;
&lt;p&gt;这样，就可以用python编写自定义的插件。&lt;/p&gt;
&lt;p&gt;Ganglia 在 GitHub 上已经收集了一些&lt;a href="https://github.com/ganglia/gmond_python_modules"&gt;常用的python插件&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;部署NginX插件&lt;/h2&gt;
&lt;p&gt;在&lt;a href="https://github.com/ganglia/gmond_python_modules"&gt;常用的python插件&lt;/a&gt;中包含了
&lt;a href="https://github.com/ganglia/gmond_python_modules/tree/master/nginx_status"&gt;nginx_status插件&lt;/a&gt;，
该插件利用&lt;a href="/nginx_keepalived.html#menuIndex9"&gt;NginX的状态监控功能&lt;/a&gt;获取数据。&lt;/p&gt;
&lt;p&gt;在确保nginx_status可以访问的前提下，只需要做如下配置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将python_modules/目录下的文件复制到gmond节点的&lt;code&gt;/usr/lib64/ganglia/python_modules&lt;/code&gt;目录。这是执行数据采集的脚本&lt;/li&gt;
&lt;li&gt;将conf.d/目录下的文件复制到gmond节点的&lt;code&gt;/etc/ganglia/conf.d/&lt;/code&gt;目录。这些文件定义了collection_group以及metric&lt;/li&gt;
&lt;li&gt;重启gmond&lt;/li&gt;
&lt;li&gt;将graph.d/目录下的文件复制到gmetad节点的&lt;code&gt;/usr/share/ganglia/graph.d&lt;/code&gt;目录。这些文件定义了如何绘制metric的图形&lt;/li&gt;
&lt;li&gt;重启gmetad，在对应的nginx节点详细信息中可以看到nginx metric对应的7个图表。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="Ganglia-nginx" src="images/2013/ganglia/ganglia_nginx.png"&gt;&lt;/p&gt;
&lt;p&gt;理解了NginX插件，基本上能够自己开发Ganglia插件了。&lt;/p&gt;
&lt;h1&gt;TODO：与Nagios结合使用&lt;/h1&gt;
&lt;p&gt;Nagios提供了很好的报警机制，将Ganglia与Nagios结合使用是常见的方式。&lt;/p&gt;</content><category term="运维"></category><category term="cluster"></category></entry><entry><title>keepalived实现双机互备</title><link href="http://holbrook.github.io/2013/07/16/ha_keepalived.html" rel="alternate"></link><published>2013-07-16T00:00:00+08:00</published><updated>2013-07-16T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-07-16:/2013/07/16/ha_keepalived.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;目标：高可用&lt;/h1&gt;
&lt;p&gt;“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。&lt;/p&gt;
&lt;p&gt;通过高可用性设计，可以提高系统的平均无故障时间(MTTF)，
对于重要的系统或系统中重要的节点，必须有高可用性的设计来保证系统的平均无故障时间达到预期的要求。&lt;/p&gt;
&lt;p&gt;前面的&lt;a href="/2013/05/27/nginx_keepalived.html"&gt;NginX负载均衡方案&lt;/a&gt;中就使用了keepalived实现NginX节点的高可用，但那只是高可用性设计中的一种工作方式。
通常来说，高可用设计中多个冗余设备可以采用以下三种工作方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从方式 （非对称方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主机工作，备机处于监控准备状况；当主机宕机时，备机接管主机的一切工作，待主机恢复正常后，按使用者的设定以自动或手动方式将服务切换到主机上运行，数据的一致性通过共享存储系统解决。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双机双工方式（互备互援）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两台主机同时运行各自的服务工作且相互监测情况，当任一台主机宕机时，另一台主机立即接管它的一切工作，保证工作实时，应用服务系统的关键数据存放在共享存储系统中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集群工作方式（多服务器互备方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多台主机一起工作，各自运行一个或几个服务，各为服务定义一个或多个备用主机，当某个主机故障时，运行在其上的服务就可以被其它主机接管。&lt;/p&gt;
&lt;p&gt;显然，主从方式最简单但存在资源浪费的情况；双工方式可以充分利用资源，但配置较复杂，两个节点之间要进行心跳监测；集群工作方式与双工方式并没有本质的区别，但复杂度急剧增加，除了健康状态要多播外，还需要考虑脑裂、仲裁、法定人数等问题。&lt;/p&gt;
&lt;p&gt;本文只讨论双机互备的工作方式。&lt;/p&gt;
&lt;h1&gt;keepalived简介&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://www.keepalived.org/"&gt;keepalived&lt;/a&gt;是&lt;a href="/2013/07/04/lvs_intro.html"&gt;LVS&lt;/a&gt;的扩展项目，最初是为了解决LVS负载调度器的单点故障问题，但由于其适用性较强，配置简洁，也被用在许多其他场合，比如NginX负载均衡的高可用设计。&lt;/p&gt;
&lt;p&gt;keepalived的设计如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keepalived_architecture" src="images/2013/lvs/keepalived_architecture.jpg"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WatchDog：监控checkers和vrrp 进程&lt;/li&gt;
&lt;li&gt;Checkers：服务器健康状态检查(healthchecking)。可以编写自定义的健康检查脚本。&lt;/li&gt;
&lt;li&gt;VRRP STACK：当健康检查失败（服务不可用）时，在节点见进行切换。使用&lt;a href="http://en.wikipedia.org/wiki/Virtual_Router_Redundancy_Protocol"&gt;VRRP(Virtual Router Redundancy Protocol, 虚拟路由器冗余协议）&lt;/a&gt;的组播实现。&lt;/li&gt;
&lt;li&gt;IPVS wrappers：生成ipvs规则。专门为LVS所用。&lt;/li&gt;
&lt;li&gt;Netlink Reflector：设定vrpp的vip地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;keepalived可以在每个节点配置相同的VRRP实例(vrrp_instance)，并指定状态为MASTER或BACKUP。&lt;/p&gt;
&lt;p&gt;当Checkers监测到本节点的服务不可用时，使本机的VRRP实例停止工作，并通知另外节点的VRRP STACK接管VRRP实例，从而对外保证服务继续可用。&lt;/p&gt;
&lt;h1&gt;双机互备方式的实现&lt;/h1&gt;
&lt;p&gt;keepalived实现主备工作的资料到处都有，我这里也有一个&lt;a href="/2013/05/27/nginx_keepalived.html"&gt;NginX主备机制的例子&lt;/a&gt;，这里就不再重复了。&lt;/p&gt;
&lt;p&gt;其实，只要稍微动点脑筋，在主备的基础上就可以实现双机互备甚至集群的工作方式。因为有两个前提：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;keepalived并没有限定节点的个数只能是2个&lt;/li&gt;
&lt;li&gt;keepalived没有限定每个节点只能有一个VRRP实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，双机互备的实现原理就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在每个节点配置两个VRRP实例&lt;/li&gt;
&lt;li&gt;两个实例分别以一个节点为主(MASTER)，另一个节点为备(BACKUP)&lt;/li&gt;
&lt;li&gt;通过外部的其他机制，如DNS轮询，使得两个VRRP实例同时对外提供服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;配置实例&lt;/h1&gt;
&lt;p&gt;keepalived的配置文件（&lt;code&gt;/etc/keepalived/keepalived.conf&lt;/code&gt;)中包含3部分内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;global_defs： 全局配置&lt;/li&gt;
&lt;li&gt;vrrp_instance：vrrp实例，用来定义虚拟路由组&lt;/li&gt;
&lt;li&gt;virtual_server：定义LVS虚拟服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里面只例举一下vrrp实例的配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight nginx %}&lt;/p&gt;
&lt;p&gt;vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass password
    }
    virtual_ipaddress {
        192.168.1.8
    }
}
vrrp_instance VI_2 {
    state BACKUP
    interface eth0
    virtual_router_id 52
    priority 99
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass password
    }
    virtual_ipaddress {
        192.168.1.9
    }
}&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight nginx %}&lt;/p&gt;
&lt;p&gt;vrrp_instance VI_1 {
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 99
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass password
    }
    virtual_ipaddress {
        192.168.1.8
    }
}
vrrp_instance VI_2 {
    state MASTER
    interface eth0
    virtual_router_id 52
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass password
    }
    virtual_ipaddress {
        192.168.1.9
    }
}&lt;/p&gt;
&lt;p&gt;{% endhighlight nginx %}&lt;/p&gt;</content><category term="cluster"></category></entry><entry><title>Pillar：定义Salt配置管理的数据</title><link href="http://holbrook.github.io/2013/07/07/salt_pillar.html" rel="alternate"></link><published>2013-07-07T00:00:00+08:00</published><updated>2013-07-07T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-07-07:/2013/07/07/salt_pillar.html</id><summary type="html">&lt;p&gt;State定义了Salt配置管理的内容，Pillar则定义了Salt配置管理的数据。Pillar使得同一个配置项在各个minion中可以使用不同的数据，从而不需要在State中定义大量的include, extend等关系。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;为什么需要Pillar&lt;/h1&gt;
&lt;p&gt;看了&lt;a href="/2013/06/30/salt_sls_sample.html"&gt;这篇文档&lt;/a&gt;，你可能已经被Salt State的强大所折服。&lt;/p&gt;
&lt;p&gt;是的，Salt State能够解决很多配置管理的问题，但是如下两个场景，如果只用state进行配置就会比较麻烦：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让&lt;code&gt;apache&lt;/code&gt;配置项适应不同的OS&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="/2013/06/30/salt_sls_sample.html#menuIndex1"&gt;这个例子&lt;/a&gt;中的apache配置中通过pkg模块验证&lt;code&gt;apache&lt;/code&gt;软件包是否安装。但是在RedHat系统的yum包管理器和Debian系统的apt包管理器中，apache的包名字分别为&lt;code&gt;httpd&lt;/code&gt;和&lt;code&gt;apache2&lt;/code&gt;。如何避免为apache配置项针对不同的包管理器定义不同的state？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同一个应用在不同环境中的数据库连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假如你开发了一个Django应用，数据库连接信息在应用的settings.py中定义：&lt;/p&gt;
&lt;p&gt;{% highlight python %}
   DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'test',
        'USER': 'root',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '3306',
    }
   }&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;显然，数据库连接信息在开发环境、测试环境、生成环境中各不相同。如果把该应用作为一个state，如何实现在不同环境中的自动部署？&lt;/p&gt;
&lt;p&gt;Salt Pillar就是为了解决类似上述的问题而提供的组件。&lt;/p&gt;
&lt;h1&gt;Pillar是什么？&lt;/h1&gt;
&lt;p&gt;如&lt;a href="/2013/07/02/salt_state_config_structure.html"&gt;这篇文章&lt;/a&gt;所述，Salt Sate定义了配置项以及minion和配置项直接的映射关系；与此类似，Pillar定义了数据以及minion和数据的映射关系。Pillar中定义的数据可以在Salt的其他组件中引用，当然最常见的情况是在State中引用Pillar数据。&lt;/p&gt;
&lt;p&gt;比如，在上一节的第一个问题中，我们可以这样定义State:&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;apache:
    pkg.installed:
      - name: {{ pillar['apache'] }}&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;salt.states.pkg.installed&lt;/code&gt;函数的&lt;code&gt;name&lt;/code&gt;参数就是引用了Pillar中定义的变量&lt;code&gt;apache&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而该变量在Pillar中的定义如下：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p _="%" endif&gt;{ % if grains['os_family'] == 'RedHat' % }
apache: httpd
{ % elif grains['os_family'] == 'Debian' % }
apache: apache2&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;Pillar的配置结构&lt;/h1&gt;
&lt;p&gt;Pillar与State就像是配置管理的左右手，所以Pillar的配置结构与&lt;a href="/2013/07/02/salt_state_config_structure.html"&gt;State的配置结构&lt;/a&gt;几乎完全一样。&lt;/p&gt;
&lt;h2&gt;Pillar Tree和Environment&lt;/h2&gt;
&lt;p&gt;与&lt;a href="/2013/07/02/salt_state_config_structure.html#menuIndex0"&gt;State Tree&lt;/a&gt;一样，Salt中可以定义一棵Pillar Tree，并且将Pillar按照环境进行分组管理。&lt;/p&gt;
&lt;p&gt;Pillar Tree定义在salt master的配置文件&lt;code&gt;/etc/salt/master&lt;/code&gt;的&lt;code&gt;pillar_roots&lt;/code&gt;变量中：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;pillar_roots:
   base:
     - /srv/pillar&lt;/p&gt;
&lt;p&gt;ext_pillar:
     - hiera: /etc/hiera.yaml
     - cmd_yaml: cat /etc/salt/yaml&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h2&gt;Pillar定义&lt;/h2&gt;
&lt;p&gt;Pillar是一组key-value，使用yaml的语法格式。&lt;/p&gt;
&lt;p&gt;简单的定义比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以使用&lt;code&gt;{ { pillar['foo'] } }&lt;/code&gt;的形式进行引用；&lt;/p&gt;
&lt;p&gt;复杂的定义比如：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}
users:
  thatch: 1000
  shouse: 1001
  utahdave: 1002
  redbeard: 1003&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;可以使用包含jinja语法的yaml进行引用：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p _="%" endfor&gt;{ % for user, uid in pillar.get('users', {}).items() % }
   { {user} }:
     user.present:
       - uid: { {uid} }&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;定义好的pillar数据保存在Pillar Tree下面的某个&lt;code&gt;sls&lt;/code&gt;文件中。为了能够在State中引用Pillar数据，
Pillar的目录结构和文件名需要与State能够对应。&lt;/p&gt;
&lt;p&gt;Pillar可以用于任何数据的定义，比如ssh key、证书、密码口令等敏感数据，minion的模块、状态、信息反馈，以及要传递给minion的任何变量的值等等。
这些数据都会以加密通道安全的分发到minion上面。&lt;/p&gt;
&lt;p&gt;Pillar的数据不仅仅可以来自SLS文件，还可以从其他数据源获取数据。相关内容可以自行查阅&lt;a href="http://docs.saltstack.com/topics/pillar/index.html"&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;minion与Pillar之间的映射&lt;/h2&gt;
&lt;p&gt;与&lt;a href="/2013/07/02/salt_state_config_structure.html#menuIndex2"&gt;minion与state之间的映射&lt;/a&gt;一样，
在Pillar的base目录中也存在一个名为&lt;code&gt;top.sls&lt;/code&gt;的入口文件，定义minion与Pillar的映射关系，例如：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;base:
  '*':
    - packages
  'alpha':
    - database&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;上边的例子定义了packages对所有的minion有效，database只对名字为'alpha'的minion有效.&lt;/p&gt;
&lt;h1&gt;Pillar数据的查询和使用&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;查询pillar数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
    salt 'client2' pillar.data
    salt '&lt;em&gt;' pillar.data
    salt '&lt;/em&gt;' pillar.raw key='roles'&lt;/p&gt;
&lt;p&gt;更多的函数可以参考&lt;a href="https://salt.readthedocs.org/en/latest/ref/modules/all/salt.modules.pillar.html"&gt;pillar模块的文档&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刷新pillar数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在master上修改Pilla文件后，需要用以下命令刷新minion上的数据（同步到minion）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   salt &amp;#39;*&amp;#39; saltutil.refresh_pillar
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;在其他sls文件中引用数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pillar解析后是dict对象，直接使用Python语法，可以用索引（&lt;code&gt;pillar['pkgs']['apache']&lt;/code&gt;）或get方法（&lt;code&gt;pillar.get('users', {})&lt;/code&gt;）获取到需要的数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Targetting中使用Pillar&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Targetting中可以用&lt;code&gt;-I&lt;/code&gt;选项指定用Pillar数据选择minion。&lt;/p&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/topics/tutorials/pillar.html"&gt;《Pillar Walkthrough》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/topics/pillar/index.html"&gt;《Pillar of Salt》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="运维"></category></entry><entry><title>lvs+nginx的负载均衡实验</title><link href="http://holbrook.github.io/2013/07/01/lvs_nginx_practice.html" rel="alternate"></link><published>2013-07-01T00:00:00+08:00</published><updated>2013-07-01T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-07-01:/2013/07/01/lvs_nginx_practice.html</id><summary type="html">&lt;p&gt;LVS+NginX是构建大型B/S应用的典型方式。本文记录在实验环境搭建这样一个架构，并进行功能、可靠性、性能等方面的测试的过程。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;准备环境&lt;/h1&gt;
&lt;p&gt;2 LVS(cluster) + 2 NginX
（图）&lt;/p&gt;
&lt;h1&gt;配置&lt;/h1&gt;
&lt;h2&gt;LVS服务器配置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装软件包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pulse: LVS守护进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;piranha: LVS的web管理工具，包括状态监控和配置&lt;/li&gt;
&lt;/ol&gt;
&lt;p _="%" endhighlight&gt;{% highlight bash %}
yum install pulse piranha&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开IP转发功能（ip_forward）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;中设置&lt;code&gt;net.ipv4.ip_forward = 1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/sbin/sysctl -w net.ipv4.ip_forward=1&lt;/code&gt; 或者&lt;code&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看状态：&lt;code&gt;/sbin/sysctl net.ipv4.ip_forward&lt;/code&gt; 或者&lt;code&gt;cat /proc/sys/net/ipv4/ip_forward&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置LVS&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置文件位于&lt;code&gt;/etc/sysconfig/ha/lvs.cf&lt;/code&gt;，使用piranha可以以图形界面的方式进行配置。&lt;/p&gt;
&lt;p&gt;{% highlight bash %}
 # 设置管理密码
 piranha-passwd&lt;/p&gt;
&lt;p&gt;# 启动piranha服务
 /etc/init.d/piranha-gui start&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;接下来可以用浏览器访问: http://IP_OF_LVS:3636（记得配置LVS上的防火墙，否则只能本机访问）。&lt;/p&gt;
&lt;p&gt;点击"Login"按钮，使用用户名&lt;code&gt;piranha&lt;/code&gt;和刚才设置的密码登录，可以看到管理界面：&lt;/p&gt;
&lt;p&gt;&lt;img alt="1" src="images/2013/lvs_nginx_practice/piranha1.png"&gt;&lt;/p&gt;
&lt;p&gt;依次配置全局设置(GLOBAL SETTINGS), 备机设置(REDUNDANCY, 可选)，虚拟服务器(VIRTUAL SERVERS)，即可。&lt;/p&gt;
&lt;p&gt;其中虚拟服务器可以配置基本信息(VIRTUAL SERVER)、真实服务器(REAL SERVER)和监控脚本(MONITORING SCRIPTS)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动服务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置完成后，启动lvs服务(&lt;code&gt;/etc/init.d/pulse start&lt;/code&gt;)，在监控界面(CONTROL/MONITORING)可以看到"Daemon"的状态为"running"。&lt;/p&gt;
&lt;p&gt;如果要设置pulse为开机自动启动，可以使用命令：&lt;code&gt;/sbin/chkconfig --level35 pulse on&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;RS（Real Server，真实服务器）配置&lt;/h2&gt;
&lt;p&gt;这里使用nginx作为Real Server，参考&lt;a href="http://thinkinside.tk/2013/05/27/nginx_keepalived.html"&gt;这篇文章&lt;/a&gt;进行最简单的配置，能够看到nginx默认的欢迎界面即可。&lt;/p&gt;
&lt;p&gt;RS需要进行一系列的设置才能与LVS协同工作，参考如下脚本：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;h1&gt;!/bin/bash&lt;/h1&gt;
&lt;p&gt;VIP=VIP_OF_LVS&lt;/p&gt;
&lt;p&gt;/sbin/ifconfig lo:0 $VIP broadcast $VIP netmask 255.255.255.255 up&lt;/p&gt;
&lt;p&gt;/sbin/route add -host $VIP dev lo:0&lt;/p&gt;
&lt;p&gt;echo "1" &amp;gt;/proc/sys/net/ipv4/conf/lo/arp_ignore&lt;/p&gt;
&lt;p&gt;echo "2" &amp;gt;/proc/sys/net/ipv4/conf/lo/arp_announce&lt;/p&gt;
&lt;p&gt;echo "1" &amp;gt;/proc/sys/net/ipv4/conf/all/arp_ignore&lt;/p&gt;
&lt;p&gt;echo "2" &amp;gt;/proc/sys/net/ipv4/conf/all/arp_announce&lt;/p&gt;
&lt;p&gt;sysctl -p&lt;/p&gt;
&lt;p&gt;/sbin/service iptables stop&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h2&gt;启动LVS服务&lt;/h2&gt;
&lt;p&gt;LVS和RS都配置好之后，可以启动LVS服务。前面提到，pulse是LVS的守护进程(Daemon)。使用如下的命令启动LVS：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/etc/init.d/pulse start
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;命令行工具：ipvsadm&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ipvsadm&lt;/code&gt;是LVS的命令行管理工具，可以用于更改运行时状态或更改配置文件。主要功能包括：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 增加/编辑虚拟服务器（VS）
 ipvsadm -A|E -t|u|f virutal-service-address:port [-s scheduler] [-p [timeout]] [-M netmask]&lt;/p&gt;
&lt;p&gt;# 删除虚拟服务器
 ipvsadm -D -t|u|f virtual-service-address&lt;/p&gt;
&lt;p&gt;# 清除内核虚拟服务器表中的所有记录。
 ipvsadm -C&lt;/p&gt;
&lt;p&gt;# 放弃内存中的修改，读取配置文件
 ipvsadm -R&lt;/p&gt;
&lt;p&gt;# 将内存中的修改保存为配置文件
 ipvsadm -S [-n]&lt;/p&gt;
&lt;p&gt;# 增加/编辑真实服务器（RS）
 ipvsadm -a|e -t|u|f service-address:port -r real-server-address:port&lt;/p&gt;
&lt;p&gt;# 删除真实服务器
 ipvsadm -d -t|u|f service-address -r server-address&lt;/p&gt;
&lt;p&gt;# 显示虚拟服务器表
 ipvsadm -L|l [options]&lt;/p&gt;
&lt;p&gt;# 虚拟服务表计数器清零（清空当前的连接数量等）
 ipvsadm -Z [-t|u|f service-address]&lt;/p&gt;
&lt;p&gt;# 设置连接超时值
 ipvsadm –set tcp tcpfin udp&lt;/p&gt;
&lt;p&gt;# 启动守护进程, 可以是master或backup方式
 ipvsadm –start-daemon state [--mcast-interface interface]&lt;/p&gt;
&lt;p&gt;# 停止守护进程
 ipvsadm –stop-daemon&lt;/p&gt;
&lt;p&gt;# 查看帮助
 ipvsadm -h&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;功能验证&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;检查LVS启动过程： &lt;code&gt;tail -f /var/log/messages&lt;/code&gt;，可以看到虚拟服务启动、连接到各个真实服务器等记录。&lt;/li&gt;
&lt;li&gt;将两台真实服务器的nginx欢迎界面（index.html）修改成不同的内容，重复刷新对虚拟服务器的访问，能看到内容变化&lt;/li&gt;
&lt;li&gt;使用命令&lt;code&gt;ipvsadm&lt;/code&gt;检查分流状况&lt;/li&gt;
&lt;li&gt;关闭一台nginx, &lt;code&gt;/var/log/messages&lt;/code&gt;中会记录服务器连接失败，此时通过&lt;code&gt;ipvsadm&lt;/code&gt;检查会发现所有的流量被分流到另一个nginx上面&lt;/li&gt;
&lt;li&gt;重新启动刚才关闭的nginx, &lt;code&gt;/var/log/messages&lt;/code&gt;中会记录服务器连接成功，此时通过&lt;code&gt;ipvsadm&lt;/code&gt;检查会发现恢复了负载分担&lt;/li&gt;
&lt;li&gt;lvs+keepalived的故障切换测试（未测试）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;性能测试&lt;/h1&gt;
&lt;p&gt;使用Apache Bench进行简单的性能测试，得出如下结论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单个nginx的最佳并发：1900，最大并发：2900；使用LVS+2台nginx的最佳并发：3000，最大并发：5900。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;说明通过LVS做负载均衡能提高并发能力，但不是线性增加，会有一定的损失。具体数据需要进一步测试。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;经过LVS访问nginx比直接访问nginx会增加50毫秒左右的响应时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;官方的测试数字是：VS/NAT方式达到1112并发，VS/DR或VS/TUN方式可以达到25,000并发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;F5的并发处理能力超过10万，可以保持的连接数能达到几百万。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="cluster"></category></entry><entry><title>Salt state 配置结构</title><link href="http://holbrook.github.io/2013/07/01/salt_state_config_structure.html" rel="alternate"></link><published>2013-07-01T00:00:00+08:00</published><updated>2013-07-01T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-07-01:/2013/07/01/salt_state_config_structure.html</id><summary type="html">&lt;p&gt;Salt的state配置比较复杂，官方文档也比较零散。初学者不易掌握。但是如果把Salt的state配置看做是编写代码，就很容易掌握其脉络。&lt;/p&gt;</summary><content type="html">&lt;p&gt;配置的目标是通过master管理多个mision的状态，最终配置的实现是使用文件夹和文件。而Salt state的设计就是在二者之间建立逻辑关系。&lt;/p&gt;
&lt;p&gt;Salt的state配置比较复杂，官方文档也比较零散。初学者不易掌握。但是如果把Salt的state配置看做是编写代码，就很容易掌握其脉络。&lt;/p&gt;
&lt;p&gt;下图是Salt state配置结构的逻辑图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="salt_functions" src="images/2013/salt_usage/salt_state_config_structure.png"&gt;&lt;/p&gt;
&lt;p&gt;配置的目标是通过master管理多个mision的状态，最终配置的实现是使用文件夹和文件。而Salt state的设计就是在二者之间建立逻辑关系。&lt;/p&gt;
&lt;h1&gt;StateTree 和 Environment&lt;/h1&gt;
&lt;p&gt;每个master上面都会建立一棵state树，将各个state的配置分级管理。&lt;/p&gt;
&lt;p&gt;这棵树的第一层就是环境（environment)的划分。salt将环境分为base环境和自定义环境。base环境是必须存在的，其他的环境根据自己的需要进行定义。典型的可以划分开发环境(dev), 用户参与测试环境（uat)，生成环境(prod), 备份环境（backup)等等。&lt;/p&gt;
&lt;p&gt;Salt约定base环境必须存在，是其他环境的基础，base环境中定义的state可以在各个自定义环境中使用。&lt;/p&gt;
&lt;p&gt;显然，每个环境至少需要一个文件夹来保持多个state配置。事实上，Salt允许一个环境使用多个文件夹。&lt;/p&gt;
&lt;p&gt;Salt环境与目录的对应关系在salt master的配置文件&lt;code&gt;/etc/salt/master&lt;/code&gt;的&lt;code&gt;file_roots&lt;/code&gt;变量中定义。&lt;code&gt;/etc/salt/master&lt;/code&gt;文件也是使用YAML格式。&lt;/p&gt;
&lt;p&gt;一个典型的配置如下：&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
 file_roots:
   base:
     - /srv/salt/
   dev:
     - /srv/salt/dev/services
     - /srv/salt/dev/states
   prod:
     - /srv/salt/prod/services
     - /srv/salt/prod/states&lt;/p&gt;
&lt;h1&gt;state定义&lt;/h1&gt;
&lt;p&gt;Salt state即可以使用单个的sls文件(single state)，也可以使用一个文件夹并在其中保持多个sls及其他配置文件（multi-state)。&lt;/p&gt;
&lt;p&gt;state之间还可以使用require, include, extend等关系进行关联。&lt;/p&gt;
&lt;h1&gt;minion 与 state之间的映射&lt;/h1&gt;
&lt;p&gt;一个salt master可以管理多个minion, 也可以定义很多个state。需要在minion和state之间建立一种多对多的映射关系。&lt;/p&gt;
&lt;p&gt;Salt在一个&lt;code&gt;top.sls&lt;/code&gt;文件中定义这种映射关系。比如：&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
base:
  '&lt;em&gt;':
    - servers
dev:
  '&lt;/em&gt;nodb*':
    - mongodb&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;按环境的不同划分state的存放目录；定义state文件/文件夹并在state之间使用关系实现复用；建立minion和state之间的多对多映射关系。&lt;/p&gt;
&lt;p&gt;掌握了这三点，就掌握了Salt state配置的脉络。&lt;/p&gt;
&lt;p&gt;实际上，Salt中&lt;a href="/2013/07/07/salt_pillar.html"&gt;Pillar的配置&lt;/a&gt;也使用了类似的结构。&lt;/p&gt;</content><category term="运维"></category></entry><entry><title>Salt state实例解析</title><link href="http://holbrook.github.io/2013/06/30/salt_sls_sample.html" rel="alternate"></link><published>2013-06-30T00:00:00+08:00</published><updated>2013-06-30T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-06-30:/2013/06/30/salt_sls_sample.html</id><summary type="html">&lt;p&gt;在Salt的官方教程中，以apache和sshd的state配置作为例子。掌握这两个例子，就能够触类旁通，处理日常工作中大部分的配置管理问题。
本文对这两个例子进行详细的分析和注释&lt;/p&gt;</summary><content type="html">&lt;p&gt;在Salt的&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/starting_states.html"&gt;官方教程&lt;/a&gt;中，以apache和sshd的state配置作为例子。掌握这两个例子，就能够触类旁通，处理日常工作中大部分的配置管理问题。
本文对这两个例子进行详细的分析和注释。&lt;/p&gt;
&lt;h1&gt;目录结构&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/starting_states.html"&gt;文档&lt;/a&gt;
中的例子包含了多个文件。这些文件之间互相引用和关联。目录结构及文件清单如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;apache/init.sls&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;apache/httpd.conf&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ssh/init.sls&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ssh/server.sls&lt;/li&gt;
&lt;li&gt;ssh/banner&lt;/li&gt;
&lt;li&gt;ssh/ssh_config&lt;/li&gt;
&lt;li&gt;ssh/sshd_config&lt;/li&gt;
&lt;li&gt;ssh/custom-server.sls&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个配置分别放在了&lt;code&gt;apache&lt;/code&gt;和&lt;code&gt;ssh&lt;/code&gt;文件夹。一个Salt状态可以使用单个的SLS文件，或者使用一个文件夹。后者更加灵活方便。&lt;/p&gt;
&lt;h1&gt;apache/init.sls&lt;/h1&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;apache:
    pkg:
      - installed
    service:
      - running
      - watch:
        - pkg: apache
        - file: /etc/httpd/conf/httpd.conf
        - user: apache
    user.present:
      - uid: 87
      - gid: 87
      - home: /var/www/html
      - shell: /bin/nologin
      - require:
        - group: apache
    group.present:
      - gid: 87
      - require:
        - pkg: apache&lt;/p&gt;
&lt;p&gt;/etc/httpd/conf/httpd.conf:
    file.managed:
      - source: salt://apache/httpd.conf
      - user: root
      - group: root
      - mode: 644
      - template: jinja
      - context:
        custom_var: "override"
      - defaults:
        custom_var: "default value"
        other_var: 123&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sls文件使用&lt;a href="http://yaml.org/spec/1.1/"&gt;YAML&lt;/a&gt;格式定义，最外面的层级定义配置项。&lt;/li&gt;
&lt;li&gt;一个sls文件中可以有多个配置项，配置项的ID可以起任意的名字。本例中包含ID为&lt;code&gt;apache&lt;/code&gt;和&lt;code&gt;/etc/httpd/conf/httpd.conf&lt;/code&gt;两个配置项。&lt;/li&gt;
&lt;li&gt;配置项内是一系列的状态声明。所有的状态项来自Salt状态模块。即可以使用&lt;a href="http://docs.saltstack.com/ref/states/all/index.html"&gt;Salt内置的状态模块&lt;/a&gt;，也可以&lt;a href="http://docs.saltstack.com/ref/states/writing.html"&gt;编写自定义的状态模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态声明内部指定状态函数的调用。状态函数是每个Salt状态模块中定义的函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;apache配置项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.pkg.html#module-salt.states.pkg"&gt;pkg模块&lt;/a&gt;，使用操作系统的包管理器(如yum, apt-get)安装软件包&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.pkg.html#salt.states.pkg.installed"&gt;salt.states.pkg.installed函数&lt;/a&gt;, 验证软件包是否安装以及是否为指定的版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.service.html#module-salt.states.service"&gt;service模块&lt;/a&gt;管理服务/守护进程(daemon)的启动或停止&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.service.html#salt.states.service.running"&gt;salt.states.service.running函数&lt;/a&gt;检查服务是否已经启动&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.service.html#module-salt.states.service"&gt;service模块&lt;/a&gt;定义了&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.service.html#salt.states.service.mod_watch"&gt;salt.states.service.mod_watch&lt;/a&gt;函数，可以使用&lt;a href="http://docs.saltstack.com/ref/states/ordering.html#the-watch-requisite"&gt;&lt;code&gt;watch&lt;/code&gt;要素&lt;/a&gt;监控其他的模块是否满足。这里监控以下情况：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apache&lt;/code&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.pkg.html#module-salt.states.pkg"&gt;软件包(pkg)&lt;/a&gt;是否已安装&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/httpd/conf/httpd.conf&lt;/code&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.file.html#module-salt.states.file"&gt;文件(file)&lt;/a&gt;是否存在&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apache&lt;/code&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.user.html#module-salt.states.user"&gt;用户(user)&lt;/a&gt;是否存在&lt;/li&gt;
&lt;li&gt;&lt;code&gt;user.present&lt;/code&gt;是简写形式，直接调用&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.user.html#module-salt.states.user"&gt;&lt;code&gt;user&lt;/code&gt;&lt;/a&gt;模块的&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.user.html#salt.states.user.present"&gt;&lt;code&gt;present&lt;/code&gt;&lt;/a&gt;函数检查是否存在如下属性的&lt;code&gt;apache&lt;/code&gt;用户：&lt;/li&gt;
&lt;li&gt;uid=87&lt;/li&gt;
&lt;li&gt;gid=87&lt;/li&gt;
&lt;li&gt;home目录为&lt;code&gt;/var/www/html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;登录脚本为&lt;code&gt;/bin/nologin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;检查依赖项：&lt;code&gt;apache&lt;/code&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.group.html#module-salt.states.group"&gt;用户组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group.present&lt;/code&gt;是简写形式，直接调用&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.group.html#module-salt.states.group"&gt;&lt;code&gt;group&lt;/code&gt;&lt;/a&gt;模块的&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.group.html#salt.states.group.present"&gt;&lt;code&gt;present&lt;/code&gt;&lt;/a&gt;函数检查是否存在如下属性的&lt;code&gt;apache&lt;/code&gt;用户组：&lt;/li&gt;
&lt;li&gt;gid=87&lt;/li&gt;
&lt;li&gt;检查依赖项：&lt;code&gt;apache&lt;/code&gt;&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.pkg.html#module-salt.states.pkg"&gt;软件包&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/httpd/conf/httpd.conf&lt;/code&gt;配置项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file.managed&lt;/code&gt;是简写形式，直接调用&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.file.html#module-salt.states.file"&gt;file模块&lt;/a&gt;的&lt;a href="http://docs.saltstack.com/ref/states/all/salt.states.file.html#salt.states.file.managed"&gt;managed方法&lt;/a&gt;根据需要从master获取文件并可能会通过模板系统(templating system)进行渲染。文件要满足如下要求：&lt;ol&gt;
&lt;li&gt;使用master上面的apache/httpd.conf文件&lt;/li&gt;
&lt;li&gt;user=root&lt;/li&gt;
&lt;li&gt;group=root&lt;/li&gt;
&lt;li&gt;mode=644&lt;/li&gt;
&lt;li&gt;使用&lt;a href="http://jinja.pocoo.org/"&gt;&lt;code&gt;jinja&lt;/code&gt;&lt;/a&gt;模板渲染&lt;/li&gt;
&lt;li&gt;上下文变量：&lt;/li&gt;
&lt;li&gt;custom_var="override"&lt;/li&gt;
&lt;li&gt;默认值:&lt;/li&gt;
&lt;li&gt;custom_var="default value"&lt;/li&gt;
&lt;li&gt;other_var=123&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;ssh/init.sls&lt;/h1&gt;
&lt;p&gt;{% highlight yaml %}
 openssh-client:
    pkg.installed&lt;/p&gt;
&lt;p&gt;/etc/ssh/ssh_config:
    file.managed:
      - user: root
      - group: root
      - mode: 644
      - source: salt://ssh/ssh_config
      - require:
        - pkg: openssh-client&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;h1&gt;ssh/server.sls&lt;/h1&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;include:
    - ssh&lt;/p&gt;
&lt;p&gt;openssh-server:
   pkg.installed&lt;/p&gt;
&lt;p&gt;sshd:
   service.running:
     - require:
       - pkg: openssh-client
       - pkg: openssh-server
       - file: /etc/ssh/banner
       - file: /etc/ssh/sshd_config&lt;/p&gt;
&lt;p&gt;/etc/ssh/sshd_config:
   file.managed:
     - user: root
     - group: root
     - mode: 644
     - source: salt://ssh/sshd_config
     - require:
       - pkg: openssh-server&lt;/p&gt;
&lt;p&gt;/etc/ssh/banner:
   file:
     - managed
     - user: root
     - group: root
     - mode: 644
     - source: salt://ssh/banner
     - require:
       - pkg: openssh-server&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;include语句将别的state添加到当前文件中，使得state可以跨文件引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用include相当于把被引用的内容文件添加到自身，可以require、watch或extend被引用的SLS中定义的内容。&lt;/p&gt;
&lt;p&gt;这里引用了&lt;code&gt;ssh&lt;/code&gt;state。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;openssh-server&lt;/code&gt;配置项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sshd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;配置项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/ssh/banner&lt;/code&gt;配置项&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ssh/custom-server.sls&lt;/h1&gt;
&lt;p&gt;{% highlight yaml %}
 include:
   - ssh.server&lt;/p&gt;
&lt;p _="%" endhighlight&gt;extend:
   /etc/ssh/banner:
     file:
       - source: salt://ssh/custom-banner&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引用&lt;code&gt;ssh&lt;/code&gt;state的server配置项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extend&lt;/code&gt;可以复用已有的state，在原来的基础上进行扩展，增加新的配置或修改已有的配置。&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;/etc/ssh/banner&lt;/code&gt;配置项的文件修改为&lt;code&gt;salt://ssh/custom-banner&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="运维"></category></entry><entry><title>salt的主要功能及使用</title><link href="http://holbrook.github.io/2013/06/25/salt_usage.html" rel="alternate"></link><published>2013-06-25T00:00:00+08:00</published><updated>2013-06-25T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-06-25:/2013/06/25/salt_usage.html</id><summary type="html">&lt;p&gt;本文介绍Salt的主要功能和基本使用，包括minion节点的管理，批量操作，以及非常重要的配置管理。&lt;/p&gt;</summary><content type="html">&lt;p&gt;掌握了这些内容，可以使用Salt极大提高运维的效率（事实上，Salt对于开发阶段也能提供很大的帮助，开发和运维的界限正在逐渐模糊）。&lt;/p&gt;
&lt;p&gt;&lt;a href="/2013/06/24/salt_intro.html"&gt;Salt的介绍&lt;/a&gt;中提到了Salt支持变更操作、配置管理、状态监控所需的一些功能，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="salt_functions" src="images/2013/salt_usage/salt_functions.png"&gt;&lt;/p&gt;
&lt;p&gt;本文详细介绍如何使用这些功能。&lt;/p&gt;
&lt;p&gt;如果想对Salt的功能和使用有一个初步的了解，最好参考官方文档：&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/walkthrough.html"&gt;Salt Stack Walkthrough&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;批量操作(targeting)&lt;/h1&gt;
&lt;p&gt;再回顾一下&lt;a href="http://thinkinside.tk/2013/06/24/salt_intro.html#测试-ref"&gt;前文中的例子&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 测试连通性
 salt '*' test.ping&lt;/p&gt;
&lt;p&gt;# 查询主机运行了多长时间
 sudo salt '*' cmd.run "uptime"&lt;/p&gt;
&lt;p&gt;# 批量重启服务
 salt '*' cmd.run "service httpd restart"&lt;/p&gt;
&lt;p&gt;# 让多台机器一起，使用Apache Bench进行压力测试
 salt '*' cmd.run "ab -n 10 -c 2 http://www.google.com/"&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;上面的例子都是对多个节点进行批量操作：使用通配符"'*'"对所有注册的节点进行操作。Salt支持多种方式对节点id(minion id)进行匹配。包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认：&lt;a href="http://en.wikipedia.org/wiki/Glob_(programming)"&gt;通配符(globbing)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;E：&lt;a href="http://zh.wikipedia.org/zh-hans/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"&gt;正则表达式(Regular Expression)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;L：列表&lt;/li&gt;
&lt;li&gt;N: 分组(group)&lt;/li&gt;
&lt;li&gt;C：复合匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先看一下通配符、正则表达式和列表的例子：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 通配符是最常用的匹配方式。Salt使用&lt;a href="http://docs.python.org/2/library/fnmatch.html"&gt;linux风格的通配符&lt;/a&gt;
 salt '&lt;em&gt;' test.ping
 salt '&lt;/em&gt;.example.net' test.ping
 salt '&lt;em&gt;.example.&lt;/em&gt;' test.ping
 salt 'web?.example.net' test.ping
 salt 'web[1-5]' test.ping
 salt 'web-[x-z]' test.ping&lt;/p&gt;
&lt;p&gt;# 正则表达式可以适应更复杂的情况。使用&lt;a href="http://docs.python.org/2/library/re.html#module-re"&gt;python的re模块&lt;/a&gt;进行匹配
 salt -E 'web1-(prod|devel)' test.ping&lt;/p&gt;
&lt;p&gt;# 最直接的方式是自己指定多个minion，即列表
 salt -L 'web1,web2,web3' test.ping&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.saltstack.com/topics/targeting/compound.html"&gt;复合匹配(Compound matchers)&lt;/a&gt;有点复杂，后续会在其他文章中专门介绍。&lt;/p&gt;
&lt;p&gt;分组匹配见本文的下一节。&lt;/p&gt;
&lt;h1&gt;节点分组（nodegroups）&lt;/h1&gt;
&lt;p&gt;好吧，批量操作确实很爽。但是每次都输入匹配规则有点麻烦，对于复杂的匹配规则更是如此。
salt的 [nodegroups功能]((http://docs.saltstack.com/topics/targeting/nodegroups.html)可以将常用的匹配规则保存下来（称之为minion的分组）。批量操作是，只需要使用L标记指定要操作的group名字即可。
groups定义在master的配置文件&lt;code&gt;/etc/salt/master&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;group 的定义可以使用各种匹配规则，比如：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;group1: 'L@foo.domain.com, bar.domain.com,baz.domain.com or bl*.domain.com'
group2: 'G@os:Debian and foo.domain.com'&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;同样的，使用复合匹配(Compound matchers)定义group的内容不在本文范围之内。&lt;/p&gt;
&lt;h1&gt;命令编排（execution）&lt;/h1&gt;
&lt;p&gt;Salt生来就有命令编排的功能。据说，Salt最先实现的是远程执行技术，然后才添加的配置管理功能。Salt使用ZeroMQ来处理命令执行的请求和响应消息，安装配置简单，并且性能非常高。&lt;/p&gt;
&lt;p&gt;Salt即可以批量执行命令，也可以单机执行。通常单机执行用于测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单机（立即）执行。 使用&lt;a href="http://docs.saltstack.com/topics/tutorials/quickstart.html"&gt;salt-call&lt;/a&gt;命令单机执行操作&lt;/li&gt;
&lt;li&gt;批量(立即)执行。最常用的操作。使用salt命令，对匹配的minion节点执行操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Salt可以执行的命令也可以分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统命令，使用&lt;code&gt;cmd.run&lt;/code&gt;执行&lt;/li&gt;
&lt;li&gt;Salt模块，将常用的命令/批处理封装到内置的Salt模块(module)，使用&lt;code&gt;模块名.功能名&lt;/code&gt;的方式执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 执行系统命令
 salt '*' cmd.run 'hostname'&lt;/p&gt;
&lt;p&gt;# 执行Salt模块
 salt '*' disk.usage&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;使用Salt模块的好处是能够做到一致。比如同样是查看磁盘使用情况，&lt;code&gt;salt '*' cmd.run "df -h"&lt;/code&gt;只能用于&lt;em&gt;NIX节点，而&lt;code&gt;salt '*' disk.usage&lt;/code&gt;对&lt;/em&gt;NIX和Windows都适用，并且采用相同结构返回数据，便于批量处理。&lt;/p&gt;
&lt;p&gt;Salt已经内置了&lt;a href="http://docs.saltstack.com/ref/modules/all/index.html"&gt;大量的模块&lt;/a&gt;，这些模块涵盖了日常管理任务的主要任务，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用的管理任务，比如apt, at, cp, cron, disk, extfs, file, grains, hosts, iptables, mount, network, pam, parted, pkg, ps, selinux, shadow, ssh, test等&lt;/li&gt;
&lt;li&gt;针对特定软件的任务，比如apache, cassandra, djangomod, git, mongodb, mysql, nginx, nova, postgres, solr, sqlite3, 和tomcat&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且，自己开发Salt模块也非常简单，很容易将实际管理操作中的一些经验通过自定义的模块固化下来，并方便分享。&lt;/p&gt;
&lt;p&gt;在开发和调试模块的时候，可以使用&lt;code&gt;test=True&lt;/code&gt;参数进行模拟执行(Dry run)。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;salt &amp;#39;minion1.example.com&amp;#39; state.highstate -v test=True
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;节点信息(grains)&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://docs.saltstack.com/topics/targeting/grains.html"&gt;grains&lt;/a&gt;是Salt内置的一个非常有用的模块。在用salt进行管理客户端的时候或者写state的时候都可以引用grains的变量。&lt;/p&gt;
&lt;p&gt;grains的基本使用举例如下：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 查看grains分类
 salt '*' grains.ls&lt;/p&gt;
&lt;p&gt;# 查看grains所有信息
 salt '*' grains.items&lt;/p&gt;
&lt;p&gt;# 查看grains某个信息
 salt '*' grains.item osrelease&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;配置管理（state)&lt;/h1&gt;
&lt;p&gt;配置管理是Salt中非常重要的内容之一。Salt通过内置的state模块支持配置管理所需的功能。关于这部分内容，官方文档有很详细的描述，可以参考
&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/states_pt1.html"&gt;part 1&lt;/a&gt;，
&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/states_pt2.html"&gt;part 2&lt;/a&gt;和
&lt;a href="http://salt.readthedocs.org/en/latest/topics/tutorials/states_pt3.html"&gt;part 3&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Salt中可以定义节点的目标状态，称之为state。state对应配置管理中的配置，可以对其进行标识、变更控制、变更识别、状态报告、跟踪和归档以及审计等一些的管理行为。&lt;/p&gt;
&lt;h2&gt;状态描述&lt;/h2&gt;
&lt;p&gt;Salt使用SLS文件（SaLt State file）描述状态。SLS使用&lt;a href="http://yaml.org/spec/1.1/"&gt;YAML&lt;/a&gt;格式进行数据序列化，因此简单明了，可读性也很高。&lt;/p&gt;
&lt;h3&gt;基本描述(yaml)&lt;/h3&gt;
&lt;p&gt;下边是一个简单的SLS文件例子:&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;apache:
   pkg:
     - installed
   service:
     - running
     - require:
       - pkg: apache&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;该文件描述一个ID为&lt;code&gt;apache&lt;/code&gt;的配置状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件包（pkg)已经安装&lt;/li&gt;
&lt;li&gt;服务应该处于运行中&lt;/li&gt;
&lt;li&gt;服务的运行依赖于&lt;code&gt;apache&lt;/code&gt;软件包的安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;state文件中的所有YAML变量名来自Salt的state模块。&lt;/p&gt;
&lt;p&gt;Salt内置了大量的state模块，比如cron, cmd, file, group, host, mount, pkg, service, ssh_auth，user等。
详细清单参考&lt;a href="http://docs.saltstack.com/ref/states/all/index.html"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;还可以开发自己的state模块。&lt;/p&gt;
&lt;h3&gt;扩展描述(jinja)&lt;/h3&gt;
&lt;p&gt;state可以使用&lt;a href="http://jinja.pocoo.org/"&gt;jinja&lt;/a&gt;模板引擎进行扩展，其语法可以参考&lt;a href="http://jinja.pocoo.org/docs/templates/"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面是一个更复杂的例子：&lt;/p&gt;
&lt;p&gt;{% highlight html+jinja %}&lt;/p&gt;
&lt;p&gt;vim:
  pkg:
    { % if grains['os_family'] == 'RedHat' % }
    - name: vim-enhanced
    { % elif grains['os'] == 'Debian' % }
    - name: vim-nox
    { % elif grains['os'] == 'Ubuntu' % }
    - name: vim-nox
    { % endif % }
    - installed&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;该state增加了判断逻辑：如果是redhard系列的就安装 vim-enhanced，如果系统是Debian或者Ubuntu就安装vim-nox。&lt;/p&gt;
&lt;h3&gt;逻辑关系&lt;/h3&gt;
&lt;p&gt;state之间可以有&lt;a href="http://docs.saltstack.com/ref/states/ordering.html"&gt;逻辑关系&lt;/a&gt;。常见的关系举例如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;require：依赖某个state，在运行此state前，先运行依赖的state，依赖可以有多个&lt;/li&gt;
&lt;/ul&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
 httpd:
   pkg:
     - installed
   file.managed:
     - name: /etc/httpd/conf/httpd.conf
     - source: salt://httpd/httpd.conf
     - require:
       - pkg: httpd&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;watch：在某个state变化时运行此模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
redis:
  pkg:
    - latest
  file.managed:
    - source: salt://redis/redis.conf
    - name: /etc/redis.conf
    - require:
      - pkg: redis
    service.running:
      - enable: True
      - watch:
      - file: /etc/redis.conf
      - pkg: redis&lt;/p&gt;
&lt;p&gt;watch除具备require功能外，还增了关注状态的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;order：优先级比require和watch低，有order指定的state比没有order指定的优先级高&lt;/li&gt;
&lt;/ul&gt;
&lt;p _="%" endhighlight&gt;{% highlight yaml %}
vim:
  pkg.installed:
    - order: 1&lt;/p&gt;
&lt;p&gt;想让某个state最后一个运行，可以用last&lt;/p&gt;
&lt;h2&gt;保存状态&lt;/h2&gt;
&lt;p&gt;状态描述文件(SLS)要保存在master节点中，并通过指令分发到minion节点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路径设置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Salt master的配置文件(&lt;code&gt;/etc/salt/master&lt;/code&gt;)中可以通过&lt;code&gt;file_roots&lt;/code&gt;参数指定状态文件的保存路径。可以为不同的环境（如开发环境、UAT环境、生产环境、灾备环境等）分别指定路径，如下所示：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;file_roots:
  base:
    - /srv/salt/
  dev:
    - /srv/salt/dev/services
    - /srv/salt/dev/states
  prod:
    - /srv/salt/prod/services
    - /srv/salt/prod/states&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;其中,base环境是必须的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;入口文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;file_roots&lt;/code&gt;中必须指定“base”环境的路径，因为该路径中存在Salt state的&lt;a href="http://docs.saltstack.com/ref/states/highstate.html"&gt;入口文件: top.sls&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Top文件建立配置环境、节点和状态配置之间的映射关系。比如一个简单的top.sls文件：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;base:
  '&lt;em&gt;':
    - servers
dev:
  '&lt;/em&gt;nodb*':
    - mongodb&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;该文件指定了：
- 所有节点使用base环境的servers配置
- &lt;em&gt;nodb&lt;/em&gt;节点使用dev环境的mongodb配置&lt;/p&gt;
&lt;p&gt;结合第一部分的file_roots配置，该top配置意味存在以下的配置文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/srv/salt/servers.sls&lt;/li&gt;
&lt;li&gt;/srv/salt/dev/mongodb.sls&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：这里也可以使用文件夹&lt;code&gt;/srv/salt/servers/&lt;/code&gt;和&lt;code&gt;/srv/salt/dev/mongodb/&lt;/code&gt;，在文件夹中放置一组状态文件和配置文件，便于建立复杂的状态配置。&lt;/p&gt;
&lt;p&gt;top.sls中的可配置内容非常丰富，具体内容可以参考&lt;a href="http://docs.saltstack.com/ref/states/highstate.html"&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;状态生效（State Enforcement）&lt;/h2&gt;
&lt;p&gt;master上对状态进行定义，最终这些状态要传递到minion节点上。在本节的例子中，如果定义好了状态文件&lt;code&gt;/srv/salt/dev/mongodb.sls&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;{% highlight yaml %}&lt;/p&gt;
&lt;p&gt;mongodb:
  pkg:
    - installed&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;可以使用命令&lt;code&gt;salt "minion1" state.highstate -v&lt;/code&gt;使得所有针对"minion1"的state生效；&lt;/p&gt;
&lt;p&gt;在执行状态之前先进行测试是个好主意，需要指定参数&lt;code&gt;test=True&lt;/code&gt;。比如，&lt;code&gt;salt "minion1" state.highstate -v test=True&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;关于state模块的更多用法，可以参考&lt;a href="https://salt.readthedocs.org/en/latest/ref/modules/all/salt.modules.state.html"&gt;state模块说明&lt;/a&gt;，或&lt;a href="http://docs.saltstack.com/ref/states/index.html#state-enforcement"&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;更多&lt;/h2&gt;
&lt;p&gt;Salt的state模块的功能不仅如此，还可以使用模板和变量，以及定义状态的定时自动生效。&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;本文介绍Salt的主要功能和基本使用，包括minion节点的管理，批量操作，以及非常重要的配置管理。
掌握了这些内容，可以使用Salt极大提高运维的效率（事实上，Salt对于开发阶段也能提供很大的帮助，开发和运维的界限正在逐渐模糊）。&lt;/p&gt;
&lt;p&gt;后续会介绍一些使用案例以及Salt的高级功能。&lt;/p&gt;</content><category term="运维"></category></entry><entry><title>用salt管理成千上万的服务器</title><link href="http://holbrook.github.io/2013/06/24/salt_intro.html" rel="alternate"></link><published>2013-06-24T00:00:00+08:00</published><updated>2013-06-24T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-06-24:/2013/06/24/salt_intro.html</id><summary type="html">&lt;p&gt;实在是厌倦了对大量服务器日复一日的重复操作。尤其是在虚拟化的时代，系统的每个组件都有很多个相同的节点在运行，更让重复的次数再乘以N。
当我发现Salt的时候，我的眼前一亮：这正是我所需要的东西。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;引言：一个”非专职运维人员“的烦恼&lt;/h1&gt;
&lt;p&gt;加入到某证券公司的IT部门，尽管所在的部门挂了一个“研发部”的名字，但是我发现有大概40%的时间是在做运维工作。&lt;/p&gt;
&lt;p&gt;这来自两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自主开发的应用，需要持续的改进，不断的更新、发布、部署、调整配置，这不是运维部门喜欢的状态。&lt;/li&gt;
&lt;li&gt;软件商提供的“产品”无法满足运维部门的要求：无法通过简单的 &lt;a href="http://en.wikipedia.org/wiki/Q%26A"&gt;Q&amp;amp;A&lt;/a&gt; 文档保证系统的正常运行，经常需要有一定技术能力的人员解决系统运行过程中各种稀奇古怪的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种情况下只能自己做一个“非专职运维人员”，需要频繁的登录各种服务器，执行一些命令来查看状态或者更改配置（包括配置文件的变更和软件包的安装部署）。很多操作都是不断的重复，日复一日，让人厌烦。&lt;/p&gt;
&lt;p&gt;”重复的工作应该交给程序去做“，所以我自己写过一些脚本。为了避免将脚本上传到几十台服务器并且不时进行更改，我使用&lt;a href="https://github.com/fabric/fabric"&gt;Fabric&lt;/a&gt;来进行服务器的批量操作。&lt;/p&gt;
&lt;p&gt;尽管避免了”批量的人工操作“，但我还是在进行”人工的批量操作“。远远没有实现自动管理。将有限的生命解放出来，投入到更有意义的编码工作是一个奔四程序员应有的追求，所以我又睁大红肿的眼睛，迷茫的搜索这个世界。&lt;/p&gt;
&lt;p&gt;我发现了&lt;a href="https://puppetlabs.com/"&gt;Puppet&lt;/a&gt;，&lt;a href=""&gt;Chef&lt;/a&gt;和&lt;a href=""&gt;CFEngine&lt;/a&gt;，但是并不满意。直到我发现了&lt;a href="http://saltstack.org/"&gt;Salt&lt;/a&gt;,我的眼前一亮：这正是我所需要的东西。&lt;/p&gt;
&lt;p&gt;如果说Salt有什么独特之处打动了我，那就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单：可能是源于python的简约精神，Salt的安装配置和使用简单到了令人发指的地步。任何稍有经验的linux使用者可以在10分钟之内搭建一个测试环境并跑通一个例子（相比之下，puppet可能需要30--60分钟）。&lt;/li&gt;
&lt;li&gt;高性能：Salt使用大名鼎鼎的&lt;a href="/2013/07/03/zeromq_intro.html"&gt;ZeroMQ&lt;/a&gt;作为通讯协议，性能极高。可以在数秒钟之内完成数据的传递&lt;/li&gt;
&lt;li&gt;可伸缩：基于&lt;a href="/2013/07/03/zeromq_intro.html"&gt;ZeroMQ&lt;/a&gt;通信，具备很强的扩展性；可以进行分级管理，能够管理分布在广域网的上万台服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管&lt;a href="http://www.twitter.com"&gt;twitter&lt;/a&gt;、&lt;a href="http://www.douban.com/"&gt;豆瓣&lt;/a&gt;、&lt;a href="http://www.oracle.com"&gt;oracle&lt;/a&gt;、等著名网站的运维团队都在使用puppet，但是我相信，他们切换到salt只是一个时间问题。毕竟不是所有的人都喜欢操纵傀儡(puppet)，但是谁又能离开盐(salt)呢？&lt;/p&gt;
&lt;p&gt;关于Salt和Puppet的对比，可以参考&lt;a href="http://www.opencredo.com/blog/a-dive-into-salt-stack"&gt;这里&lt;/a&gt;，或者看看&lt;a href="http://wiki.saltstack.cn/reproduction/dive-into-saltstack"&gt;中文版&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;Salt快速入门&lt;/h1&gt;
&lt;p&gt;Salt的体系结构中将节点区分为: master, minion, syndic。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master: 老大，管理端&lt;/li&gt;
&lt;li&gt;minion: 马仔，被管理端&lt;/li&gt;
&lt;li&gt;syndic: 头目，对于老大来说是马仔，对于马仔来说是老大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在入门阶段，先不考虑syndic。&lt;/p&gt;
&lt;h2&gt;安装配置&lt;/h2&gt;
&lt;p&gt;如果将操作系统区分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;*NIX&lt;/li&gt;
&lt;li&gt;Linux&lt;/li&gt;
&lt;li&gt;Solaris&lt;/li&gt;
&lt;li&gt;HP Unix&lt;/li&gt;
&lt;li&gt;FreeBSD&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS X&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;windows&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理论上来说，Salt可以安装在任何*NIX系统上，包括master和minion。除了&lt;a href="https://github.com/saltstack/salt"&gt;源代码&lt;/a&gt;之外，
还可以通过Salt提供的&lt;a href="https://github.com/saltstack/salt-bootstrap"&gt;安装脚本&lt;/a&gt;，或者&lt;a href="https://pypi.python.org/pypi/salt"&gt;PyPI&lt;/a&gt;进行安装。&lt;/p&gt;
&lt;p&gt;对于Linux，尤其是企业环境中常用的RHEL,CentOS,Ubuntu，可以通过包管理器非常容易的安装master 和/或 minion。
比如: yum(需要先配置&lt;a href="http://fedoraproject.org/wiki/EPEL/zh-cn"&gt;EPEL&lt;/a&gt;), apt(需要增加&lt;code&gt;http://debian.madduck.net/repo/&lt;/code&gt;库)，yaourt，ports。&lt;/p&gt;
&lt;p&gt;Mac OS X 先使用HomeBrew解决依赖包：&lt;code&gt;brew install swig zmq&lt;/code&gt;，然后用PyPI安装：&lt;code&gt;pip install salt&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于windows，只能安装minion（windows只适合做马仔）。从&lt;a href="http://saltstack.com/downloads/"&gt;官方网站&lt;/a&gt;下载合适的安装包。安装过程中可以指定master地址和本机名称。
安装后需要自己启动Salt服务。配置文件在C:\salt\conf\minion。&lt;/p&gt;
&lt;p&gt;具体的各操作系统下的安装可以参考&lt;a href="http://docs.saltstack.com/topics/installation/index.html"&gt;官方文档&lt;/a&gt;。这里为了简单，只考虑常用的RHEL/CentOS 和 windows。 在下面的例子中，使用一台RHEL/CentOS作为master， 另外一台RHEL/CentOS和一台windows 2003 Server作为 minion。&lt;/p&gt;
&lt;h3&gt;安装管理端(master)&lt;/h3&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 安装EPEL,注意选择合适的版本
 rpm -ivh http://mirrors.sohu.com/fedora-epel/6/x86_64/epel-release-6-8.noarch.rpm
 yum update&lt;/p&gt;
&lt;p&gt;# 安装master
 yum install salt-master&lt;/p&gt;
&lt;p&gt;# 修改配置
 vim /etc/salt/master&lt;/p&gt;
&lt;p&gt;# 最基本的设定服务端监听的IP(比如使用VIP做master的高可用时)：
 # interface: 服务端监听IP
 # 其他配置参考&lt;a href="http://docs.saltstack.com/ref/configuration/master.html"&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;# 启动服务(以下命令等效)
 salt-master -d
 /etc/init.d/salt-master start
 service salt-master start&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h3&gt;安装被管理端(minion)&lt;/h3&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 安装EPEL,注意选择合适的版本
 rpm -ivh http://mirrors.sohu.com/fedora-epel/6/x86_64/epel-release-6-8.noarch.rpm
 yum update&lt;/p&gt;
&lt;p&gt;# 安装minion
 yum install salt-minion&lt;/p&gt;
&lt;p&gt;# 修改配置
 vim /etc/salt/minion&lt;/p&gt;
&lt;p&gt;# 最基本的设定是指定master地址，以及本机标识符：
 # master: master的主机名或IP地址
 # id: 本机标识符
 # 其他配置参考&lt;a href="http://docs.saltstack.com/ref/configuration/minion.html"&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;# 启动服务(以下命令等效)
 salt-minion -d
 /etc/init.d/salt-minion start
 service salt-minion start&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h3&gt;接受minion的托管请求&lt;/h3&gt;
&lt;p&gt;minion向master投诚后，还需要master接受才行。这个过程叫做“授信”。&lt;/p&gt;
&lt;p&gt;Salt底层使用公钥-私钥证书来保证通信信道的安全。具体的机制可以参考ZeroMQ的相关内容。Salt已经屏蔽了底层的细节，只需要使用封装好的命令：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 在master上运行
 # 查看所有minion
 salt-key -L&lt;/p&gt;
&lt;p&gt;Accepted Keys:
 windows
 bond_app_server_main
 mac_os_vm
 salt-master
 Unaccepted Keys:
 minion1
 minion2
 Rejected Keys:&lt;/p&gt;
&lt;p&gt;#其中Unaccepted Keys是未许可的minion。可以使用下面的命令通过认证：
 salt-key -a minion1&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;安装配置好之后，首先要测试一下联通性：&lt;code&gt;salt '*' test.ping&lt;/code&gt;。salt会列出每个认证过的minion的联通状态(true 或 false)。&lt;/p&gt;
&lt;p&gt;再举一些例子：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;p&gt;# 查询主机运行了多长时间
 sudo salt '*' cmd.run "uptime"&lt;/p&gt;
&lt;p&gt;# 批量重启服务
 salt '*' cmd.run "service httpd restart"&lt;/p&gt;
&lt;p&gt;# 让多台机器一起，使用Apache Bench进行压力测试
 salt '*' cmd.run "ab -n 10 -c 2 http://www.google.com/"&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;注意，默认情况下master和minion之间使用以下端口进行通信：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4505(publish_port): salt的消息发布系统&lt;/li&gt;
&lt;li&gt;4506(ret_port):salt客户端与服务端通信的端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络的设置需要保证这些端口可以访问。&lt;/p&gt;
&lt;h1&gt;Salt的强大功能&lt;/h1&gt;
&lt;p&gt;上面的例子都是用Salt进行批量操作。但是Salt的功能不仅如此。&lt;/p&gt;
&lt;p&gt;认真分析一下我的“非专职运维工作”的内容，发现可以分为以下三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变更操作：根据需要对节点中某个资源的某种状态进行调整，并检验变更的结果&lt;/li&gt;
&lt;li&gt;配置管理：让上述行为变得“可管理”，支持“有关人士”对上述行为的标记、控制、识别、报告、跟踪和归档甚至审批和审计&lt;/li&gt;
&lt;li&gt;状态监控：随时掌握状态，发现异常。尽量在系统用户发现问题之前解决麻烦&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Salt对上述三个方面提供了完美的支持，事实上，Salt提供的功能比我需要的还要多。下图是Salt的主要功能：&lt;/p&gt;
&lt;p&gt;&lt;img alt="salt_functions" src="images/2013/salt_usage/salt_functions.png"&gt;&lt;/p&gt;
&lt;p&gt;具体的功能使用在&lt;a href="/2013/06/25/salt_usage.html"&gt;这篇文章&lt;/a&gt;中详细说明。&lt;/p&gt;
&lt;h1&gt;Salt的网络资源&lt;/h1&gt;
&lt;h2&gt;网站&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://saltstack.org/"&gt;salt官方网站&lt;/a&gt;，&lt;/li&gt;
&lt;li&gt;&lt;a href="http://saltstack.cn/"&gt;中国SaltStack用户组(CSSUG)网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://intothesaltmine.org/blog/html/index.html"&gt;Into The Salt Mine,关于Salt的各种安装、配置、使用的博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack"&gt;saltstack将代码托管在github上&lt;/a&gt;,包括：&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt"&gt;salt主工程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-bootstrap"&gt;salt-bootstrap，一个快速安装Salt的脚本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-states"&gt;salt states参考配置&lt;/a&gt;，大量用于监控目标主机状态的配置文件，可以直接使用&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-cloud"&gt;Salt Cloud&lt;/a&gt;,使得Salt支持各种云服务(Amazon EC2, HP Cloud, OpenStack,Parallels等)的扩展&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salty-vagrant"&gt;salty-vagrant&lt;/a&gt;, 用Salt管理&lt;a href="http://www.vagrantup.com/"&gt;Vagrant虚拟环境&lt;/a&gt;的扩展&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-api"&gt;salt-api&lt;/a&gt;，基于Salt进行二次开发的包&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-ui"&gt;salt-ui&lt;/a&gt;, 一个图形界面&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/pepper"&gt;pepper&lt;/a&gt;, Stand-alone CLI tools that mimic Salt's CLI tools but proxy Salt commands through salt-api &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-contrib"&gt; salt-contrib&lt;/a&gt;, Salt Module Contributions &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/sublime-text"&gt; sublime-text&lt;/a&gt;, Salt-related syntax highlighting and snippets for Sublime Text &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/formulae"&gt; formulae&lt;/a&gt;, &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-vim"&gt; salt-vim&lt;/a&gt;, Vim files for editing Salt files &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-ci"&gt; salt-ci&lt;/a&gt;, Salt-CI — Salt Continuous Integration &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-genesis"&gt; salt-genesis&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt-qa"&gt; salt-qa&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/saltstack_org"&gt; saltstack_org&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/saltstack/salt-windows-install"&gt; salt-windows-install&lt;/a&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/cssug"&gt;中国SaltStack用户组在github上托管的代码&lt;/a&gt;，包括：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/cssug/salt"&gt;salt的一个分支&lt;/a&gt;, 其目标是实现中心库和配置管理功能。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/cssug/salt-dashboard"&gt;salt的web管理界面&lt;/a&gt;，基于Django。&lt;/li&gt;
&lt;/ul&gt;</content><category term="运维"></category></entry><entry><title>用nginX+keepalived实现高可用的负载均衡</title><link href="http://holbrook.github.io/2013/05/27/nginx_keepalived.html" rel="alternate"></link><published>2013-05-27T00:00:00+08:00</published><updated>2013-05-27T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-05-27:/2013/05/27/nginx_keepalived.html</id><summary type="html">&lt;p&gt;实施nginx和keepalived的规划、安装、配置等步骤。&lt;/p&gt;</summary><content type="html">&lt;p&gt;前面的&lt;a href="http://thinkinside.tk/weblayer_nginx_keepalived/"&gt;《统一web访问层方案》&lt;/a&gt;中就目的、目标和整体方案进行了讨论，本文讨论具体的实施。简单来说就是在两台服务器上分别部署NginX，并通过keepalived实现高可用。&lt;/p&gt;
&lt;h1&gt;1 规划和准备&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;需要统一访问的应用系统：
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;应用系统&lt;/th&gt;&lt;th&gt; 域名/虚拟目录&lt;/th&gt;&lt;th&gt;应用服务器及URL&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;svn&lt;/td&gt;&lt;td&gt;  dev.mycompany.com/svn   &lt;/td&gt;&lt;td&gt;http://50.1.1.21/svn&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;svn web管理&lt;/td&gt;&lt;td&gt;    dev.mycompany.com/submin    &lt;/td&gt;&lt;td&gt;http://50.1.1.21/submin&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;网站    &lt;/td&gt;&lt;td&gt;www.mycompany.com  &lt;/td&gt;&lt;td&gt;http://50.1.1.10; http://50.1.1.11; http://50.1.1.12&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;OA&lt;/td&gt;&lt;td&gt;   oa.mycompany.com    &lt;/td&gt;&lt;td&gt;http://50.1.1.13:8080; http://50.1.1.14:8080&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;web访问服务器&lt;/p&gt;
&lt;p&gt;用两台接入服务器50.1.1.3/4分别作为主、备(MASTER、BACKUP)服务器，使用RHEL5.6x64，配置了yum 私服。&lt;/p&gt;
&lt;p&gt;两台接入服务器公用一个虚拟IP（VIP）：50.1.1.2&lt;/p&gt;
&lt;h1&gt;2 安装&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;两台接入服务器分别安装NginX和keepalived:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c1"&gt;#准备依赖包：&lt;/span&gt;
    yum -y install gcc pcre-devel zlib-devel openssl-devel

    &lt;span class="c1"&gt;#下载&lt;/span&gt;
    wget http://nginx.org/download/nginx-1.2.4.tar.gz
    wget http://www.keepalived.org/software/keepalived-1.2.7.tar.gz

    &lt;span class="c1"&gt;#安装NginX&lt;/span&gt;
    tar zxvf nginx-1.2.4.tar.gz
    &lt;span class="nb"&gt;cd&lt;/span&gt; nginx-1.2.4
    ./configure
    make &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install

    &lt;span class="c1"&gt;#安装keepalived&lt;/span&gt;
    tar zxvf keepalived-1.2.7.tar.gz
    &lt;span class="nb"&gt;cd&lt;/span&gt; keepalived-1.2.7
    ./configure
    make
    make install

    cp /usr/local/etc/rc.d/init.d/keepalived /etc/rc.d/init.d/
    cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/
    mkdir /etc/keepalived
    cp /usr/local/etc/keepalived/keepalived.conf /etc/keepalived/
    cp /usr/local/sbin/keepalived /usr/sbin/

    &lt;span class="c1"&gt;#加入启动&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/usr/local/nginx/sbin/nginx&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/rc.local
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/etc/init.d/keepalived start&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/rc.local
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;3 配置&lt;/h1&gt;
&lt;h2&gt;3.1 配置NginX&lt;/h2&gt;
&lt;p&gt;两台接入服务器的NginX的配置完全一样,主要是配置/usr/local/nginx/conf/nginx.conf的http。其中多域名指向是通过虚拟主机（配置http下面的server）实现；同一域名的不同虚拟目录通过每个server下面的不同location实现；到后端的服务器在http下面配置upstream,然后在server或location中通过proxypass引用。要实现前面规划的接入方式，http的配置如下：&lt;/p&gt;
&lt;p&gt;{% highlight c %}
    http {
        include       mime.types;
        default_type  application/octet-stream;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;sendfile&lt;/span&gt;        &lt;span class="nt"&gt;on&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="nt"&gt;upstream&lt;/span&gt; &lt;span class="nt"&gt;dev&lt;/span&gt;&lt;span class="nc"&gt;.hysec.com&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;21&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;


    &lt;span class="nt"&gt;upstream&lt;/span&gt; &lt;span class="nt"&gt;www&lt;/span&gt;&lt;span class="nc"&gt;.hysec.com&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;ip_hash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;11&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;12&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="nt"&gt;upstream&lt;/span&gt; &lt;span class="nt"&gt;oa&lt;/span&gt;&lt;span class="nc"&gt;.hysec.com&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;ip_hash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;13&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;14&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


    &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;listen&lt;/span&gt;      &lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;server_name&lt;/span&gt; &lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;svn&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;submin&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;

    &lt;span class="nt"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;listen&lt;/span&gt;       &lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;server_name&lt;/span&gt;  &lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nt"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;listen&lt;/span&gt;       &lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;server_name&lt;/span&gt;  &lt;span class="n"&gt;oa&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;oa&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hysec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;验证方法：&lt;/p&gt;
&lt;p&gt;首先用IP访问前表中各个应用服务器的url，再用域名和路径访问前表中各个应用系统的域名/虚拟路径&lt;/p&gt;
&lt;h2&gt;3.2 配置keepalived&lt;/h2&gt;
&lt;p&gt;按照上面的安装方法，keepalived的配置文件在/etc/keepalived/keepalived.conf。主、从服务器的配置相关联但有所不同。如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Master配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight c %}&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;! Configuration File for keepalived

global_defs {
notification_email {
        wanghaikuo@hysec.com
        wanghaikuo@gmail.com
   }

   notification_email_from wanghaikuo@hysec.com
   smtp_server smtp.hysec.com
   smtp_connect_timeout 30
   router_id nginx_master

}

vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 101
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        50.1.1.2
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Backup配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight c %}
    ! Configuration File for keepalived&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;global_defs {
notification_email {
        wanghaikuo@hysec.com
        wanghaikuo@gmail.com
   }

   notification_email_from wanghaikuo@hysec.com
   smtp_server smtp.hysec.com
   smtp_connect_timeout 30
   router_id nginx_backup

}

vrrp_instance VI_1 {
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 99
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        50.1.1.2
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先后在主、从服务器上启动keepalived:&lt;/p&gt;
&lt;p&gt;/etc/init.d/keepalived start&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在主服务器上查看是否已经绑定了虚拟IP：&lt;/p&gt;
&lt;p&gt;ip addr&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止主服务器上的keepalived:&lt;/p&gt;
&lt;p&gt;/etc/init.d/keepalived stop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后在从服务器上查看是否已经绑定了虚拟IP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动主服务器上的keepalived，看看主服务器能否重新接管虚拟IP&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;3.3 让keepalived监控NginX的状态&lt;/h2&gt;
&lt;p&gt;经过前面的配置，如果主服务器的keepalived停止服务，从服务器会自动接管VIP对外服务；一旦主服务器的keepalived恢复，会重新接管VIP。 但这并不是我们需要的，我们需要的是当NginX停止服务的时候能够自动切换。&lt;/p&gt;
&lt;p&gt;keepalived支持配置监控脚本，我们可以通过脚本监控NginX的状态，如果状态不正常则进行一系列的操作，最终仍不能恢复NginX则杀掉keepalived，使得从服务器能够接管服务。&lt;/p&gt;
&lt;p&gt;如何监控NginX的状态
最简单的做法是监控NginX进程，更靠谱的做法是检查NginX端口，最靠谱的做法是检查多个url能否获取到页面。&lt;/p&gt;
&lt;p&gt;如何尝试恢复服务
如果发现NginX不正常，重启之。等待3秒再次校验，仍然失败则不再尝试。&lt;/p&gt;
&lt;p&gt;根据上述策略很容易写出监控脚本。这里使用nmap检查nginx端口来判断nginx的状态，记得要首先安装nmap。监控脚本如下:&lt;/p&gt;
&lt;p&gt;{% highlight bash %}&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="c1"&gt;# check nginx server status&lt;/span&gt;
&lt;span class="nv"&gt;NGINX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/nginx/sbin/nginx
&lt;span class="nv"&gt;PORT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;80

nmap localhost -p &lt;span class="nv"&gt;$PORT&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PORT&lt;/span&gt;&lt;span class="s2"&gt;/tcp open&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;#echo $?&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -ne &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nv"&gt;$NGINX&lt;/span&gt; -s stop
    &lt;span class="nv"&gt;$NGINX&lt;/span&gt;
    sleep 3
    nmap localhost -p &lt;span class="nv"&gt;$PORT&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PORT&lt;/span&gt;&lt;span class="s2"&gt;/tcp open&amp;quot;&lt;/span&gt;
    &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -ne &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; /etc/init.d/keepalived stop
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;不要忘了设置脚本的执行权限，否则不起作用。&lt;/p&gt;
&lt;p _="%" c highlight&gt;假设上述脚本放在/opt/chk_nginx.sh，则keepalived.conf中增加如下配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vrrp_script chk_http_port {
    script &amp;quot;/opt/chk_nginx.sh&amp;quot;
    interval 2
    weight 2
}

track_script {
    chk_http_port
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p _="%" c highlight&gt;更进一步，为了避免启动keepalived之前没有启动nginx , 可以在/etc/init.d/keepalived的start中首先启动nginx:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;start() {
    /usr/local/nginx/sbin/nginx
    sleep 3
    echo -n $&amp;quot;Starting &lt;span class="nv"&gt;$prog&lt;/span&gt;: &amp;quot;
    daemon keepalived &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;KEEPALIVED_OPTIONS&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
    RETVAL=$?
    echo
    [ &lt;span class="nv"&gt;$RETVAL&lt;/span&gt; -eq 0 ] &lt;span class="err"&gt;&amp;amp;&amp;amp;&lt;/span&gt; touch /var/lock/subsys/&lt;span class="nv"&gt;$prog&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;4 还可以做什么&lt;/h1&gt;
&lt;p&gt;对于简单重复性劳动，人总是容易犯错，这种事情最好交给机器去做。 比如，在这个案例中，作为统一接入服务器，可能经常要修改nginx的配置、nginx下面的html文件等。而且，一定要保证集群中的每台服务器的配置相同。 最好的做法是由配置管理服务器来管理，如果没有，也可以使用简单的linux文件同步来解决。&lt;/p&gt;
&lt;h1&gt;5 支持https&lt;/h1&gt;
&lt;p&gt;需要安装openSSL：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install openssl-devel
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在nginx/conf下生成秘钥：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}
    #生成RSA密钥
    openssl dsaparam -rand -genkey -out myRSA.key 1024&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#生成CA密钥：(要输入一个自己记得的密码)
openssl gendsa -des3 -out cert.key myRSA.key

#用这个CA密钥来创建证书，需要上一步创建的密码
openssl req -new -x509 -days 365 -key cert.key -out cert.pem

#把证书设置为root专用
chmod 700 cert.*

#生成免密码文件
openssl rsa -in cert.key -out cert.key.unsecure
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;如果要启用SSL，首先在安装nginx是要增加配置参数：--with-http_ssl_module ，
然后在nginx中进行如下配置：&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight c %}
    # 这里是SSL的相关配置
    server {
      listen 443;
      server_name www.example.com; # 你自己的域名
      root /home/www;
      ssl on;
      ssl_certificate cert.perm;
      #使用.unsecure文件可以在nginx启动时不输入密码
      ssl_certificate_key cert.key.unsecure;
      location / {
      #...
      }
    }&lt;/p&gt;
&lt;p&gt;公共证书的申请过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生成RSA(私钥)文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;openssl genrsa -des3 -out myRSA.key 2048&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成csr文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;openssl req -new -key myRSA.key -out my.csr&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将csr提交给证书机构，比如GlobalSign。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;证书机构会返回私有证书(crt)和中级证书（crt）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到机构网站下载根证书（root_CA.cer), 将根证书拼接到私有证书之后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在nginx中配置证书：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;{% highlight c %}
    ssl_certificate /etc/ssl/my.crt;
    ssl_certificate_key /etc/ssl/myRSA.key;
    ssl_client_certificate /etc/ssl/root_CA.cer;&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;6 支持webservice&lt;/h1&gt;
&lt;p&gt;通过chunkin-nginx-module模块支持webservice。&lt;/p&gt;
&lt;p&gt;否则会报错：411：http 头中缺少 Conten-Length 参数&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;{% highlight bash %}
    git clone https://github.com/agentzh/chunkin-nginx-module.git&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#重新编译nginx
cd PATH/TO/NGINX/SOURCE
./configure xxx --add-module=/PATH/TO/chunkin-nginx-module
make &amp;amp;&amp;amp; make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p _="%" c highlight&gt;在nginx的server{}节点中增加配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;chunkin on;

error_page 411 = @my_411_error;

location @my_411_error {
    chunkin_resume;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;h1&gt;7 状态监控&lt;/h1&gt;
&lt;p&gt;编译时需要增加&lt;code&gt;--with-http_stub_status_module&lt;/code&gt;参数。&lt;/p&gt;
&lt;p&gt;查看编译参数：使用命令&lt;code&gt;/usr/local/nginx/sbin/nginx -V&lt;/code&gt;&lt;/p&gt;
&lt;p _="%" highlight nginx&gt;安装好之后增加配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;location /nginx_status {
    stub_status on;
    access_log   off;
    # deny all;
    allow all;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;重新加载配置后，会看到一些文本：&lt;/p&gt;
&lt;p&gt;Active connections: 1 （对后端发起的活动连接数）&lt;/p&gt;
&lt;p&gt;server accepts handled requests&lt;/p&gt;
&lt;p&gt;5 5 5  （处理连接个数，成功握手次数，处理请求数）&lt;/p&gt;
&lt;p&gt;Reading: 0 Writing: 1 Waiting: 0 （读取客户端header数，返回客户端header数，等待数即active-reading-writing）&lt;/p&gt;</content><category term="cluster"></category></entry><entry><title>你真的会数钱吗？</title><link href="http://holbrook.github.io/2013/01/01/money.html" rel="alternate"></link><published>2013-01-01T00:00:00+08:00</published><updated>2013-01-01T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2013-01-01:/2013/01/01/money.html</id><summary type="html">&lt;p&gt;货币，记账相关的领域模型，使用值对象&lt;/p&gt;</summary><content type="html">&lt;hr&gt;
&lt;p&gt;一篇旧的博文，原文发表在&lt;a href="http://www.cnblogs.com/holbrook/archive/2013/01/01/2841307.html"&gt;博客园&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;快年底了，假如你们公司的美国总部给每个人发了一笔201212.21美元的特别奖金，作为程序员的你， 该如何把这笔钱收入囊中？&lt;/p&gt;
&lt;h1&gt;1.美元？美元！&lt;/h1&gt;
&lt;p&gt;你可能觉得，这根本不是问题。在自己的账户中直接加上一笔“转入”就行了。但是首先就遇到了币种的问题。&lt;/p&gt;
&lt;p&gt;一般来说，银行账户都是单币种的。你可能会说不对啊，我的一卡通就能存入不同的币种啊？但那是一个“账号（Account Number）”对应的多个“账户(Account)”。 通常财务记账的时候，一个“账户(Account)”都使用同一币种。&lt;/p&gt;
&lt;p&gt;账户(Account)记录了资金的往来，包含很多条目(Entry)。账户会记录结余，结余等于所有条目中金额的总和。&lt;/p&gt;
&lt;p&gt;我们不可能为每个币种设计一种条目，所以需要抽象出一个货币类——Money，适用于各种不同的币种：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Money类" src="images/posts/domain/money/money.png"&gt;&lt;/p&gt;
&lt;p&gt;Money类至少要记录金额和币种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于金额，由于货币存在最小面额，所以金额的类型可以采用定点小数或者整型。考虑到会对金额进行一些运算，用整数处理应该更方便。如果用java语言实现，可以使用long类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于币种，java提供了java.util.Currency类，专门用于表示货币，符合ISO 4217货币代码标准。Currency使用Singleton模式，需要用getInstance方法获得实例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要的方法包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String getCurrencyCode() 获取货币的ISO 4217货币代码&lt;/li&gt;
&lt;li&gt;int getDefaultFractionDigits() 获取与此货币一起使用的默认小数位数&lt;/li&gt;
&lt;li&gt;static Currency getInstance(Locale locale) 返回给定语言环境的国家/地区的 Currency 实例&lt;/li&gt;
&lt;li&gt;static Currency getInstance(String currencyCode) 返回给定货币代码的 Currency 实例。&lt;/li&gt;
&lt;li&gt;String getSymbol() 获取默认语言环境的货币符号&lt;/li&gt;
&lt;li&gt;String getSymbol(Locale locale) 获取指定语言环境的货币符号&lt;/li&gt;
&lt;li&gt;String toString() 返回此货币的 ISO 4217 货币代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过Currency类的帮助，我们的Money类看起来大概是这个样子(为了方便，提供多种构造函数)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  public class Money {
      private long amount;
      private Currency currency;

      public double getAmount() {
          return BigDecimal.valueOf(amount, currency.getDefaultFractionDigits()).doubleValue();

      }

      public Currency getCurrency() {
          return currency;
      }

      public Money(double amount, Currency currency) {
          this.currency = currency;
          this.amount = Math.round(amount * centFactor());
      }

      public Money(long amount, Currency currency) {
          this.currency = currency;
          this.amount = amount * centFactor();
      }

      private static final int[] cents = new int[] { 1, 10, 100, 1000,10000 };

      private int centFactor() {
          return cents[currency.getDefaultFractionDigits()];
      }
  }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用Money类表示我们的$201212.21奖金，就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Money myMoney = new Money(201212.21,Currency.getInstance(Locale.US));
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;2.存入账户&lt;/h1&gt;
&lt;p&gt;终于解决了币种的问题，可以把钱存入账户了。存入的逻辑是：在条目中记录一笔账目，并计算账户的余额。&lt;/p&gt;
&lt;p&gt;不同币种之间相加或相减是没有意义的，为了避免人为错误，在Money的代码中就要禁止这种操作。我们可以采用抛出异常的方式。 为了简单起见，这里不再定义一个单独的"MoneyException"，而是直接使用java.lang.Exception:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public Money add(Money money) throws Exception{
    if(!money.getCurrency().equals(this.currency)){
        throw(new Exception(&amp;quot;different currency can&amp;#39;t be add&amp;quot;));
    }
    BigDecimal value = this.getAmount().add(money.getAmount());
    Money result = new Money(value.doubleValue(),this.getCurrency());
    return result;
}

public Money minus(Money money) throws Exception{
    if(!money.getCurrency().equals(this.currency)){
        throw(new Exception(&amp;quot;different currency can&amp;#39;t be minus&amp;quot;));
    }

    BigDecimal value =this.getAmount().add(money.getAmount().negate());
    Money result = new Money(value.doubleValue(),this.getCurrency());
    return result;

}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;3.收税&lt;/h1&gt;
&lt;p&gt;先不要高兴得太早，这笔钱属于“一次性所得”，需要交20%的个人所得税。税后所得应该是多少？&lt;/p&gt;
&lt;p&gt;你可能说：是80%。只要为Money加上一个multiply(double factor)方法就可以进行计算了。&lt;/p&gt;
&lt;p&gt;但是牵扯到了舍入的问题。由于货币存在最小单位，在做乘/除法运算的时候就要考虑到舍入的问题了。最好是能够控制舍入的行为。假如税务部门对于 舍入的计算有明确规定，我们也可以做一个遵纪守法的好公民。&lt;/p&gt;
&lt;p&gt;在java.math.BigDecimal中定义了7种舍入模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ROUND_UP：等于远离0的数。&lt;/li&gt;
&lt;li&gt;ROUND_DOWN：等于靠近0的数。&lt;/li&gt;
&lt;li&gt;ROUND_CEILING：等于靠近正无穷的数。&lt;/li&gt;
&lt;li&gt;ROUND_FLOOR：等于靠近负无穷的数。&lt;/li&gt;
&lt;li&gt;ROUND_HALFUP：等于靠近的数，若舍入位为5，应用ROUNDUP。&lt;/li&gt;
&lt;li&gt;ROUND_HALFDOWN：等于靠近的数，若舍入位为5，应用ROUNDDOWN。&lt;/li&gt;
&lt;li&gt;ROUND_HALFEVEN：舍入位前一位为奇数，应用ROUNDHALFUP；舍入位前一位为偶数，应用ROUNDHALFDOWN。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以借用这些模式作为参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public static final int ROUND_UP = BigDecimal.ROUND_UP;
public static final int ROUND_DOWN = BigDecimal.ROUND_DOWN;
public static final int ROUND_CEILING = BigDecimal.ROUND_CEILING;
public static final int ROUND_FLOOR = BigDecimal.ROUND_FLOOR;
public static final int ROUND_HALF_UP = BigDecimal.ROUND_HALF_UP;
public static final int ROUND_HALF_DOWN = BigDecimal.ROUND_HALF_DOWN;
public static final int ROUND_HALF_EVEN = BigDecimal.ROUND_HALF_EVEN;
public static final int ROUND_UNNECESSARY = BigDecimal.ROUND_UNNECESSARY;


public Money multiply(double multiplicand, int roundingMode) {
    BigDecimal amount = this.getAmount().multiply(new BigDecimal(multiplicand));
    amount = amount.divide(BigDecimal.ONE,roundingMode);
    return new Money(amount.doubleValue(),this.getCurrency());
}

public Money divide(double divisor, int roundingMode) {
    BigDecimal amount = this.getAmount().divide(new BigDecimal(divisor),
            roundingMode);
    Money result = new Money(amount.doubleValue(), this.getCurrency());
    return result;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;4.转成人民币&lt;/h1&gt;
&lt;p&gt;尽管各领域的国际化提了十几年，但是在国内想直接用美元消费还是有一定困难。所以你决定将这笔钱换成人民币。&lt;/p&gt;
&lt;p&gt;对于账户来说，就是在美元账户和人民币账户分别做一笔转出和转入。 转入和转出的amount值是不同的，因为涉及到币种转换的问题。 显然，账户对象不应该知道如何进行汇率转换，责任又落在了Money类上。&lt;/p&gt;
&lt;p&gt;最直观的做法是在Money类上增加一个convertTo(Currency currency)的方法。 但汇率实在是一个复杂的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汇率是经常变化的；&lt;/li&gt;
&lt;li&gt;汇率转换时的舍入处理会有相关的约定；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些复杂的问题处理如果直接放在Money类上会显得十分笨重，单独设计一个MoneyConverter类会比较好：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.Currency&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;interface&lt;/span&gt; &lt;span class="n"&gt;MoneyConverter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Money&lt;/span&gt; &lt;span class="n"&gt;convertTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Money&lt;/span&gt; &lt;span class="n"&gt;money&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Currency&lt;/span&gt; &lt;span class="n"&gt;currency&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们实现一个最简单的转化器，使用固定的汇率值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.math.BigDecimal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.Currency&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.Locale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SimpleMoneyConverter&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;MoneyConverter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;BigDecimal&lt;/span&gt; &lt;span class="n"&gt;DOLLAR_TO_CNY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BigDecimal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;6.2365&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Currency&lt;/span&gt; &lt;span class="n"&gt;DOLLAR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Currency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Locale&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;US&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Currency&lt;/span&gt; &lt;span class="n"&gt;CNY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Currency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Locale&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHINA&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Money&lt;/span&gt; &lt;span class="n"&gt;convertTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Money&lt;/span&gt; &lt;span class="n"&gt;money&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Currency&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="n"&gt;known&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;money&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCurrency&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="n"&gt;known&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;
            &lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;unknown currency&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;BigDecimal&lt;/span&gt; &lt;span class="n"&gt;factorSource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;BigDecimal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ONE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;factorTarget&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BigDecimal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ONE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;money&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCurrency&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DOLLAR&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="n"&gt;factorSource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DOLLAR_TO_CNY&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DOLLAR&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="n"&gt;factorTarget&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DOLLAR_TO_CNY&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;BigDecimal&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;money&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getAmount&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;multiply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;factorSource&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;divide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;factorTarget&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Money&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;doubleValue&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;known&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Currency&lt;/span&gt; &lt;span class="n"&gt;currency&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DOLLAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;currency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CNY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，即使是最简单的转换器，处理起来也比较麻烦。所以千万不要在Money类中做这件事情。&lt;/p&gt;
&lt;p&gt;通过转换器可以很容易得到转成人民币后的值。&lt;/p&gt;
&lt;h1&gt;5.分钱&lt;/h1&gt;
&lt;p&gt;有好处不能独享。这笔钱你决定和老婆三七开。当然，你三！&lt;/p&gt;
&lt;p&gt;这又是一个新的舍入问题：即使你指定各自的舍入计算方法，也不能保证各部分舍入后的值加总后仍等于原值。&lt;/p&gt;
&lt;p&gt;前面的“可定制乘除法”似乎不能很好的解决这个问题，所以我们需要一个新的方法： Money[] allocate(double[] ratioes)&lt;/p&gt;
&lt;p&gt;传入分配比例的数组，返回分配结果的数组。&lt;/p&gt;
&lt;p&gt;为了保证分配的公平，可以使用伪随机数来处理误差。&lt;/p&gt;
&lt;p&gt;该方法的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public Money[] allocate(double[] ratioes) throws Exception{
    if(ratioes.length==0){
        throw (new Exception(&amp;quot;there is no ratio&amp;quot;));
    }

    double ratioTotal = 0;
    for(double ratio:ratioes){
        ratioTotal += ratio;
    }

    if(0==ratioTotal){
        throw(new Exception(&amp;quot;total of ratioes is zero&amp;quot;));
    }


    double total = this.getAmount().doubleValue();
    double delta = total;
    Money[] results = new Money[ratioes.length];

    for(int i=0;i&amp;lt;ratioes.length;i++){
        double amount = total*ratioes[i]/ratioTotal;
        results[i] = new Money(amount,this.getCurrency());
        delta -= results[i].getAmount().doubleValue();
    }

    int i = (int)(Math.random() * ratioes.length);
    results[i] = results[i].minus(new Money(delta,this.getCurrency()));
    return results;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;6.记账&lt;/h1&gt;
&lt;p&gt;将一切重要的数据保存到数据库是很通常的做法。但是将Money保存到数据库的时候，你要小心了！&lt;/p&gt;
&lt;p&gt;Money不能作为单独的实体。如果把Money当做实体来处理，就会产生一些问题：&lt;/p&gt;
&lt;p&gt;会有很多实体关联到Money，比如本文中的Account，Entry等。
需要非常小心处理对Money对象的引用，避免多个实体引用到同一个Money对象。在第一点的前提下，这会变得很困难。
所以应该把Money嵌入到需要的实体中，而不是把Money作为单独的实体。这样，Money仅仅是实体对象（比如Entry）的一个属性，只不过其具有多个内置的属性值。&lt;/p&gt;
&lt;p&gt;在JPA中，可以使用@Embeddable来标注Money类。&lt;/p&gt;
&lt;p&gt;更复杂的情况是，由于一个Account中的所有Entry都应该具有相同的Currency，将Currency保存到Account中会更简洁，Entry中只记录ammount。&lt;/p&gt;
&lt;p&gt;可以为Money的currency属性增加@Transient标注，在Entry类的getMoney中进行组装。&lt;/p&gt;
&lt;h1&gt;7.来点高级的&lt;/h1&gt;
&lt;p&gt;在DDD（领域驱动设计）中，Money是典型的值对象（Value Object）。值对象与实体的根本区别是：值对象不需要进行标识（ID）。&lt;/p&gt;
&lt;p&gt;这会带来一些处理上的不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实体对象根据ID判断是否相等，值对象只根据内部属性值判断是否相等&lt;/li&gt;
&lt;li&gt;值对象通常小而且简单，创建的代价较小&lt;/li&gt;
&lt;li&gt;值对象只传递值，不传递对象引用，不用判断值对象是否指向同一个物理对象&lt;/li&gt;
&lt;li&gt;通常将值对象设计为通过构造函数进行属性设置，一旦创建就无法改变其属性值&lt;/li&gt;
&lt;li&gt;由于值对象根据内部属性值判等，我们要为Money类覆盖equals方法： public boolean equals(Object other)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;8.其他未尽事宜&lt;/h1&gt;
&lt;p&gt;我们还可以为Money类增加互相比较的方法（略）&lt;/p&gt;
&lt;p&gt;可以在构造函数中进行格式校验（略）&lt;/p&gt;
&lt;p&gt;可以增加一些帮助显式的方法 使用currency的getSymbol(Locale locale)方法、和NumberFormat的format方法，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;NumberFormat nf=NumberFormat.getCurrencyInstance(Locale.CHINA);

String s=nf.format(73084.803984);// result：￥73,084.80
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;9.小结&lt;/h1&gt;
&lt;p&gt;本文探讨如何在应用中处理货币类型，包括币种转换、各种计算、如何持久化等内容。&lt;/p&gt;
&lt;p&gt;货币类型是典型的值对象，本文也介绍了一点值对象的特点。更多的内容可以参考DDD。&lt;/p&gt;</content><category term="领域模型"></category></entry><entry><title>JPA概要</title><link href="http://holbrook.github.io/2012/12/30/JPA_intro.html" rel="alternate"></link><published>2012-12-30T00:00:00+08:00</published><updated>2012-12-30T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-12-30:/2012/12/30/JPA_intro.html</id><summary type="html">&lt;p&gt;JPA定义了Java ORM及实体操作API的标准。本文摘录了JPA的一些关键信息以备查阅。如果有hibernate的基础，通过本文也可以快速掌握JPA的基本概念及使用。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;1 JPA概述&lt;/h1&gt;
&lt;p&gt;JPA（Java Persistence API，Java持久化API），定义了对象-关系映射（ORM）以及实体对象持久化的标准接口。&lt;/p&gt;
&lt;p&gt;JPA1.0是&lt;a href="https://jcp.org/en/jsr/detail?id=220"&gt;JSR-220&lt;/a&gt;（EJB3.0）规范的一部分，在JSR-220中规定实体对象（EntityBean）由JPA进行支持。&lt;/p&gt;
&lt;p&gt;后来，JPA2.0迁移到&lt;a href="https://jcp.org/en/jsr/detail?id=317"&gt;JSR-317&lt;/a&gt;（Java Persistence 2.0），已经不局限于EJB3.0，而是作为POJO持久化的标准规范，可以脱离容器独立运行，开发和测试更加方便。&lt;/p&gt;
&lt;p&gt;JPA在应用中的位置如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="arcitecture" src="images/jpa/arcitecture.png"&gt;&lt;/p&gt;
&lt;p&gt;JPA维护一个Persistence Context（持久化上下文），在持久化上下文中维护实体的生命周期。主要包含三个方面的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ORM元数据。JPA支持annotion或xml两种形式描述对象-关系映射。&lt;/li&gt;
&lt;li&gt;实体操作API。实现对实体对象的CRUD操作。&lt;/li&gt;
&lt;li&gt;查询语言。约定了面向对象的查询语言JPQL（Java Persistence Query Language）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JPA的主要API都定义在javax.persistence包中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="arcitecture" src="images/jpa/api.png"&gt;&lt;/p&gt;
&lt;p&gt;如果你熟悉Hibernate，可以很容易做出对应：&lt;/p&gt;
&lt;table style="border-collapse: collapse;" border="2" frame="hsides" rules="groups" cellspacing="0" cellpadding="6"&gt;&lt;caption&gt;&amp;nbsp;&lt;/caption&gt;&lt;colgroup&gt;&lt;col class="left" style="margin-left: 0px; margin-right: auto; text-align: left;"&gt;&lt;col class="left" style="margin-left: 0px; margin-right: auto; text-align: left;"&gt;&lt;col class="left" style="margin-left: 0px; margin-right: auto; text-align: left;"&gt;&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;&lt;th class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: center;" scope="col"&gt;org.hibernate&lt;/th&gt;&lt;th class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: center;" scope="col"&gt;javax.persistence&lt;/th&gt;&lt;th class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: center;" scope="col"&gt;说明&lt;/th&gt;&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;cfg.Configuration&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;Persistence&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;读取配置信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;SessionFactory&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;EntityManagerFactory&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;用于创建会话/实体管理器的工厂类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;Session&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;EntityManager&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;提供实体操作API，管理事务，创建查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;Transaction&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;EntityTransaction&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;管理事务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;Query&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;Query&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;执行查询&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1&gt;2 实体生命周期&lt;/h1&gt;
&lt;p&gt;实体生命周期是JPA中非常重要的概念，描述了实体对象从创建到受控、从删除到游离的状态变换。对实体的操作主要就是改变实体的状态。&lt;/p&gt;
&lt;p&gt;JPA中实体的生命周期如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="arcitecture" src="images/jpa/lifecycle.png"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;New，新创建的实体对象，没有主键(identity)值&lt;/li&gt;
&lt;li&gt;Managed，对象处于Persistence Context(持久化上下文）中，被EntityManager管理&lt;/li&gt;
&lt;li&gt;Detached，对象已经游离到Persistence Context之外，进入Application Domain&lt;/li&gt;
&lt;li&gt;Removed, 实体对象被删除&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;EntityManager提供一系列的方法管理实体对象的生命周期，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;persist, 将新创建的或已删除的实体转变为Managed状态，数据存入数据库。&lt;/li&gt;
&lt;li&gt;remove，删除受控实体&lt;/li&gt;
&lt;li&gt;merge，将游离实体转变为Managed状态，数据存入数据库。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果使用了事务管理，则事务的commit/rollback也会改变实体的状态。&lt;/p&gt;
&lt;h1&gt;3 实体关系映射（ORM）&lt;/h1&gt;
&lt;h2&gt;3.1 基本映射&lt;/h2&gt;
&lt;table style="border-collapse: collapse;" border="2" frame="hsides" rules="groups" cellspacing="0" cellpadding="6"&gt;&lt;caption&gt;&amp;nbsp;&lt;/caption&gt;&lt;colgroup&gt;&lt;col class="left" style="margin-left: 0px; margin-right: auto; text-align: left;"&gt;&lt;col class="left" style="margin-left: 0px; margin-right: auto; text-align: left;"&gt;&lt;col class="left" style="margin-left: 0px; margin-right: auto; text-align: left;"&gt;&lt;col class="left" style="margin-left: 0px; margin-right: auto; text-align: left;"&gt;&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;&lt;th class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: center;" scope="col"&gt;对象端&lt;/th&gt;&lt;th class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: center;" scope="col"&gt;数据库端&lt;/th&gt;&lt;th class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: center;" scope="col"&gt;annotion&lt;/th&gt;&lt;th class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: center;" scope="col"&gt;可选annotion&lt;/th&gt;&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;Class&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;Table&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@Entity&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@Table(name="table_name")&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;property&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;column&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;–&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@Column(name = "column_name")&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;property&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;primary key&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@Id&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@GeneratedValue 详见ID生成策略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;property&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;NONE&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@Transient&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2&gt;3.2 ID生成策略&lt;/h2&gt;
&lt;p&gt;ID对应数据库表的主键，是保证唯一性的重要属性。JPA提供了以下几种ID生成策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GeneratorType.AUTO ，由JPA自动生成&lt;/li&gt;
&lt;li&gt;GenerationType.IDENTITY，使用数据库的自增长字段，需要数据库的支持（如SQL Server、MySQL、DB2、Derby等）&lt;/li&gt;
&lt;li&gt;GenerationType.SEQUENCE，使用数据库的序列号，需要数据库的支持（如Oracle）&lt;/li&gt;
&lt;li&gt;GenerationType.TABLE，使用指定的数据库表记录ID的增长 需要定义一个TableGenerator，在@GeneratedValue中引用。例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;@TableGenerator( name="myGenerator", table="GENERATORTABLE", pkColumnName = "ENTITYNAME", pkColumnValue="MyEntity", valueColumnName = "PKVALUE", allocationSize=1 )&lt;/p&gt;
&lt;p&gt;@GeneratedValue(strategy = GenerationType.TABLE,generator="myGenerator")&lt;/p&gt;
&lt;h2&gt;3.3 关联关系&lt;/h2&gt;
&lt;p&gt;JPA定义了one-to-one、one-to-many、many-to-one、many-to-many 4种关系。&lt;/p&gt;
&lt;p&gt;对于数据库来说，通常在一个表中记录对另一个表的外键关联；对应到实体对象，持有关联数据的一方称为owning-side，另一方称为inverse-side。&lt;/p&gt;
&lt;p&gt;为了编程的方便，我们经常会希望在inverse-side也能引用到owning-side的对象，此时就构建了双向关联关系。 在双向关联中，需要在inverse-side定义mappedBy属性，以指明在owning-side是哪一个属性持有的关联数据。&lt;/p&gt;
&lt;p&gt;对关联关系映射的要点如下：&lt;/p&gt;
&lt;table style="border-collapse: collapse;" border="2" frame="hsides" rules="groups" cellspacing="0" cellpadding="6"&gt;&lt;caption&gt;&amp;nbsp;&lt;/caption&gt;&lt;colgroup&gt;&lt;col class="left" style="margin-left: 0px; margin-right: auto; text-align: left;"&gt;&lt;col class="left" style="margin-left: 0px; margin-right: auto; text-align: left;"&gt;&lt;col class="left" style="margin-left: 0px; margin-right: auto; text-align: left;"&gt;&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;&lt;th class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: center;" scope="col"&gt;关系类型&lt;/th&gt;&lt;th class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: center;" scope="col"&gt;Owning-Side&lt;/th&gt;&lt;th class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: center;" scope="col"&gt;Inverse-Side&lt;/th&gt;&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;one-to-one&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@OneToOne&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@OneToOne(mappedBy="othersideName")&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;one-to-many / many-to-one&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@ManyToOne&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@OneToMany(mappedBy="xxx")&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;many-to-many&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@ManyToMany&lt;/td&gt;
&lt;td class="left" style="vertical-align: top; margin-left: 0px; margin-right: auto; text-align: left;"&gt;@ManyToMany(mappedBy ="xxx")&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中 many-to-many关系的owning-side可以使用@JoinTable声明自定义关联表，比如Book和Author之间的关联表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;@JoinTable(name = &amp;quot;BOOKAUTHOR&amp;quot;, joinColumns = { @JoinColumn(name = &amp;quot;BOOKID&amp;quot;, referencedColumnName = &amp;quot;id&amp;quot;) }, inverseJoinColumns = { @JoinColumn(name = &amp;quot;AUTHORID&amp;quot;, referencedColumnName = &amp;quot;id&amp;quot;) })
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关联关系还可以定制延迟加载和级联操作的行为（owning-side和inverse-side可以分别设置）：&lt;/p&gt;
&lt;p&gt;通过设置fetch=FetchType.LAZY 或 fetch=FetchType.EAGER来决定关联对象是延迟加载或立即加载。&lt;/p&gt;
&lt;p&gt;通过设置cascade={options}可以设置级联操作的行为，其中options可以是以下组合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CascadeType.MERGE 级联更新&lt;/li&gt;
&lt;li&gt;CascadeType.PERSIST 级联保存&lt;/li&gt;
&lt;li&gt;CascadeType.REFRESH 级联刷新&lt;/li&gt;
&lt;li&gt;CascadeType.REMOVE 级联删除&lt;/li&gt;
&lt;li&gt;CascadeType.ALL 级联上述4种操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.4 继承关系&lt;/h2&gt;
&lt;p&gt;JPA通过在父类增加@Inheritance(strategy=InheritanceType.xxx)来声明继承关系。A支持3种继承策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单表继承（InheritanceType.SINGLETABLE），所有继承树上的类共用一张表，在父类指定（@DiscriminatorColumn）声明并在每个类指定@DiscriminatorValue来区分类型。&lt;/li&gt;
&lt;li&gt;类表继承（InheritanceType.JOINED），父子类共同的部分公用一张表，其余部分保存到各自的表，通过join进行关联。&lt;/li&gt;
&lt;li&gt;具体表继承（InheritanceType.TABLEPERCLASS)，每个具体类映射到自己的表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中1和2能够支持多态，但是1需要允许字段为NULL，2需要多个JOIN关系；3最适合关系数据库，对多态支持不好。具体应用时根据需要取舍。&lt;/p&gt;
&lt;h2&gt;3.5 值对象、关联表&lt;/h2&gt;
&lt;p&gt;在领域驱动设计(DDD)中，值对象不具有唯一标识，而是依附在实体上，只能通过实体获取。&lt;/p&gt;
&lt;p&gt;通常，值对象的字段作为所嵌入的实体对象对应的表中的字段。如有必要，也可以通过&lt;code&gt;@SecondaryTable&lt;/code&gt;和&lt;code&gt;@AttributeOverrides&lt;/code&gt;注解将值对象的字段放到关联表中。&lt;/p&gt;
&lt;p&gt;JPA使用&lt;code&gt;@Embeddable&lt;/code&gt;标记一个类为值对象；在实体对象中使用&lt;code&gt;@Embedded&lt;/code&gt;使用值对象作为属性。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;@Embeddable
public class Address {
    private String street;
    private String city;
    private String state;
    @Column(name=&amp;quot;ZIP_CODE&amp;quot;)
    private String zip;
    ……
}

@Entity
@Table(name=&amp;quot;EMP&amp;quot;)
@SecondaryTable(name=&amp;quot;EMP_ADDRESS&amp;quot;,
                pkJoinColumns=@PrimaryKeyJoinColumn(name=&amp;quot;EMP_ID&amp;quot;))
public class Professor {
    @Id private int id;
    private String name;
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name=&amp;quot;street&amp;quot;, column=@Column(table=&amp;quot;EMP_ADDRESS&amp;quot;)),
        @AttributeOverride(name=&amp;quot;city&amp;quot;, column=@Column(name=&amp;quot;CITY&amp;quot;, table=&amp;quot;EMP_ADDRESS&amp;quot;)),
        @AttributeOverride(name=&amp;quot;state&amp;quot;, column=@Column(name=&amp;quot;STATE&amp;quot;, table=&amp;quot;EMP_ADDRESS&amp;quot;)),
        @AttributeOverride(name=&amp;quot;zip&amp;quot;,
                           column=@Column(name=&amp;quot;ZIP_CODE&amp;quot;, table=&amp;quot;EMP_ADDRESS&amp;quot;))
    })
    private Address address;
    ……
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;3.6 复合主键&lt;/h2&gt;
&lt;p&gt;JPA中，可以使用&lt;code&gt;@EmbeddedId&lt;/code&gt;主键将一个值对象声明为复合主键。作为复合主键的值对象要实现&lt;code&gt;Serializable&lt;/code&gt;接口，
并覆盖&lt;code&gt;equals&lt;/code&gt;和&lt;code&gt;hashCode&lt;/code&gt;方法：&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;@Embeddable
public class SectionPK implements Serializable{
  @ManyToOne
  private Security target;
  private Interval interval;
  private Date datetime;

  @Override
  public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + ((target == null) ? 0 : target.hashCode());
      result = prime * result
              + ((datetime == null) ? 0 : datetime.hashCode());
      result = prime * result +
          ((interval == null) ? 0 : interval.hashCode());
      return result;
  }

  @Override
  public boolean equals(Object obj) {
      if (this == obj)
          return true;
      if (obj == null)
          return false;
      if (getClass() != obj.getClass())
          return false;

      SectionPK other = (SectionPK) obj;
      if(!isEqual(this.getDatetime(),other.getDatetime()))
        return false;
      if(!isEqual(this.getInterval(),other.getInterval()))
        return false;
      if(!isEqual(this.getTarget(),other.getTarget()))
        return false;
      return true;
  }

  private boolean isEqual(Object obj1,Object obj2){
    if(obj1==null){
      if(obj2!=null)
        return false;
    }else if(!obj1.equals(obj2)){
      return false;
    }
    return true;
  }

}

@Entity
public class Section {
  @EmbeddedId
  SectionPK key;
  ……
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;3.7 集合映射&lt;/h2&gt;
&lt;p&gt;从JPA2.0开始，不仅支持实体集合的映射，还支持基本类型(如String,Integer等）集合以及值对象(Embeded)集合的映射。&lt;/p&gt;
&lt;p&gt;JPA通过&lt;code&gt;@ElementCollection&lt;/code&gt;注解集合映射，可以自动检测元素类型，也可以通过&lt;code&gt;targetClass&lt;/code&gt;参数指定。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;@CollectionTable&lt;/code&gt;注解可以指定集合表的详细信息。当然，也可以使用&lt;code&gt;@JoinTable&lt;/code&gt;注解进行指定。&lt;/p&gt;
&lt;p&gt;比如，基本类型集合的映射：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//Set
    @ElementCollection
    @JoinTable(name = &amp;quot;item&amp;quot;, joinColumns = { @JoinColumn(nullable = false, name = &amp;quot;item_id&amp;quot;, referencedColumnName = &amp;quot;id&amp;quot;) })
    @Column(name = &amp;quot;filename&amp;quot;, nullable = false)
    private Set&amp;lt;String&amp;gt; images = new HashSet&amp;lt;String&amp;gt;();

//List
    @ElementCollection(targetClass = java.lang.String.class)
    @JoinTable(name = &amp;quot;item&amp;quot;, joinColumns = { @JoinColumn(nullable = false, name = &amp;quot;item_id&amp;quot;) })
    @IndexColumn(name = &amp;quot;position&amp;quot;, base = 1)
    @Column(name = &amp;quot;filename&amp;quot;, nullable = false)
    @OrderBy(clause=&amp;quot;item_id desc&amp;quot;)
    private List&amp;lt;String&amp;gt; listImages = new ArrayList&amp;lt;String&amp;gt;();

//Map
    @ElementCollection
    @JoinTable(name=&amp;quot;item&amp;quot;, joinColumns={ @JoinColumn(nullable=false, name=&amp;quot;item_id&amp;quot;)})
    @MapKeyColumn(name=&amp;quot;map_key&amp;quot;)
    @Column(name=&amp;quot;filename&amp;quot;, nullable=false)
    private Map&amp;lt;String, String&amp;gt; mapImages = new HashMap&amp;lt;String, String&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;值对象集合映射：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public enum FeatureType { AC, CRUISE, PWR, BLUETOOTH, TV, ... }

@Embeddable
public class ServiceVisit {
……
}




@Entity
public class Vehicle {
@Id
int vin;

@ElementCollection
@CollectionTable(name=&amp;quot;VEH_OPTNS&amp;quot;)
@Column(name=&amp;quot;FEAT&amp;quot;)
Set&amp;lt;FeatureType&amp;gt; optionalFeatures;

@ElementCollection
@CollectionTable(name=&amp;quot;VEH_SVC&amp;quot;)
@OrderBy(&amp;quot;serviceDate&amp;quot;)
List&amp;lt;ServiceVisit&amp;gt; serviceHistory;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;4 事件及监听&lt;/h1&gt;
&lt;p&gt;&lt;img alt="events" src="images/jpa/events.png"&gt;&lt;/p&gt;
&lt;p&gt;通过在实体的方法上标注@PrePersist，@PostPersist等声明即可在事件发生时触发这些方法。&lt;/p&gt;
&lt;h1&gt;5 Query Language 查询语言&lt;/h1&gt;
&lt;p&gt;JPA提供两种查询方式，一种是根据主键查询，使用EntityManager的find方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  T find(Class entityClass, Object primaryKey)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另一种就是使用JPQL查询语言。JPQL是完全面向对象的，具备继承、多态和关联等特性，和hibernate HQL很相似。&lt;/p&gt;
&lt;p&gt;使用EntityManager的createQuery方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Query createQuery(String qlString)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5.1 使用参数&lt;/h2&gt;
&lt;p&gt;可以在JPQL语句中使用参数。JPQL支持命名参数和位置参数两种参数，但是在一条JPQL语句中所有的参数只能使用同一种类型。&lt;/p&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Query query = em.createQuery("select p from Person p where p.personid=:Id");
  query.setParameter("Id",new Integer(1));&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位置参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Query query = em.createQuery("select p from Person p where p.personid=?1");
  query.setParameter(1,new Integer(1));&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;5.2 命名查询&lt;/h2&gt;
&lt;p&gt;如果某个JPQL语句需要在多个地方使用，还可以使用&lt;code&gt;@NamedQuery&lt;/code&gt; 或者 &lt;code&gt;@NamedQueries&lt;/code&gt;在实体对象上预定义命名查询。&lt;/p&gt;
&lt;p&gt;在需要调用的地方只要引用该查询的名字即可。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;@NamedQuery(name=&amp;quot;getPerson&amp;quot;, query= &amp;quot;FROM Person WHERE personid=?1&amp;quot;)

@NamedQueries({ @NamedQuery(name=&amp;quot;getPerson1&amp;quot;, query= &amp;quot;FROM Person WHERE personid=?1&amp;quot;), @NamedQuery(name=&amp;quot;getPersonList&amp;quot;, query= &amp;quot;FROM Person WHERE age&amp;gt;?1&amp;quot;) })

Query query = em.createNamedQuery(&amp;quot;getPerson&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5.3 排序&lt;/h2&gt;
&lt;p&gt;JPQL也支持排序，类似于SQL中的语法。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Query query = em.createQuery(&amp;quot;select p from Person p order by p.age, p.birthday desc&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5.4 聚合查询&lt;/h2&gt;
&lt;p&gt;JPQL支持AVG、SUM、COUNT、MAX、MIN五个聚合函数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Query query = em.createQuery(&amp;quot;select max(p.age) from Person p&amp;quot;);
Object result = query.getSingleResult(); String maxAge = result.toString();
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5.5 更新和删除&lt;/h2&gt;
&lt;p&gt;JPQL不仅用于查询，还可以用于批量更新和删除。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Query query = em.createQuery(&amp;quot;update Order as o set o.amount=o.amount+10&amp;quot;); //update 的记录数 int result = query.executeUpdate();

Query query = em.createQuery(&amp;quot;delete from OrderItem item where item.order in(from Order as o where o.amount&amp;lt;100)&amp;quot;);
query.executeUpdate();

query = em.createQuery(&amp;quot;delete from Order as o where o.amount&amp;lt;100&amp;quot;);
query.executeUpdate();//delete的记录数
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5.6 更多&lt;/h2&gt;
&lt;p&gt;与SQL类似，JPQL还涉及到更多的语法，可以参考&lt;a href="http://docs.oracle.com/cd/E11035_01/kodo41/full/html/ejb3_langref.html"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;6 事务管理&lt;/h2&gt;
&lt;p&gt;JPA支持本地事务管理（RESOURCELOCAL）和容器事务管理（JTA），容器事务管理只能用在EJB/Web容器环境中。&lt;/p&gt;
&lt;p&gt;事务管理的类型可以在persistence.xml文件中的“transaction-type”元素配置。&lt;/p&gt;
&lt;p&gt;JPA中通过EntityManager的getTransaction()方法获取事务的实例（EntityTransaction），之后可以调用事务的begin()、commit()、rollback()方法。&lt;/p&gt;</content><category term="java"></category></entry><entry><title>Java规则引擎规范：JSR94</title><link href="http://holbrook.github.io/2012/12/07/jsr94.html" rel="alternate"></link><published>2012-12-07T00:00:00+08:00</published><updated>2012-12-07T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-12-07:/2012/12/07/jsr94.html</id><summary type="html">&lt;p&gt;Java World似乎总会出现一些接口规范，这样做的好处是可以面向接口编程，可以在实现了该接口的产品/组件之间自由切换，避免被厂商绑架。 本文要介绍的JSR94:Java Rule Engine API，Java规则引擎API规范。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Java World似乎总会出现一些接口规范，这样做的好处是可以面向接口编程，可以在实现了该接口的产品/组件之间自由切换，避免被厂商绑架。 本文要介绍的&lt;a href="http://jcp.org/aboutJava/communityprocess/final/jsr094/index.html"&gt;JSR94:Java Rule Engine API&lt;/a&gt;，
Java规则引擎API规范。&lt;/p&gt;
&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;JSR-94是JCP(Java Community Process)制定的关于Java规则引擎API的规范，包括接口定义和示例代码。于2004年8月发布。 JSR-94定义了javax.rules和javax.rules.admin,前者包含了Java规则引擎运行时（Rumtime)API及异常（Exception）定义，后者包含了规则管理相关的API和异常定义。&lt;/p&gt;
&lt;h1&gt;规则管理API&lt;/h1&gt;
&lt;p&gt;规则管理API在javax.rules.admin中定义,主要包括以下类/接口：&lt;/p&gt;
&lt;p&gt;&lt;img alt="javax.rules.admin" src="images/rule-engine/javax.rules.admin.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rule：规则实体&lt;/li&gt;
&lt;li&gt;RuleExecutionSet：执行集，某个规则对应的动作&lt;/li&gt;
&lt;li&gt;LocalRuleExecutionSetProvider：用于从本地创建执行集，如InputStream,Reader等&lt;/li&gt;
&lt;li&gt;RuleExectuionSetProvider：用于从本地或远程创建执行集，如xml Element，Serializable等&lt;/li&gt;
&lt;li&gt;RuleAdministrator：用于获取ExecutionSetProvider，并管理执行集的注册/注销&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规则管理API实现的功能包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;装载规则（Rule）和执行集（RuleExecutionSet)&lt;/li&gt;
&lt;li&gt;执行集的注册/注销,只有注册的执行集对应的规则才能被客户访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;运行时API&lt;/h1&gt;
&lt;p&gt;运行时API在javax.rules中定义，主要包括以下类/接口：&lt;/p&gt;
&lt;p&gt;&lt;img alt="javax.rules" src="images/rule-engine/javax.rules.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RuleServiceProviderManager: 通过URL注册/注销RuleServiceProvider&lt;/li&gt;
&lt;li&gt;RuleServiceProvider: 提供对RuleRuntime和RuleAdministrator的访问&lt;/li&gt;
&lt;li&gt;RuleRuntime: 规则引擎运行时，可以创建规则会话&lt;/li&gt;
&lt;li&gt;RuleSession: 规则会话，用于执行规则&lt;/li&gt;
&lt;li&gt;RuleExecutionSetMetaData: 执行集元数据，包括name,url,description等。执行集元数据会被RuleSession使用&lt;/li&gt;
&lt;li&gt;StatelessRuleSession: 无状态规则会话&lt;/li&gt;
&lt;li&gt;StatefulRuleSession: 有状态规则会话&lt;/li&gt;
&lt;li&gt;Handle和ObjectFilter: 有状态会话维护会话状态的帮助类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规则引擎运行时API实现的功能包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册/注销规则引擎实例，只有注册的规则引擎实例才能被使用&lt;/li&gt;
&lt;li&gt;从注册的规则引擎实例创建Runtime&lt;/li&gt;
&lt;li&gt;从Runtime创建会话，包括有状态和无状态两种会话&lt;/li&gt;
&lt;li&gt;通过会话执行规则&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;异常定义&lt;/h1&gt;
&lt;p&gt;除了前面提到的主要类/接口外，JSR94还规定了规则引擎运行时及管理的一些异常，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="javax.rules.exceptions" src="images/rule-engine/javax.rules.exceptions.png"&gt;&lt;/p&gt;
&lt;h1&gt;代码示例&lt;/h1&gt;
&lt;p&gt;下面是使用Drools作为规则引擎实例的一个例子，规则文件使用了Drools的drl格式：&lt;/p&gt;
&lt;p&gt;JSR94Sample.java&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;com.sample&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.io.FileReader&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.ArrayList&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.HashMap&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.List&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.ConfigurationException&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.RuleRuntime&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.RuleServiceProvider&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.RuleServiceProviderManager&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.StatelessRuleSession&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.admin.LocalRuleExecutionSetProvider&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.admin.RuleAdministrator&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.rules.admin.RuleExecutionSet&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.drools.jsr94.rules.RuleServiceProviderImpl&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;JSR94Sample&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;RuleServiceProvider&lt;/span&gt; &lt;span class="n"&gt;ruleProvider&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;initProvider&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;uri&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RuleServiceProviderImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;RULE_SERVICE_PROVIDER&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;Class&lt;/span&gt; &lt;span class="n"&gt;providerClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RuleServiceProviderImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//注册ruleProvider&lt;/span&gt;
            &lt;span class="n"&gt;RuleServiceProviderManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;registerRuleServiceProvider&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;providerClass&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//从RuleServiceProviderManager获取ruleProvider&lt;/span&gt;
            &lt;span class="n"&gt;ruleProvider&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RuleServiceProviderManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRuleServiceProvider&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ConfigurationException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;adminSample&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;


        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//获取RuleAdministrator实例&lt;/span&gt;
            &lt;span class="n"&gt;RuleAdministrator&lt;/span&gt; &lt;span class="n"&gt;admin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ruleProvider&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRuleAdministrator&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

            &lt;span class="c1"&gt;//获取RuleExectuionSetProvider&lt;/span&gt;
            &lt;span class="n"&gt;HashMap&lt;/span&gt; &lt;span class="n"&gt;properties&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;properties&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;My Rules&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;properties&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;A trivial rulebase&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;LocalRuleExecutionSetProvider&lt;/span&gt; &lt;span class="n"&gt;ruleExecutionSetProvider&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;admin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getLocalRuleExecutionSetProvider&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;properties&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//创建RuleExecutionSet&lt;/span&gt;
            &lt;span class="n"&gt;FileReader&lt;/span&gt; &lt;span class="n"&gt;reader&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FileReader&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bin/sample.drl&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;RuleExecutionSet&lt;/span&gt; &lt;span class="n"&gt;reSet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ruleExecutionSetProvider&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRuleExecutionSet&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reader&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;properties&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//注册RuleExecutionSet&lt;/span&gt;
            &lt;span class="n"&gt;admin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;registerRuleExecutionSet&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mysample&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;reSet&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;properties&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="o"&gt;}&lt;/span&gt;


    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;runtimeSampe&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//获取RuleRuntime, 创建会话&lt;/span&gt;
            &lt;span class="n"&gt;RuleRuntime&lt;/span&gt; &lt;span class="n"&gt;runtime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ruleProvider&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRuleRuntime&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;StatelessRuleSession&lt;/span&gt; &lt;span class="n"&gt;ruleSession&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StatelessRuleSession&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;runtime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRuleSession&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mysample&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;RuleRuntime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STATELESS_SESSION_TYPE&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//初始化输入数据&lt;/span&gt;
            &lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="n"&gt;message1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;message1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;message1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setStatus&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;HELLO&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="n"&gt;message2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;message2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Goodbye World&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;message2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setStatus&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;GOODBYE&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;


            &lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;inputs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;inputs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;inputs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//执行规则&lt;/span&gt;
            &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ruleSession&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeRules&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inputs&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;size&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++){&lt;/span&gt;
                &lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;message&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;


            &lt;span class="c1"&gt;//释放会话资源&lt;/span&gt;
            &lt;span class="n"&gt;ruleSession&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;release&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;


    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// TODO Auto-generated method stub&lt;/span&gt;
        &lt;span class="n"&gt;initProvider&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;adminSample&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;runtimeSampe&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;


    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Message&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;HELLO&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;GOODBYE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

        &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

        &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getMessage&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;message&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getStatus&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;status&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setStatus&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;规则文件使用的就是&lt;a href="/2012/12/06/rule_language.html"&gt;这里&lt;/a&gt;的例子。&lt;/p&gt;
&lt;h1&gt;实现JSR94的产品&lt;/h1&gt;
&lt;p&gt;主要的一些实现了JSR94的规则引擎产品如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.jboss.org/drools/"&gt;Drools&lt;/a&gt;:   开源  DRL,xDRL,DSL,Decision Table ReteOO  Eclipse,excel   文件系统    jar&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mandarax.sourceforge.net/"&gt;Mandarax&lt;/a&gt;:     开源  RuleML&lt;/li&gt;
&lt;li&gt;&lt;a href="http://openrules.com/"&gt;OpenRules&lt;/a&gt;:   开源  Decision Table  Rete    excel       war&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jlisa.sourceforge.net/"&gt;JLisa&lt;/a&gt;:   开源&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.fico.com/en/Products/DMTools/Pages/FICO-Blaze-Advisor-System.aspx"&gt;Blaze&lt;/a&gt;:    商业  SRL&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www-01.ibm.com/software/integration/business-rule-management/jrules-family/"&gt;WebSphere ILOG JRules&lt;/a&gt;:  商业&lt;/li&gt;
&lt;li&gt;&lt;a href="http://herzberg.ca.sandia.gov/"&gt;JESS&lt;/a&gt;:   商业&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;JSR94为规则引擎提供了公用标准API,为实现规则管理API和运行时API提供了指导规范, 目前已经获得很多开源/商业规则引擎产品的支持。 但是JSR94没有对&lt;a href="/2012/12/06/rule_language.html"&gt;规则的描述语言&lt;/a&gt;进行规范，导致各规则引擎产品大多采用自己私有的描述语言。&lt;/p&gt;</content><category term="规则引擎"></category><category term="Java"></category></entry><entry><title>Drools规则描述语言快速手册</title><link href="http://holbrook.github.io/2012/12/06/rule_language.html" rel="alternate"></link><published>2012-12-06T00:00:00+08:00</published><updated>2012-12-06T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-12-06:/2012/12/06/rule_language.html</id><summary type="html">&lt;p&gt;&lt;a href="/2012/03/20/rule_engine_1.html"&gt;在规则引擎中，通常会使用某种表述性的语言（而不是编程语言）来描述规则&lt;/a&gt;。
所以规则描述语言也是规则引擎的一个重要组成部分。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="/2012/03/20/rule_engine_1.html"&gt;在规则引擎中，通常会使用某种表述性的语言（而不是编程语言）来描述规则&lt;/a&gt;。
所以规则描述语言也是规则引擎的一个重要组成部分。&lt;/p&gt;
&lt;p&gt;目前在规则描述语言方面，并没有一个通用的标准获得规则引擎厂商的广泛支持，大部分规则描述语言都是厂商私有的。&lt;/p&gt;
&lt;p&gt;大体来说，规则语言可以分为结构化的（Structured)和基于标记的（Markup，通常为xml）。&lt;/p&gt;
&lt;p&gt;常见的规则描述语言包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;srl(Structured Rule Language) : Fair Isaac（以前是Blaze Software）定义的结构化规则描述语言&lt;/li&gt;
&lt;li&gt;drl(Drools Rule Language) : Jboss（以前是drools.org)定义的结构化规则描述语言&lt;/li&gt;
&lt;li&gt;RuleML(Rule Markup Language）: www.ruleml.org定义的xml规则描述语言&lt;/li&gt;
&lt;li&gt;SRML(Simple Rule Markup Language): xml规则描述语言&lt;/li&gt;
&lt;li&gt;BRML(Business Rules Markup Language):xml规则描述语言&lt;/li&gt;
&lt;li&gt;SWRL（A Semantic Web Rule Language):www.daml.org定义的xml规则描述语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不管是哪种规则描述语言，都需要描述一组条件以及在此条件下执行的操作（即规则）。&lt;/p&gt;
&lt;h1&gt;概览&lt;/h1&gt;
&lt;p&gt;下面是一个drl的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sample&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.sample.DroolsTest.Message&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;rule&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;when&lt;/span&gt;
        &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HELLO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;myMessage&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;then&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;myMessage&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setMessage&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Goodbye cruel world&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setStatus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GOODBYE&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;rule&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;GoodBye&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;when&lt;/span&gt;
        &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GOODBYE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;myMessage&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;then&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;myMessage&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完整的drl文件会包含以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;package 声明&lt;/li&gt;
&lt;li&gt;imports&lt;/li&gt;
&lt;li&gt;declares&lt;/li&gt;
&lt;li&gt;globals&lt;/li&gt;
&lt;li&gt;functions&lt;/li&gt;
&lt;li&gt;queries&lt;/li&gt;
&lt;li&gt;rules&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;package和import声明&lt;/h1&gt;
&lt;p&gt;与Java语言类似，drl的头部需要有package和import的声明。&lt;/p&gt;
&lt;p&gt;规则文件当中必须要有一个 &lt;strong&gt;package&lt;/strong&gt; 声明,同时 package 声明必须要放在规则文件的第一行。&lt;/p&gt;
&lt;h1&gt;规则定义&lt;/h1&gt;
&lt;p&gt;drl中，一个规则的标准结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;rule &amp;quot;name&amp;quot;
    attributes
    when
        LHS
    then
        RHS
end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个规则通常包括三个部分:属性部分(attribute)、条件 部分(LHS)和结果部分(RHS)。&lt;/p&gt;
&lt;h2&gt;条件部分(LHS)&lt;/h2&gt;
&lt;p&gt;在 LHS 当中,可以包含多个条件,如果 LHS 部分没空的话,那么引擎会自动添加一 个 eval(true)的条件。&lt;/p&gt;
&lt;p&gt;多个条件之间之间用可以使用 &lt;strong&gt;and&lt;/strong&gt; 或 &lt;strong&gt;or&lt;/strong&gt; 来进行连接。默认是 &lt;strong&gt;and&lt;/strong&gt; 关系。&lt;/p&gt;
&lt;p&gt;每个条件的语法为：&lt;/p&gt;
&lt;p&gt;[绑定变量名:]Object([field 约束])&lt;/p&gt;
&lt;p&gt;“绑定变量名”是可选的。绑定的变量可以在该LHS后续的条件中引用。&lt;/p&gt;
&lt;p&gt;“field 约束”是指当前对象里相关字段的条件限制, 多个约束之间可以用“&amp;amp;&amp;amp;”(and)、“||”(or)和“,”(and)来连接。&lt;/p&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;when&lt;/span&gt;
&lt;span class="x"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;customer&lt;/span&gt;&lt;span class="x"&gt;:Customer()&lt;/span&gt;
&lt;span class="x"&gt;then&lt;/span&gt;
&lt;span class="x"&gt;    ……&lt;/span&gt;


&lt;span class="x"&gt;when&lt;/span&gt;
&lt;span class="x"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;customer&lt;/span&gt;&lt;span class="x"&gt;:Customer(age&amp;gt;20,gender==􏰃male􏰃)&lt;/span&gt;
&lt;span class="x"&gt;    Order(customer==&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;customer&lt;/span&gt;&lt;span class="x"&gt;,price&amp;gt;1000)&lt;/span&gt;
&lt;span class="x"&gt;then&lt;/span&gt;
&lt;span class="x"&gt;    ……&lt;/span&gt;


&lt;span class="x"&gt;when&lt;/span&gt;
&lt;span class="x"&gt;    Customer(age&amp;gt;20 || (gender==&amp;#39;male&amp;#39; &amp;amp;&amp;amp; city==‘sh&amp;#39;))&lt;/span&gt;
&lt;span class="x"&gt;then&lt;/span&gt;
&lt;span class="x"&gt;    ……&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;约束中可以使用的比较操作符包括：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=、= =、!=、contains、not contains、 memberof、not memberof、matches、not matches
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;order&lt;/span&gt;&lt;span class="nd"&gt;:Order&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;age&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;orders&lt;/span&gt; &lt;span class="nt"&gt;contains&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;order&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="err"&gt;……&lt;/span&gt;


&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;order&lt;/span&gt;&lt;span class="nd"&gt;:Order&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt; &lt;span class="nt"&gt;memberOf&lt;/span&gt; &lt;span class="nt"&gt;orderNames&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;orderNames为数组或集合类型&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="err"&gt;……&lt;/span&gt;

&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt; &lt;span class="nt"&gt;matches&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;李.*&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;正则表达式匹配&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="err"&gt;……&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;结果部分(RHS)&lt;/h2&gt;
&lt;p&gt;RHS 部分定义了当LHS满足是要进行的操作。&lt;/p&gt;
&lt;p&gt;RHS中可以编写代码，可以使用 LHS 部分当中定义的绑定变量名以及drl头部定义的全局变量。&lt;/p&gt;
&lt;p&gt;在 RHS 当中虽然可以直接编写 Java 代码,但不建议在代码当中有条件判断,如果需要条件判断,那么请重新考虑将其放在 LHS 当中,否则就违背了使用规则的初衷。&lt;/p&gt;
&lt;h3&gt;使用宏函数&lt;/h3&gt;
&lt;p&gt;RHS中可以使用宏函数对工作空间(Working Memory)进行操作。当调用宏函数后，所有未设置“no-loop”属性的规则都会被重新匹配，符合条件的重新触发。&lt;/p&gt;
&lt;p&gt;宏函数包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert：将一个 Fact 对象插入到当前的 Working Memory&lt;/li&gt;
&lt;li&gt;update：对当前 Working Memory 中的 Fact 进行更新&lt;/li&gt;
&lt;li&gt;retract ：从 Working Memory 中删除某个 Fact 对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些宏函数都是StatefulSession中定义的方法。&lt;/p&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="err"&gt;……&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="nt"&gt;Customer&lt;/span&gt; &lt;span class="nt"&gt;cus&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;new&lt;/span&gt; &lt;span class="nt"&gt;Customer&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="nt"&gt;cus&lt;/span&gt;&lt;span class="nc"&gt;.setName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="nt"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;cus&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;


&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;age&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;10&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nc"&gt;.setAge&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nc"&gt;.getAge&lt;/span&gt;&lt;span class="o"&gt;()+&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="nt"&gt;update&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;


&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;age&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;10&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="nt"&gt;Customer&lt;/span&gt; &lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;new&lt;/span&gt; &lt;span class="nt"&gt;Customer&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nc"&gt;.setName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nc"&gt;.setAge&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nc"&gt;.getAge&lt;/span&gt;&lt;span class="o"&gt;()+&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;用新对象替换Working&lt;/span&gt; &lt;span class="nt"&gt;Memory中的旧对象&lt;/span&gt;
    &lt;span class="nt"&gt;update&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;drools&lt;/span&gt;&lt;span class="nc"&gt;.getWorkingMemory&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="nc"&gt;.getFactHandleByIdentity&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;


&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="nt"&gt;retract&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;modify代码块&lt;/h3&gt;
&lt;p&gt;modify代码块用于快速修改并更新(update)某个 Fact 对象的多个属性。语法及例子如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;modify&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;fact-expression&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;修改&lt;/span&gt; &lt;span class="n"&gt;Fact&lt;/span&gt; &lt;span class="err"&gt;属性的表达式&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;修改&lt;/span&gt; &lt;span class="nx"&gt;Fact&lt;/span&gt; &lt;span class="nx"&gt;属性的表达式&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;*&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="nt"&gt;when&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="nd"&gt;:Customer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;张三&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;age&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nt"&gt;20&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;then&lt;/span&gt;
    &lt;span class="nt"&gt;modify&lt;/span&gt;&lt;span class="o"&gt;($&lt;/span&gt;&lt;span class="nt"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;setId&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;super man&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;setAge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;drools宏对象&lt;/h3&gt;
&lt;p&gt;通过使用 drools 宏对象可以实现在规则文件里直接访问 Working Memory, 从而获取对当前的 Working Memory 的更多控制。&lt;/p&gt;
&lt;p&gt;drools 宏对象的常用方法包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;drools.getWorkingMemory()：获取当前的 WorkingMemory 对象&lt;/li&gt;
&lt;li&gt;drools.halt()：在当前规则执行完成后,不再执行 其它未执行的规则。&lt;/li&gt;
&lt;li&gt;drools.getRule()：得到当前的规则对象&lt;/li&gt;
&lt;li&gt;drools.insert(new Object)：向当前的 WorkingMemory 当中插入 指定的对象,功能与宏函数 insert 相同。&lt;/li&gt;
&lt;li&gt;drools.update(new Object)：更新当前的 WorkingMemory 中指定 的对象,功能与宏函数 update 相同。&lt;/li&gt;
&lt;li&gt;drools.update(FactHandle Object)：更新当前的 WorkingMemory 中指定 的对象,功能与宏函数 update 相同。&lt;/li&gt;
&lt;li&gt;drools.retract(new Object)：从当前的 WorkingMemory 中删除指 定的对象,功能与宏函数 retract 相 同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;when
    eval(true);
then
    Customer cus=new Customer();
    cus.setName(&amp;quot;张三&amp;quot;);
    drools.insert(cus)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;kcontext宏对象&lt;/h3&gt;
&lt;p&gt;kcontext 也是 Drools 提供的一个宏对象,它的作用主要是用来得到当前的 KnowledgeRuntime 对象,KnowledgeRuntime 对象可以实现与引擎的各种交互。&lt;/p&gt;
&lt;h2&gt;规则属性&lt;/h2&gt;
&lt;p&gt;主要的规则属性如下：&lt;/p&gt;
&lt;p&gt;13 个:  auto-focus、、lock-on-active、no-loop、 ruleflow-group、、when。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;salience&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置规则执行的优先级,数字越大越先执行，数字相同的使用随机顺序。默认值为0，可以设置为负数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no-loop&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认为false。设置为true时，表示该规则只会被引擎检查一次。引擎内部对Fact更新时，忽略本规则的再次检查。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;date-effective&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置规则的开始生效日期。默认接受“dd-MMM-yyyy”格式的字符串。可以用代码修改日期格式，如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.setProperty("drools.dateformat","yyyy-MM-dd")&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;date-expires&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置规则的过期日期。格式与&lt;code&gt;date-effective&lt;/code&gt;相同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;enabled&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认为true。设置规则是否可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dialect&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置规则中使用的编程语言。默认为java，还可以设置为mvel。通过drools.getRule().getDialect()可以获取该属性的设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;duration&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;延迟指定的时间后，在 &lt;strong&gt;另一个线程中&lt;/strong&gt; 触发规则。单位为毫秒。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;activation-group&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为规则划指定一个活动组（组名为字符串）。同一个活动组中的规则只执行一个，根据优先级(salience)来决定执行哪一个规则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;agenda-group 和 auto-focus&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为规则指定一个议程(agenda)组。指定了议程组的规则只有在该议程组得到焦点时才被触发。但如果规则同时指定了auto-focus属性为true，则该规则自动得到焦点。&lt;/p&gt;
&lt;p&gt;指定议程组焦点可以通过回话(session)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;session.getAgenda().getAgendaGroup("GROUP_NAME").setFocus();
  session.fireAllRules();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以实现org.drools.runtime.rule.AgendaFilter 接口：&lt;/p&gt;
&lt;p&gt;{% highlight java %}
    package test;
    import org.drools.runtime.rule.Activation;
    import org.drools.runtime.rule.AgendaFilter;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class TestAgendaFilter implements AgendaFilter {
    private String startName;
    public TestAgendaFilter(String startName){
        this.startName=startName;
    }
    public boolean accept(Activation activation) {
        String ruleName=activation.getRule().getName();
        if(ruleName.startsWith(this.startName)){
            return true;
        }else{
            return false;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ruleflow-group&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指定规则流组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lock-on-active&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当在规则上使用 ruleflow-group 属性或 agenda-group 属性的时候,将 lock-on-action 属性 的值设置为 true,可能避免因某些 Fact 对象被修改而使已经执行过的规则再次被激活执行。lock-on-active 是 no-loop 的增强版属性，在规则流中很有用。&lt;/p&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;rule &amp;quot;rule1&amp;quot;
    salience 1
    when
    ……
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;注释&lt;/h1&gt;
&lt;p&gt;Drools 当中注释的写法与编写 Java 类的注 释的写法完全相同,注释的写法分两种:单行注释与多行注释。&lt;/p&gt;
&lt;p&gt;单行注释可以采用“#”或者“//”来进行标记， 多行注释以“/&lt;em&gt;”开始,以“&lt;/em&gt;/”结束。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* 规则rule1的注释&lt;/span&gt;
&lt;span class="cm"&gt;这是一个测试用规则&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
rule&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rule1&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;when&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;eval&lt;span class="o"&gt;(&lt;/span&gt;true&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;#没有条件判断&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kr"&gt;then&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;System&lt;span class="o"&gt;.&lt;/span&gt;out&lt;span class="o"&gt;.&lt;/span&gt;println&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rule1 execute&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;仅仅是输出&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;类型声明&lt;/h1&gt;
&lt;p&gt;可以在规则文件中定义Fact类型，而不需要编写Java类。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;declare Address
    city : String
    addressName : String
end

declare Person
    name:String
    birthday:Date
    address:Address //使用declare声明的对象作为address属性类型
    order:Order //使用名为Order的JavaBean作为order属性类型
end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在KnowledgeBase中可以获取规则文件中定义的Fact类型，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//获取规则文件当中定义的Address对象并对其进行实例化
FactType addressType=knowledgeBase.getFactType(&amp;quot;test&amp;quot;,&amp;quot;Address&amp;quot;);
Object add=addressType.newInstance();
addressType.set(add, &amp;quot;city&amp;quot;,&amp;quot;Beijing&amp;quot;);
addressType.set(add, &amp;quot;addressName&amp;quot;,&amp;quot;Capital&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在声明中还可以定义元数据。可以为 Fact 对象、Fact对象的属性或者是规则来定义元数据,元数据定义采用的是“@”符号开头。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;declare User
    @createTime(2009-10-25)
    username : String @maxLenth(30)
    userid : String @key
    birthday : java.util.Date
end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;元数据的获取？(TODO)&lt;/p&gt;
&lt;h1&gt;全局变量（TODO）&lt;/h1&gt;
&lt;h1&gt;函数和import function&lt;/h1&gt;
&lt;h2&gt;函数的定义和使用&lt;/h2&gt;
&lt;p&gt;函数是定义在规则文件当中一代码块,作用是将在规则文件当中若干个规则都会用到的业务操作封装起来,实现业务代码的复用,减少规则编写的工作量。
函数的可见范围是函数所在的规则文件。&lt;/p&gt;
&lt;p&gt;函数以function定义，可以是void，也可以有返回值。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.List&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.ArrayList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;/*&lt;/span&gt;
&lt;span class="err"&gt;一个测试函数&lt;/span&gt;
&lt;span class="err"&gt;用来向&lt;/span&gt;&lt;span class="n"&gt;Customer对象当中添加指定数量的Order对象的函数&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;setOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Customer&lt;/span&gt; &lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;orderSize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;ls&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;orderSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;Order&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Order&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;ls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setOrders&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ls&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;/*&lt;/span&gt;
&lt;span class="err"&gt;测试规则&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;rule&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;rule1&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt;
    &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Customer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;setOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;rule 1 customer has order size:&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getOrders&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="o"&gt;/*&lt;/span&gt;
&lt;span class="err"&gt;测试规则&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;rule&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;rule2&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt;
    &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Customer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;setOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;rule 2 customer has order size:&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getOrders&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;引入静态方法&lt;/h2&gt;
&lt;p&gt;实际应用当中,可以考虑使用在 Java 类当中定义静态方法的办法来替代在规则文件当 中定义函数。&lt;/p&gt;
&lt;p&gt;Drools 提供了一个特殊的 import 语句:import function,通过该 import 语句,可以实现将一个 Java 类中静态方法引入到一个规则文件当中,使得该文件当中的规 则可以像使用普通的 Drools 函数一样来使用 Java 类中某个静态方法。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p _="%" endhighlight&gt;{% highlight java %}
package test;
public class RuleTools {
    public static void printInfo(String name){
        System.out.println("your name is :"+name);
    }
}&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;function&lt;/span&gt; &lt;span class="nn"&gt;test.RuleTools.printInfo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;/*&lt;/span&gt;
&lt;span class="err"&gt;测试规则&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;rule&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;rule1&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;when&lt;/span&gt;
        &lt;span class="nb"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;then&lt;/span&gt;
        &lt;span class="n"&gt;printInfo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;test import function&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;查询定义&lt;/h1&gt;
&lt;p&gt;查询用于根据条件在当前的 WorkingMemory 当中查找 Fact。Drools 当中查询可分为两种:一种是不需要外部传入参数;一种是需要外部传入参 数。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;query &amp;quot;testQuery&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    customer:Customer(age&amp;gt;30,orders.size &amp;gt;10)&lt;/span&gt;
&lt;span class="x"&gt;end&lt;/span&gt;

&lt;span class="x"&gt;query &amp;quot;testQuery2&amp;quot;(int &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;age&lt;/span&gt;&lt;span class="x"&gt;,String &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;gender&lt;/span&gt;&lt;span class="x"&gt;)&lt;/span&gt;
&lt;span class="x"&gt;    customer:Customer(age&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;age&lt;/span&gt;&lt;span class="x"&gt;,gender==&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;gender&lt;/span&gt;&lt;span class="x"&gt;)&lt;/span&gt;
&lt;span class="x"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过session可以在外部调用规则文件中的查询，比如：&lt;/p&gt;
&lt;p&gt;{% highlight java %}
……
QueryResults queryResults=statefulSession.getQueryResults("testQuery");
for(QueryResultsRow qr:queryResults){
    Customer cus=(Customer)qr.get("customer"); //打印查询结果
    System.out.println("customer name :"+cus.getName());
}&lt;/p&gt;
&lt;p&gt;QueryResults queryResults2=statefulSession.getQueryResults("testQuery2", new Object[]{new Integer(20),"F"});&lt;/p&gt;
&lt;p _="%" endhighlight&gt;……&lt;/p&gt;</content><category term="规则引擎"></category></entry><entry><title>规则引擎中常用的模式匹配算法</title><link href="http://holbrook.github.io/2012/12/05/algorithm_of_pattern_match.html" rel="alternate"></link><published>2012-12-05T00:00:00+08:00</published><updated>2012-12-05T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-12-05:/2012/12/05/algorithm_of_pattern_match.html</id><summary type="html">&lt;p&gt;规则引擎的核心是Pattern Matcher(模式匹配器)。不管是正向推理还是反向推理，首先要解决一个模式匹配的问题。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="/2012/03/20/rule_engine_1.html"&gt;前面&lt;/a&gt;提到，规则引擎的核心是Pattern Matcher(模式匹配器)。不管是正向推理还是反向推理，首先要解决一个模式匹配的问题。&lt;/p&gt;
&lt;p&gt;对于规则的模式匹配，可以定义为： 一个规则是一组模式的集合。如果事实/假设的状态符合该规则的所有模式，则称为该规则是可满足的。 模式匹配的任务就是将事实/假设的状态与规则库中的规则一一匹配，找到所有可满足的规则。&lt;/p&gt;
&lt;h1&gt;什么是模式匹配&lt;/h1&gt;
&lt;p&gt;对于模式匹配我们都应该不陌生，我们经常使用的正则表达式就是一种模式匹配。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正则表达式是一种“模式（pattern）”&lt;/li&gt;
&lt;li&gt;编程语言提供的“正则表达式引擎”就是Pattern Matcher。比如python中的re模块&lt;/li&gt;
&lt;li&gt;首先输入“知识”：re.compile(r'string')&lt;/li&gt;
&lt;li&gt;然后就可以让其匹配（match）事实（字符串）&lt;/li&gt;
&lt;li&gt;最后通过正则表达式引擎可以得到匹配后的结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于规则匹配，通常定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件部分，也称为LHS(left-hand side)&lt;/li&gt;
&lt;li&gt;事实部分，也称为RHS(right-hand side)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设系统中有N条规则，平均每个规则的条件部分有P个模式，在某个时点有M个事实需要处理。则规则匹配要做的事情就是： 对每一个规则r，判断当前的事实o是否满足LHS(r)=True,如果满足，则将规则r的实例r(o)，即规则+满足该规则的事实，加到冲突集中等待处理。 通常采取如下过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从N条规则中取出一条r；&lt;/li&gt;
&lt;li&gt;从M个事实中取出P个事实的一个组合c；&lt;/li&gt;
&lt;li&gt;用c测试LHS(r)，如果LHS(r（c）)=True，将RHS(r（c）)加入队列中；&lt;/li&gt;
&lt;li&gt;如果M个事实还存在其他的组合c，goto 3；&lt;/li&gt;
&lt;li&gt;取出下一条规则r，goto 2；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际的问题可能更复杂，在规则的执行过程中可能会改变RHS的数据，从而使得已经匹配的规则实例失效或者产生新的满足规则的匹配，形成一种“动态”的匹配链。&lt;/p&gt;
&lt;p&gt;上面的处理由于涉及到组合，过程很复杂。有必要通过特定的算法优化匹配的效率。目前常见的模式匹配算法包括Rete、Treat、Leaps，HAL，Matchbox等。&lt;/p&gt;
&lt;h1&gt;Rete算法&lt;/h1&gt;
&lt;p&gt;Rete算法是目前使用最广泛的规则匹配算法，由Charles L. Forgy博士在1979年发明。Rete算法是一种快速的Forward-Chaining推理算法，其匹配速度与规则的数量无关。 Rete的高效率主要来自两个重要的假设：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时间冗余性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设facts在推理过程中的变化是缓慢的, 即在每个执行周期中,只有少数的facts发生变化，因此影响到的规则也只占很小的比例。所以可以只考虑每个执行周期中已经匹配的facts.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结构相似性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设许多规则常常包含类似的模式和模式组。&lt;/p&gt;
&lt;p&gt;Rete算法的基本思想是保存过去匹配过程中留下的全部信息,以空间代价来换取执行效率 。对每一个模式 ,附加一个匹配元素表来记录WorkingMemory中所有能与之匹配的元素。当一个新元素加入到WorkingMemory时, 找出所有能与之匹配的模式, 并将该元素加入到匹配元素表中; 当一个无素从WorkingMemory中删除时,同样找出所有与该元素匹配的模式,并将元素从匹配元素表中删除。 Rete算法接受对工作存储器的修改操作描述 ,产生一个修改冲突集的动作 。&lt;/p&gt;
&lt;p&gt;Rete算法的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将初始数据（fact）输入Working Memory。&lt;/li&gt;
&lt;li&gt;使用Pattern Matcher比较规则（rule）和数据（fact）。&lt;/li&gt;
&lt;li&gt;如果执行规则存在冲突（conflict），即同时激活了多个规则，将冲突的规则放入冲突集合。&lt;/li&gt;
&lt;li&gt;解决冲突，将激活的规则按顺序放入Agenda。&lt;/li&gt;
&lt;li&gt;使用规则引擎执行Agenda中的规则。重复步骤2至5，直到执行完毕所有Agenda中的规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Tread算法&lt;/h1&gt;
&lt;p&gt;在 Rete算法中 ,同一规则连接结点上的寄存器保留了大量的冗余结果。实际上, 寄存器中大部分信息已经体现在冲突集的规则实例中。因此 ,如果在部分匹配过程中直接使用冲突集来限制模式之间的变量约束,不仅可以减少寄存器的数量 ,而且能够加快匹配处理效率 。这一思想称为 冲突集支撑策略 。&lt;/p&gt;
&lt;p&gt;考虑增删事实对匹配过程的影响，当向工作存储器增加一个事实时 ,冲突集中已有的规则实例仍然保留,只是将与该事实匹配的规则实例加入到冲突集中; 当从工作存储器删去一个事实时，不可能有新的规则实例产生, 只是将 包含该事实的规则实例从冲突集中删去。&lt;/p&gt;
&lt;p&gt;基于冲突集支撑策略和上述观察, Treat算法放弃了Rete算法中利用寄存器保存模式之间变量约束中间结果的思想,对于每一个模式 ,除保留原有 a寄存器的外 ,增加两个新链来记录与该模式匹配的增删事实,一个叫做增链 (addlist),另一个叫做删链 (deletelist)。当修改描述的操作符为 “+”时,临时执行部分连接任务;当修改描述的操作符为 “一”时,直接删去冲突集中包含该事实的规则实例。&lt;/p&gt;
&lt;p&gt;Treat算法的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;行动 :根据点火规则的 RHS,生成修改描述表 CHANGES;&lt;/li&gt;
&lt;li&gt;模式匹配:置每一模式的删链和增链为空,对 CHANGES的每一个修改描述 ,执行模式匹配。对于与修改描述中的事实匹配成功的模式,若修改描述的操作符为 “+”, 将该事实加入这一模式的增链;若修改描述的操作符为 “一”,将该事实加入这一模式的 删链。&lt;/li&gt;
&lt;li&gt;删去事实的处理:对于任一模式链中的每一个事实,找到冲突集中所有包含该事实 的规则实例,并将这一规则实例从冲突集中删去。相应地修改该模式的 a寄存器 。&lt;/li&gt;
&lt;li&gt;新增事实的处理:对 于 每 一 模 式 ,若 其 增 链 非 空 ,则 将 增 链 中 的 所 有 事 实 加 入 该 模 式的a寄存器 ,并对与新增事实相关的每一条规则临时执行部分匹配,寻找该规则新的实 例。具体做法为:首先将第一个模式增链中的事实集合与后一模式的 a寄存器进行连接 , 再将部分连接结果与第三个模式的a寄存器进行连接 ,一直到所有模式均连接完成为止。 其中 ,a寄存器 的内容包括新增 事实。若连接结果非空 ,则将找到 的规则 实例插入到冲突 集中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Leaps 算法&lt;/h1&gt;
&lt;p&gt;前向推理引擎，包括LEAPS，都包括了匹配-选择-执行（match-select-action）循环。即，确定可以匹配的规则，选择某个匹配的元 组，此元组相应的规则动作被执行。重复这一过程，直到某一状态（如没有更多的规则动作）。RETE和TREAT匹配算法速度慢的原因是，它们把满足规则条 件的元组都实例化。Leaps算法的最大的改进就是使用一种"lazy"的方法来评估条件（conditions），即仅当必要时才进行元组的实例化。这 一改进极大的减少了前向推理引擎的时空复杂度，极大提高了规则执行速度。&lt;/p&gt;
&lt;p&gt;Leaps算法将所有的 asserted 的 facts ，按照其被 asserted 在 Working Memory 中的顺序（ FIFO ），放在主堆栈中。它一个个的检查 facts ，通过迭代匹配 data type 的 facts 集合来找出每一个相关规则的匹配。当一个匹配的数据被发现时，系统记住此时的迭代位置以备待会的继续迭代，并且激发规则结果（ consequence ）。当结果（ consequence ）执行完成以后，系统就会继续处理处于主堆栈顶部的 fact 。如此反复。&lt;/p&gt;
&lt;p&gt;Leaps算法的效率可以比Rete算法和Tread算法高几个数量级。&lt;/p&gt;
&lt;h1&gt;其他算法&lt;/h1&gt;
&lt;p&gt;对于HAL算法和Matchbox算法，使用的范围不是很广，这里不做过多的介绍。&lt;/p&gt;</content><category term="规则引擎"></category></entry><entry><title>NoSQL数据库选型指引</title><link href="http://holbrook.github.io/2012/11/06/nosql_list.html" rel="alternate"></link><published>2012-11-06T00:00:00+08:00</published><updated>2012-11-06T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-11-06:/2012/11/06/nosql_list.html</id><summary type="html">&lt;p&gt;从设计原则上，NoSQL不再强调ACID（酸），而是强调BASE（碱）。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;什么是NoSQL&lt;/h1&gt;
&lt;p&gt;NoSQL可以有两种解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No SQL：“不使用SQL查询语言”。强调其轻量的特点&lt;/li&gt;
&lt;li&gt;Not Only SQL：”不仅仅是查询“。强调其高性能，分布式，大容量等传统关系数据库所不具备的特性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从设计原则上，NoSQL不再强调ACID（酸），而是强调BASE（碱）。&lt;/p&gt;
&lt;p&gt;ACID是指：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;atomicity（原子性）：一个事务中的所有操作，要么全部完成，要么全部不完成。如果中途发生错误需要回滚（Rollback）&lt;/li&gt;
&lt;li&gt;consistency(一致性)：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。這表示寫入的資料必須完全符合所有的預設規則，這包含資料的精確度、串聯性以及後續数据库可以自發性地完成預定的工作。&lt;/li&gt;
&lt;li&gt;isolation(隔離性)：当两个或者多个事务并发访问（此处访问指查询和修改的操作）数据库的同一数据时所表现出的相互关系。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）&lt;/li&gt;
&lt;li&gt;durability(持久性)：在事务完成以后，该事务对数据库所作的更改便持久地保存在数据库之中，并且是完全的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BASE是指：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Basically Available（基本可用）&lt;/li&gt;
&lt;li&gt;Soft-state（软状态/柔性事务）&lt;/li&gt;
&lt;li&gt;Eventually Consistent（最终一致性）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NoSQL与关系数据库的原则不同：NoSQL牺牲高一致性，换取获得可用性或可靠性。软状态意味着状态是异步的，在某些时段状态是不一致的；但最终一致保证数据早晚会一致。&lt;/p&gt;
&lt;h1&gt;NoSQL选型要素&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;存储结构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于NoSQL的目的和原则的不同，NoSQL中的数据不是按照表存储。根据NoSQL存储结构的不同，可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文档存储&lt;/li&gt;
&lt;li&gt;图存储&lt;/li&gt;
&lt;li&gt;key/value儲存&lt;/li&gt;
&lt;li&gt;列存储&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否持久化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有的NoSQL是纯内存存储，不支持持久化&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是否支持嵌入式&lt;/li&gt;
&lt;li&gt;是否支持集群部署&lt;/li&gt;
&lt;li&gt;操作接口的丰富程度&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;常见的NoSQL数据库&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;文档数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;th&gt;&lt;td&gt;名称&lt;/td&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;部署方式&lt;/td&gt;&lt;td&gt;操作接口&lt;/td&gt;&lt;td&gt;备注&lt;/td&gt;&lt;/th&gt;
&lt;tr&gt;&lt;td&gt;CouchDB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;分布式&lt;/td&gt;&lt;td&gt;JavaScript MapReduce, RESTful JSON API&lt;/td&gt;&lt;td&gt;HTTP访问，内置了Web管理控制台&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;JackRabbit&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Lotus Notes&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;LotusScript, Java&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;BaseX&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;XQuery, Java&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;MongoDB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;服务，集群&lt;/td&gt;&lt;td&gt;PHP，Python，Perl，Ruby，JavaScript，C++等&lt;/td&gt;&lt;td&gt;JSON数据库，支持全文索引，自动分片，跨LAN或WAN扩展&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;图形数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;th&gt;&lt;td&gt;名称&lt;/td&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;部署方式&lt;/td&gt;&lt;td&gt;操作接口&lt;/td&gt;&lt;td&gt;备注&lt;/td&gt;&lt;/th&gt;
&lt;tr&gt;&lt;td&gt;Neo4j&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DEX&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Java , C#&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;AllegroGraph&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;SPARQL&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FlockDB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Scala&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;key/value数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;th&gt;&lt;td&gt;名称&lt;/td&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;部署方式&lt;/td&gt;&lt;td&gt;操作接口&lt;/td&gt;&lt;td&gt;备注&lt;/td&gt;&lt;/th&gt;
&lt;tr&gt;&lt;td&gt;BigTable&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;memcached&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Redis&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Oracle Berkeley DB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;列数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;th&gt;&lt;td&gt;名称&lt;/td&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;部署方式&lt;/td&gt;&lt;td&gt;操作接口&lt;/td&gt;&lt;td&gt;备注&lt;/td&gt;&lt;/th&gt;
&lt;tr&gt;&lt;td&gt;Cassandra&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;HBase&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Hypertable&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;对象数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;th&gt;&lt;td&gt;名称&lt;/td&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;部署方式&lt;/td&gt;&lt;td&gt;操作接口&lt;/td&gt;&lt;td&gt;备注&lt;/td&gt;&lt;/th&gt;
&lt;tr&gt;&lt;td&gt;db4o&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;iBoxDB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;JADE&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ZODB&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ObjectStore&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</content><category term="NoSQL"></category></entry><entry><title>QQ 餐厅与系统性能模型(续)：如何评价系统的性能</title><link href="http://holbrook.github.io/2012/10/29/performance_test.html" rel="alternate"></link><published>2012-10-29T00:00:00+08:00</published><updated>2012-10-29T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-10-29:/2012/10/29/performance_test.html</id><summary type="html">&lt;p&gt;作为QQ餐厅的客人，对餐厅效率的评价就是供餐“快”或者“慢”。但是对于餐厅的经营者，这样简单的考虑问题显然是不够的。
在《QQ餐厅与系统性能模型》 中提到了系统性能的很多指标，而客人感觉“快”或者“慢”仅仅对应其中的 响应时间 这一指标。本文讨论如何全面评价一个系统的性能"&lt;/p&gt;</summary><content type="html">&lt;p&gt;作为QQ餐厅的客人，对餐厅效率的评价就是供餐“快”或者“慢”。但是对于餐厅的经营者，这样简单的考虑问题显然是不够的。&lt;/p&gt;
&lt;p&gt;在&lt;a href="/2012/10/23/whats_performance.html"&gt;《QQ餐厅与系统性能模型》&lt;/a&gt; 中提到了系统性能的很多指标，而客人感觉“快”或者“慢”仅仅对应其中的 &lt;em&gt;响应时间&lt;/em&gt; 这一指标。&lt;/p&gt;
&lt;p&gt;对于QQ餐厅的经营者，应该如何考虑呢？&lt;/p&gt;
&lt;p&gt;在《QQ餐厅与系统性能模型》 中已经描述了客人数量增加时餐厅中发生的一系列“故事”，让我们回顾一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源利用率与负载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;资源利用率随负载的增加而增加，最终达到100%。此时再增加负载，资源利用率也不会增加。当然，这是对单一资源来说，现实中总是有某种资源最先达到100%而其他的资源仍有空闲。&lt;/p&gt;
&lt;p&gt;资源利用率达到100%时对应的并发用户数称为 &lt;strong&gt;最佳并发用户数&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应时间与负载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当并发用户数小于前面定义的“最大并发用户数”时，系统的响应时间是一个固定的值。如果继续增加系统的负载，用户等待时间就会增加从而延长响应时 间。假设用户有一个能容忍的最长等待时间，则负载增加到一定程度时系统对某些请求的响应时间就会超过用户的容忍度。在临界状态的负载称为 最大并发用户数 。&lt;/p&gt;
&lt;p&gt;在最大并发用户数的情况下，系统的吞吐量应该达到最大值。超过最大并发用户数的负载会导致资源浪费在超时的请求上，从而使吞吐量下降。&lt;/p&gt;
&lt;p&gt;（在系统负载略高于最大并发用户数时，可能吞吐量会有一定程度的增加，但此时的吞吐量已经没有意义。所以应该考量最大并发用户数下系统的吞吐量）&lt;/p&gt;
&lt;h1&gt;评价系统的性能&lt;/h1&gt;
&lt;p&gt;从系统建设者的角度来说，系统性能不仅仅是”快“或者”慢“，而是应该有一个全面的描述。比如对于”QQ餐厅系统“，至少要有如下的描述才能评价其性能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QQ餐厅的可用资源包括：2位厨师，6名服务员，30套座位&lt;/li&gt;
&lt;li&gt;QQ餐厅最理想情况是同时接待25位客人，此时2名厨师工作量饱和，服务员空闲1人，座位空闲5套&lt;/li&gt;
&lt;li&gt;在25人就餐的情况下，没小时可以卖出8道菜，客人评价就餐时间为10分钟，99%的客人可以在30分钟完成内用餐&lt;/li&gt;
&lt;li&gt;假设 客人能容忍的最长用餐时间为60分钟，则QQ餐厅最多能容纳35人就餐&lt;/li&gt;
&lt;li&gt;在35人就餐的情况下，每小时可以卖出10道菜，客人平均就餐时间为20分钟，99%的客人可以在50分钟内完成用餐&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;提高系统的性能&lt;/h1&gt;
&lt;p&gt;有了前面比较系统的性能描述，就很容易知道如何提高系统的性能。提高系统性能的目标有两个级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在现有的响应时间基础上，提高最佳并发用户数和最大并发用户数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个指标的现实意义在于：最佳并发用户数要不小于系统的平均负载，最大并发用户数要不小于系统的峰值负载（通常应该达到峰值的1.5–2倍）。&lt;/p&gt;
&lt;p&gt;实现这个级别的目标通常比较容易，主要是增加系统的可用资源。必要时还可以横向扩展（增加服务器数量）。比如对于前面的QQ餐厅性能情况，增加厨师数量就能够有效提高最佳并发数和最大并发数。&lt;/p&gt;
&lt;p&gt;当然，如果能够说服用户增加所能容忍的等待时间，也可以提高最大并发数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加系统整体的响应速度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户感受到的整体响应时间=请求传输时间+等待时间+处理时间+响应返回时间。针对这些不同的时间片段可以分别想办法提高速度。比如：&lt;/p&gt;
&lt;p&gt;提高网络带宽可以减小请求传输时间和响应返回时间； 增加处理单元可以减小等待时间； 优化算法可以减小处理时间。&lt;/p&gt;
&lt;p&gt;上面的几种办法实现起来难度都比较大，所以提高系统性能应该优先考虑第一个级别的办法。&lt;/p&gt;
&lt;h1&gt;最精简的性能测试的例子&lt;/h1&gt;
&lt;p&gt;使用Apache ab进行性能测试，访问NginX上面部署的静态页面。在不同并发下测试100万次请求，结果如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;并发数 失败请求数 每秒完成请求  平均响应时间ms  99%请求响应时间ms 吞吐量(kb/s)&lt;/p&gt;
&lt;p&gt;100 0 13005.97  7.689 10  24132.19&lt;/p&gt;
&lt;p&gt;500 0 24132.19  36.193  232 25632.78&lt;/p&gt;
&lt;p&gt;600 0 13948.85  43.014  296 25881.7&lt;/p&gt;
&lt;p&gt;700 0 14317.11  48.893  232 25632.78&lt;/p&gt;
&lt;p&gt;800 288 14264.21  56.084  2570  26461.06&lt;/p&gt;
&lt;p&gt;1000  390 14752.1 67.787  3013  27363.46&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在各轮测试中，Nginx均没有发生故障切换。&lt;/p&gt;
&lt;p&gt;从测试数据中可以得出以下结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前的性能瓶颈在于网络带宽&lt;/li&gt;
&lt;li&gt;当前系统的最佳并发数为500，最大并发为700&lt;/li&gt;
&lt;li&gt;在最佳并发下，系统每秒可以处理2.4万个请求，平均响应时间36ms，99%的请求在232ms内完成&lt;/li&gt;
&lt;li&gt;在最大并发下，系统每秒可以处理1.4万个请求，平均响应时间48ms，99%的请求在232ms内完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;负载均衡器的性能指标&lt;/h1&gt;
&lt;p&gt;对于负载均衡器，需要的性能指标与具体的应用服务器不太一样。更关注如下指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每秒的会话处理数，要区分4层和7层&lt;/li&gt;
&lt;li&gt;最多保持的连接数&lt;/li&gt;
&lt;li&gt;吞吐量，要区分4层和7层&lt;/li&gt;
&lt;li&gt;支持的虚拟服务器的个数&lt;/li&gt;
&lt;li&gt;支持的后端真实服务器的个数&lt;/li&gt;
&lt;/ul&gt;</content><category term="测试"></category></entry><entry><title>QQ餐厅与系统性能模型</title><link href="http://holbrook.github.io/2012/10/23/whats_performance.html" rel="alternate"></link><published>2012-10-23T00:00:00+08:00</published><updated>2012-10-23T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-10-23:/2012/10/23/whats_performance.html</id><summary type="html">&lt;p&gt;如果你在玩QQ餐厅的时候被老板抓到，可以理直气壮的说：'我在研究系统性能模型'。本文以QQ餐厅作为模型，讨论系统性能的主要指标&lt;/p&gt;</summary><content type="html">&lt;h1&gt;QQ餐厅”系统“&lt;/h1&gt;
&lt;p&gt;QQ餐厅是一个系统。 其中包括各种资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;厨师是 &lt;em&gt;CPU&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;服务员是 &lt;em&gt;内存&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;桌椅板凳是 &lt;em&gt;磁盘IO&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个系统中只运行一个 &lt;em&gt;应用&lt;/em&gt; ，该应用只提供一个 &lt;em&gt;服务&lt;/em&gt; ：就餐服务。显然，系统的所有资源都会用于这个服务。 QQ餐厅当然会有很多客人，称之为 并发用户数 ，或者叫 &lt;em&gt;负载&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;开始的时候客人不多，桌椅板凳或厨师、服务员都可能空闲，叫做 &lt;em&gt;资源闲置&lt;/em&gt; ，已经使用的资源比例叫做 &lt;em&gt;资源利用率&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;随着资源和人的增加，资源利用率也会逐渐增长，并最终达到100%。此时餐厅已经”全速运转“，这是的并发用户数叫做 &lt;em&gt;最佳并发数&lt;/em&gt; ， 所谓”最佳“是指资源已经充分利用，并且每个请求没有额外的等待。&lt;/p&gt;
&lt;p&gt;如果某些资源不足，就会发生该资源的利用率已经达到100%，但是其他资源仍有空闲的情况。此时该项资源成为 &lt;em&gt;性能瓶颈&lt;/em&gt; 。为避免性能瓶颈，最理想的情况是使得所有资源的利用率同时达到100%，此时各种资源的比例叫做 &lt;em&gt;最佳资源配比&lt;/em&gt; 。 QQ餐厅玩家很重要的一项任务就是在餐厅的不断扩建过程中，始终维持各资源的最佳配比。&lt;/p&gt;
&lt;p&gt;当客人的数量超过”最佳并发数“时，就会产生额外的等待。也就是说， &lt;em&gt;等待时间&lt;/em&gt; 会随着并发用户数的增加而增长。而从客人的角度来说，等待时间+供餐所需的固有时间（服务员点菜、传菜、结账和厨师做菜等需要的，不可减少的时间）= 响应时间 ，所以等待时间的延长会导致响应时间的延长。而客人的耐心是有限的，如果响应时间过长，客人就会愤然离去，这叫做 &lt;em&gt;响应超时&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;由于响应超时会导致客人的离去，我们应该区分满意离开的客人和因为超时而离开的客人。我们把餐厅在单位时间接待的客人叫做 &lt;em&gt;吞吐量&lt;/em&gt; ，并发用户数-吞吐量=超时的请求。不发生超时情况下的最大并发用户数成为 &lt;em&gt;最大并发数&lt;/em&gt; 。 此时系统的吞吐量达到最大。&lt;/p&gt;
&lt;h1&gt;系统性能指标&lt;/h1&gt;
&lt;p&gt;在QQ餐厅中，涉及到了很多系统性能指标，让我们来回顾一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统，应用，服务&lt;/li&gt;
&lt;li&gt;资源： CPU、内存、磁盘IO等&lt;/li&gt;
&lt;li&gt;负载，并发用户数&lt;/li&gt;
&lt;li&gt;资源利用率、性能瓶颈、资源闲置&lt;/li&gt;
&lt;li&gt;最佳并发数，最佳资源配比&lt;/li&gt;
&lt;li&gt;等待时间、响应时间与响应超时&lt;/li&gt;
&lt;li&gt;吞吐量、最大并发数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，由于QQ餐厅的模型比较简单，有一些性能指标没有体现出来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户响应时间和系统响应时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面的响应时间是从餐厅（系统）角度考虑的，如果从客人（用户）角度考虑，可能还需要加上从家到餐厅以及从餐厅返回到家的时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;吞吐量的计量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面把餐厅在单位时间接待的客人数量作为吞吐量，这是因为QQ餐厅进行了简化，假设每位顾客只点一种套餐（一道菜+一份饮料）并且只点一次。更复杂 的情况是根据粒度的不同，分别用每秒完成菜品的数量（流量）、完成点餐的数量（请求）、用餐次数（事务）作为吞吐量的计量，根据需要选择一个或者多个指 标。&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;综上所述，QQ餐厅是一个系统，玩QQ餐厅就是考虑如何优化系统的性能。 而需要分析系统的哪些性能指标、如何分析决定能否对系统性能进行有效的优化。 这些内容可以继续围观&lt;a href="/2012/10/29/performance_test.html"&gt;《QQ餐厅与系统性能模型(续)：如何评价系统的性能》&lt;/a&gt;。&lt;/p&gt;</content><category term="测试"></category></entry><entry><title>规则，推理机和规则引擎</title><link href="http://holbrook.github.io/2012/03/20/rule_engine_1.html" rel="alternate"></link><published>2012-03-20T00:00:00+08:00</published><updated>2012-03-20T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-03-20:/2012/03/20/rule_engine_1.html</id><summary type="html">&lt;p&gt;规则作为一种知识，其典型运用就是通过实际情况，根据给定的一组规则，得出结论。
这种规则的运用过程叫做推理。如果由程序来处理推理过程，那么这个程序就叫做推理机/推理引擎（Inference Engine）。
基于规则的推理机称为“规则引擎”。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;什么是规则&lt;/h1&gt;
&lt;p&gt;在现实生活中，规则无处不在。我们最长接触的是法律、法规和各种制度；对于企业级应用来说，第一步的业务调研中很重要的内容就是了解业务规则。在企业流程再造中，可能还会接触到流程规则。&lt;/p&gt;
&lt;p&gt;在IT技术领域，很多地方也应用了规则，比如路由表，防火墙策略，乃至角色权限控制(RBAC)，或者Web框架中的URL匹配。&lt;/p&gt;
&lt;p&gt;不管是哪种种规则，都规定了一组确定的条件和此条件所产生的结果。&lt;/p&gt;
&lt;p&gt;举一个例子，是纷繁复杂的保险费率计算中的一条规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IF&lt;/li&gt;
&lt;li&gt;汽车是红色&lt;/li&gt;
&lt;li&gt;车是运动型的&lt;/li&gt;
&lt;li&gt;驾驶员是男性&lt;/li&gt;
&lt;li&gt;驾驶员在16-25岁之间&lt;/li&gt;
&lt;li&gt;THEN&lt;/li&gt;
&lt;li&gt;保险费用增加20%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这个例子可以看出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每条规则都是一组条件决定的一系列结果&lt;/li&gt;
&lt;li&gt;一条规则可能与其他规则共同决定最终结果。比如例子中的规则只产生了增量，还需要与确定基数的规则共同作用才能决定最终的费率&lt;/li&gt;
&lt;li&gt;可能存在条件互相交叉的规则，此时有必要规定规则的优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;推理机与规则引擎&lt;/h1&gt;
&lt;p&gt;规则作为一种知识，其典型运用就是通过实际情况，根据给定的一组规则，得出结论。这个结论可能是某种静态的结果，也可能是需要进行的一组操作。
这种规则的运用过程叫做推理。如果由程序来处理推理过程，那么这个程序就叫做推理机/推理引擎（Inference Engine）。推理机是专家系统（专家系统是人工智能的一个分支）的核心模块。&lt;/p&gt;
&lt;p&gt;&lt;img alt="推理机" src="images/rule-engine/inference_engine.png"&gt;&lt;/p&gt;
&lt;p&gt;推理引擎根据知识表示的不同采取的控制策略也是不同的，常见的类型包括基于神经网络、基于案例和基于规则的推理机。其中，基于规则的推理机易于理解、易于获取、易于管理，被广泛采用。这种推理引擎被称为“规则引擎”。&lt;/p&gt;
&lt;p&gt;在规则引擎中，将知识表达为规则（rules），要分析的情况定义为事实（facts）。二者在内存中的存储分别称为Production Memory和Working Memory，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="规则引擎" src="images/rule-engine/rule_engine.png"&gt;&lt;/p&gt;
&lt;p&gt;rules和facts是规则引擎接受的输入参数，而规则引擎本身包括两个组成部分：Pattern Matcher和Agenda。Pattern Matcher根据facts找到匹配的rules，Agenda管理PatternMatcher挑选出来的规则的执行次序。在外围，还会有一个执行引擎（Execution Engine）负责根据Agenda输出的rules执行具体的操作。&lt;/p&gt;
&lt;p&gt;其中Pattern Matcher是规则引擎负责推理的核心。和人类的思维相对应，规则引擎中也存在两种推理方式：正向推理（Forward-Chaining）和反向推理（Backward-Chaining）。&lt;/p&gt;
&lt;p&gt;正向推理也叫演绎法，由事实驱动，从 一个初始的事实出发，不断地应用规则得出结论。首先在候选队列中选择一条规则作为启用规则进行推理，记录其结论作为下一步推理时的证据。如此重复这个过程，直到再无可用规则可被选用或者求得了所要求的解为止。&lt;/p&gt;
&lt;p&gt;反向推理也叫归纳法，由目标驱动，首先提出某个假设，然后寻找支持该假设的证据，若所需的证据都能找到，说明原假设是正确的；若无论如何都找不到所需要的证据，则说明原假设不成立，此时需要另做新的假设。&lt;/p&gt;
&lt;h1&gt;规则引擎的作用&lt;/h1&gt;
&lt;p&gt;规则引擎可以将规则的定义从代码中分离出来，将推理过程封装到规则引擎内部进行处理，这带来几个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;规则外部化，即有利于规则知识的复用，也可避免改变规则时带来的代码变更问题&lt;/li&gt;
&lt;li&gt;由规则引擎使用某种算法进行推理过程，不需要编写复杂晦涩的逻辑判断代码&lt;/li&gt;
&lt;li&gt;开发人员的不需要过多关注逻辑判断，可以专注于逻辑处理&lt;/li&gt;
&lt;/ol&gt;</content><category term="规则引擎"></category></entry><entry><title>Python之禅(The Zen of Python)</title><link href="http://holbrook.github.io/2012/02/12/zen_of_python.html" rel="alternate"></link><published>2012-02-12T00:00:00+08:00</published><updated>2012-02-12T00:00:00+08:00</updated><author><name>Holbrook</name></author><id>tag:holbrook.github.io,2012-02-12:/2012/02/12/zen_of_python.html</id><summary type="html">&lt;p&gt;Python之禅, 中英对照&lt;/p&gt;</summary><content type="html">&lt;h1&gt;&lt;a href="http://www.python.org/dev/peps/pep-0020/"&gt;The Zen of Python&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;by Tim Peters&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Beautiful is better than ugly.&lt;/li&gt;
&lt;li&gt;Explicit is better than implicit.&lt;/li&gt;
&lt;li&gt;Simple is better than complex.&lt;/li&gt;
&lt;li&gt;Complex is better than complicated.&lt;/li&gt;
&lt;li&gt;Flat is better than nested.&lt;/li&gt;
&lt;li&gt;Sparse is better than dense.&lt;/li&gt;
&lt;li&gt;Readability counts.&lt;/li&gt;
&lt;li&gt;Special cases aren't special enough to break the rules.&lt;/li&gt;
&lt;li&gt;Although practicality beats purity.&lt;/li&gt;
&lt;li&gt;Errors should never pass silently.&lt;/li&gt;
&lt;li&gt;Unless explicitly silenced.&lt;/li&gt;
&lt;li&gt;In the face of ambiguity, refuse the temptation to guess.&lt;/li&gt;
&lt;li&gt;There should be one-- and preferably only one --obvious way to do it.&lt;/li&gt;
&lt;li&gt;Although that way may not be obvious at first unless you're Dutch.&lt;/li&gt;
&lt;li&gt;Now is better than never.&lt;/li&gt;
&lt;li&gt;Although never is often better than &lt;em&gt;right&lt;/em&gt; now.&lt;/li&gt;
&lt;li&gt;If the implementation is hard to explain, it's a bad idea.&lt;/li&gt;
&lt;li&gt;If the implementation is easy to explain, it may be a good idea.&lt;/li&gt;
&lt;li&gt;Namespaces are one honking great idea -- let's do more of those!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Python之禅&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/lanphaday/article/details/2151918"&gt;赖勇浩 翻译&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优美胜于丑陋（Python 以编写优美的代码为目标）&lt;/li&gt;
&lt;li&gt;明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）&lt;/li&gt;
&lt;li&gt;简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）&lt;/li&gt;
&lt;li&gt;复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）&lt;/li&gt;
&lt;li&gt;扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）&lt;/li&gt;
&lt;li&gt;间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）&lt;/li&gt;
&lt;li&gt;可读性很重要（优美的代码是可读的）&lt;/li&gt;
&lt;li&gt;即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）&lt;/li&gt;
&lt;li&gt;不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）&lt;/li&gt;
&lt;li&gt;当存在多种可能，不要尝试去猜测&lt;/li&gt;
&lt;li&gt;而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）&lt;/li&gt;
&lt;li&gt;虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）&lt;/li&gt;
&lt;li&gt;做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）&lt;/li&gt;
&lt;li&gt;如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）&lt;/li&gt;
&lt;li&gt;命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）&lt;/li&gt;
&lt;/ul&gt;</content><category term="python"></category></entry></feed>