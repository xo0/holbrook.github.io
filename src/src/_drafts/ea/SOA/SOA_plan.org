
* 服务中心，流程中心，事件处理中心，认证中心，权限管理中心。。。
ESB，BPEL，CEP，。。。

* 你需要的是什么样的SOA
前面提到的各个中心，其位置是不同的。

服务中心提供整个服务的架构；
其他的中心提供具体的服务
* 服务

可以被（应用系统）调用
提供者，消费者

底层的、细粒度的服务可以组装成上层的、粗粒度的服务
* 消息
请求消息，响应消息，状态消息
* 协议

消息协议，通信协议
KCXP、FIX、texido等
TUXEDO

* 宏源SOA规划
** SOA是一种世界观

面向服务？？？我们听说过面向组件，面向对象，面向函数。是不是和这些有些渊源？
体系结构？我们听说过EJB、COM+、CORBA体系结构，难道和这些体系结构类似？
面向服务的体系结构（Service-Oriented Architecture，SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。
接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以一种统一和通用的方式进行交互。
这是完整的定义：
1 是一个组件模型
2 不同功能单元，称为服务
3 服务之间通过接口和约定联系起来
4 接口是中立的
这个定义是很虚的。
(？？ 这怎么和我多年前学习COM时说的一模一样？
我找到别的网站上的一篇文章说的：
SCA服务组件与传统组件的主要区别在于：
　　1. 服务组件往往是粗粒度的，而传统组件以细粒度居多。（不对，过去我们做COM，也有流程集合组件，是粗粒度的）
　　2. 服务组件的接口是标准的，主要是WSDL接口，而传统组件常以具体API形式出现。（不对，只是接口实现技术不同而已，有这样区别的么？）
　　3. 服务组件的实现与语言是无关的，而传统组件常绑定某种特定的语言。（不对，很多语言都能实现COM）
　　4. 服务组件可以通过组件容器提供QoS的服务，而传统组件完全由程序代码直接控制。（不对，传统组件也业由组件容器提供了若干服务）




SOA是一个组件模型。组件模型我们知道，COM+、EJB都是组件模型。组件有属性、方法、事件。组件运行在组件容器中。
组件容器来保证组件的创建、并发、池化、日志、销毁。
而组件是脱胎于对象的。看看各个语言实现的组件模型，其实现都是应用对象模型。
对象具有数据和方法，没有事件。而数据，也没有什么读写限制。这是组件和对象非常明显的区别。
我们曾经面向函数编程，更早时候我们还写过大流水没有函数的程序代码（现在想来甚是幼稚，简直是一团浆糊，但我现在代码复查的时候居然还能看见这类代码，其跟踪纠错、质量保证、变化裁减扩展、阅读理解都不符合，如何能商业化开发）。
但是函数无法表现函数间的关系。只好放到不同的源代码文件中表示逻辑群集。但这种表示方法很是糟糕。数据和方法仍然没有分离，也没有屏蔽可见级别。于是，我们必须走向面向对象。其实我们对OO，并不是像业界理论那样分析业务、映射成对象，然后设计对象。其最开始就是为了解决代码可视级别的事情，继承和多态并不是我们所考虑的。也没有很专业的去分析设计对象。但确实是人以群分物以类聚，实现出来的东西，等我们真正理解懂了OO的理论，回头看我们的代码，居然还真的很符合OO理论。让我感叹现在很多入道不几年的程序员，为了OO而OO，为了实践OO理论而强制自己写OO代码，最后是OO的表面形式，而思路却是大流水，连函数流程都阅读不出来，思路分叉判断很多。建议先踏实把面向函数用起来，再自然过渡到面向对象。
面向对象也有解决不了的问题。那就是没有事件和属性。于是面向组件产生。但是大家仔细分析源代码，属性和事件，都是通过面向对象的方法做到的。如一个属性，往往是Getxxx和Setxxx构成，一个事件是一个特殊形式的属性而已。
事情都是承接的，自然而然过渡的，就和面向大流水到了面向过程，然后是面向对象，然后是面向组件。
面向组件，我们又遇到了问题。而这些问题，都是由于我们顺其自然理解习惯而引起的。
很多人分析完业务，不管你是用UML还是什么组织结构-流程-考核的方法，你在软件设计的时候，总是要有个艰难的映射。就是把现实要映射成类，要影射成组件。而这个映射是如此的不符合顺其自然的思考习惯。你需要变换一种思路，而这分析和设计两种思路，老是拧不在一起。
我们不想继续拧巴了。我们就想很直白的说：我要完成这个事情。我现在有这么多信息，我输入进去，你就给我产出我需要的计算结果。OK，就这么简单。我不想再映射什么类，什么组件了。
这就是很自然的人类思考习惯。我们业界老前辈老专家兜兜转转，研究发表了N多理论和方法，但最终仍然科学理性拧不过人类顺其自然的分析习惯。又回来了。但这个回归已经升华了，我们在简单的接口之下再也不会有大流水的实现了。在我们的服务接口之下，我们自由的应用我们擅长的开发实现方法。我们再也不用和客户讲类映射，客户再也不用和我们讲业务流程了。我们统一了，我们就想这么做：我要完成这个事情。我现在有这么多信息，我输入进去，你就给我产出我需要的计算结果。OK，就这么简单。
让客户学会UML，不可能。过去让我们和客户，想拿RUP过程管理方法和UML事务描述方法来统一，只是个理论理想。
SOA，不是面向组件升级到面向服务这么简单。是我们的软件分析方法、软件设计方法、软件开发方法的变革。是业界对过去这些理论和产品的反思。业界对世界的抽象方法变了。
SOA需要将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。但怎么联系起来。高内聚，低耦合是我们一贯的原则。像过去我们互相开放DLL的方式根本不合适，都是硬编码进自己的系统中。一旦接口改变，都需要修改。幸好，业界发现了有个工作流的东西，听说可以驱动业务流程。于是，满心欢喜的奔了过去。
真正一用才发现不对。工作流的规范世界早已固定。工作流产生的时候，还没有SOA呢。SOA需要的业务流程连接，工作流的原理类似，但并不是最适合软件服务的连接。于是，业界又集体联合起来研发了BPEL，业务流程处理语言。但有些工作流厂商也唯恐被称为落后时代脚步，于是强嘴说自己已经是SOA了。于是，业界李鬼李逵一堆。各有各的利益，各唱各的调。
SOA这种世界观也需要落地到一个可实现的框架。于是SCA和SDO出现。SCA是SOA的落地架构框架规范，SDO是数据结构规范和数据存取原理规范。而这些规范，用现有的开发语言和技术框架都可以实现。所以，对于现有系统，无须认为现有的系统落后了，不符合SOA了，需要重新上一套SOA软件了。
但是，我粗略阅读SCA规范，特别类似于我过去熟悉的组件模型体系。只不过SCA在组件模型基础上又提供了服务定义和服务Wire。组件模型是提供了个体的规范，而SCA不仅提供了个体，更提供了个体之间连接的规范。组件模型让我熟悉了接口与实现的分离，让我熟悉了容器运行保护，让我熟悉了元数据管理。没有经过面向组件时代的人，不会感受到SOA到来的必要性。
我们曾经用组件模型开发应用软件，其目的就是想像这些组件都是独立的个体，然后我们用一种脚本把这些组件穿在一起（过去我想到是VBA脚本，然后是Javascript脚本，然后是ASP脚本，然后又关注了工作流，均不满意，最后才落眼到BEPL）。而如今，SCA、SDO、BEPL、ESB给我们多年的设想提供了可落实的体系模型。我们需要这样灵活组合的应用软件，我们不需要一个上千个参数配置的航母软件（如SAP R/3）。
只有了解了SOA、BPEL、ESB的前生后世，我们才能平和的看待这些技术，看待和这些技术相关的技术，我们才能有的放矢的去学习它、利用它，为我们更快速的适应客户需求变化而有益。
*** 什么是企业服务
服务不仅仅是webservice，webservice只是服务的一种表现形式

   * 是一种有特定结果的可重复业务活动的逻辑表示（例如，检查客户信用度、提供天气预报等）
   * 自包含
   * 可以组合其他服务
   * 对于服务使用者来说是"黑盒"的


** SOA的生存环境

目标：为业务创新和优化（Business Innovation & Optimization)提供支持
基础：基础设施服务（Infrastructure Service）
开发和管理：开发规范，IT服务管理

** 服务的分层、分组及现状



** SOA规范
SOA的若干规范：SDO (Service Data Object), SCA (Service Component Architecture),
BPEL (Business Process Execution Language) 都包含了接口定义的内容。 

*** 接口规范
SOA的接口独立于编程语言和操作系统。我们把一个服务系统和外界的数据交互定义为服务的接口，
**** 接口定义要包含的内容
那么完整的接口定义要包含哪些内容
- 数据。首先需要对在一个服务系统和外界之间交互的数据做定义。 
 | 内容         | 说明                                                                                                                                                                                                                                                                                                                            |
 |--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | 数据类型定义 | 每个编程语言都有自己的数据类型定义，XML Schema也有数据类型定义。数据类型包括基本类型和复杂类型。                                                                                                                                                                                                                                |
 | 数据格式     | 指在内存，文件或者线上的各种数据类型的数据如何排列存放，特别的是复杂类型的数据如何存放。C语言中的Struct对象在内存里有其自己的数据格式，Java语言的Object对象在内存里按即定的数据格式存放，XML是一个典型的使用字符描述复杂类型数据的数据格式规范。很多C/S系统定义报文格式，在线上收发二进制流。8583即是银行也常用的一种报文格式。 |
 | 数据内容     | 数据内容一般划分为技术和业务两个层次。技术层面的内容一般是在服务和外界之间交互的数据报文头信息；业务层面的内容就是数据报文体信息。在业务层面，现在有越来越多的行业业务数据内容规范，例如电子商务的ebXML, 金融交易的FIX协议等。                                                                                                  |


- 交互。数据有了，还需要定义服务和外界交互的方式。数据在两个系统之间交互收发，有多种的模式和规范。 
 | 内容                   | 说明                                                                                                                                                                                                                                                                                   |
 |------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | 接口交互方式           | a.请求应答方式。即外界客户端向服务系统先发送一条数据作为请求，服务给外界客户端返回另一条数据作为应答。b.推送方式。即服务向客户端先发送数据，没有反向的数据。                                                                                                                           |
 | 请求应答数据内容       | 请求即输入数据的内容定义，应答即输出数据的内容定义。输出包括正常和异常输出。                                                                                                                                                                                                           |
 | 有/无状态接口调用      | 接口调用是有状态接口，还是无状态接口。使用同样的输入多次调用同一个接口，输出不变的是无状态接口，否则是有状态接口。                                                                                                                                                                     |
 | 同步，异步方式接口调用 | 对于客户端来说，同步方式指调用一个服务接口即可得到结果；异步方式调用可细分为两种实现方式：a. 客户端先调用服务的一个接口，若干时间后再调用服务的另一个接口获取前一个接口调用的结果数据；b. 客户端先调用服务的一个接口，服务执行完处理后，调用客户端提供的一个接口把结果数据发给客户端。 |
 | 接口调用规范           | 接口调用的会话(Session)机制，多个接口之间的调用顺序和规则。包括同一个服务的多个接口之间的调用规则，多个服务的多个接口之间的调用规则。例如Web Service的动态绑定调用技术就是按一定的规则调用UDDI服务， 和SOAP服务的多个接口。                                                            |
 | 通信方式和通信协议     | 一般来说客户端和服务不在一个节点上，服务接口是远程接口，需要基于一定的通信方式和通信协议。例如TCP, HTTP，SOAP，MQ消息中间件等。                                                                                                                                                        |

- 其他
 | 内容             | 说明                                                   |
 |------------------+--------------------------------------------------------|
 | 接口调用安全策略 | 客户端和服务之间彼此需要授权和认证。                   |
 | 事务             | 多个服务接口调用需要包含在一个事务内，具备执行原子性。 |
 | 日志             | 接口调用操作需要记录在日志中，以便管理和监控服务。     |

**** 参考规范：SCA、SDO、BPEL
下面我们来看，SCA,SDO,BPEL三个SOA领域的规范做了哪些接口内容的定义工作。 
| 内容                   | 说明                                                                                                                                              |
|------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------|
| 数据类型定义           | SDO规范中的SDO Data Type定义了基本类型和Object类型                                                                                                |
| 数据格式               | SDO没有固定的数据格式，但是提供统一的数据访问接口。SDO服务支持各种格式的数据对象。                                                                |
| 数据内容               | SCA服务定义中的Interface定义了服务和外界交互的业务层面数据内容。SCA Interface目前支持Java Interface和WSDL两种描述方式。                           |
| 接口交互方式           | 服务接口都是请求应答方式。                                                                                                                        |
| 请求应答数据内容       | SCA Interface定义了服务请求应答的数据内容。                                                                                                       |
| 有/无状态接口调用      | SCA Conversational Interface定义了有状态的接口。                                                                                                  |
| 同步，异步方式接口调用 | SCA Bidirectional Interface 定义了异步调用方式的接口。BPEL 中的partnerLinkType 也可以描述异步调用服务接口和与之相对应的Callback接口。             |
| 接口调用规范           | SCA Conversational Interface定义了多个接口之间的调用顺序和规范                                                                                    |
| 通信方式和通信协议     | SCA Binding定义了服务接口的通信方式和通信协议。通信协议可以理解为技术层面的数据内容。SCA支持多种通信方式，如Web service binding, JMS binding 等。 |
| 接口调用安全策略       | SCA Policy 中的Security定义了接口访问安全策略。                                                                                                   |
| 事务                   | SCA Policy 中的Transactionality 定义了接口调用的事务模式                                                                                          |
| 日志                   | 日志功能由服务平台内部实现                                                                                                                        |

三个规范都涉及到给服务定义统一的接口规范，有了统一的接口规范，就可以方便地调用不同技术实现的服务，这就是SOA解决异构接口互联互通的中心指导思想。从技术角度上讲，这也是SOA最主要的工作。 

*** 协议规范
*** 消息规范
** 目标与设想
