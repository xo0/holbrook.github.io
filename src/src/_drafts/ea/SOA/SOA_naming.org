祭奠SOA

SOA(service-oriented architecture）, 面向服务架构。听起来很简单，想想很糊涂。

SOA是一个筐，各厂商稀奇古怪、琳琅满目的东西都一股脑塞到这个筐里，让人无所适从。最后这个筐破掉了，
人们发现厂商宣称的如果xxx就能够xxx的承诺破灭了，于是“SOA已死”，厂商又开始兜售SOA的后来替代者，比如
mashups、BPM、SaaS，云。

但是，死掉的是“SOA”这个单词，这个噱头。IT人员对于整合的追求永远也不会终止。如果能够不被厂商眼花缭乱的产品
和华丽的辞藻所迷惑，SOA的精神


前世：CORBA，EJB，/  RPC, WebService
本质：带来分布式


为SOA正名

SOA(service-oriented architecture）, 面向服务架构。听起来很简单，想想很糊涂。

SOA已经成了一个筐，各厂商稀奇古怪、琳琅满目的东西都一股脑塞到这个筐里，让人无所适从。

本文试图为SOA正名：以形式逻辑的方法，确定SOA的内涵，外延，定义、划分、限制、概括

* SOA中的服务
* ESB:不能承受之重
咨询商只是少数几家公司可以做的事情，更多的还是软件厂商。搭乘SOA的春风，
ESB厂商

都在鼓吹自己


* 太多的标准=没有标准



* 五花八门的定义

已经有太多的组织为SOA做出了五花八门的定义。这些定义千差万别，甚至表达的主体都不相同，比如：

“一组策略、实践和框架，支持将应用程序功能作为一组服务在与能够调用、发布和发现的服务使用者相关的粒度发布；这组服务是使用接口的单一标准形式从实现抽象出来的。”（CBDI）

“面向服务的体系结构是一种客户机/服务器软件设计方法，其中的应用程序由软件服务和软件服务使用者（也称为客户机或服务请求方）组成。
SOA与更为通用的客户机/服务器模型不同，其定义强调软件组件间的松散偶合及对独立接口的使用。”（Gartner）

“面向服务的体系结构是一种用于根据需要对资源进行关联的企业级IT体系结构。这些资源被表示为与业务一致的服务，
这些服务可以参与和包含到价值网、企业或业务线中，以满足业务需求。SOA 应用程序的主要结构化元素是服务，而不是子系统、系统或组件。”（IBM）


“设计和开发能够互相调用服务的软件时所采用的一系列原则和方法论。服务体现为具有明确定义的业务功能，通过软件组件的形式构建（相互独立的代码和/或数据）,服务可以重用。”
（[[http://en.wikipedia.org/wiki/Service-oriented_architecture][维基百科]] ）


以上这些定义让人头痛欲裂，痛苦不堪。但忍痛读完这些拗口的文字，我们还是可以抛开华丽的修饰，找到一些关键词汇：

- SOA是策略、实践和框架/设计方法/体系结构/原则和方法论
- 服务具有明确的业务功能/与业务一致/满足业务需求
- 服务有合适的粒度, 服务可以重用
- 服务可以调用、发布和发现
- 服务抽象成接口的形式
- 服务的双方（提供者，使用者）松耦合
- 服务以组件的形式构建/服务不是子系统、系统或组件/将应用程序功能作为服务


** SOA中的服务

从前面对SOA的各种定义中，我们能看到对服务内涵的不同角度的说明，简单归纳一下：

- 业务角度
  服务首先要满足业务需要，服务要具有明确的业务功能，

业务角度的定义：
业务希望向其客户及合作伙伴或组织的其他部分公开的服务集。

体系结构角度的定义：
需要服务提供者、请求方和服务描述的体系结构风格。一组体系结构原则、模式和标准，以处理各种特征，如成熟度、封装、松散偶合、关注分离、重用、可组合性和单一实现。

实现角度的定义：
一种包括诸如 Web 服务等标准、工具和技术的编程模型。这些定义既包括 SOA 为业务完成的工作的高级视图，也包括关注基于 SOA 的解决方案的技术方面的定义


** 服务的描述
WebService（XML/SOAP/UDDI/WSDL）

webservice不是SOA唯一的可接口中立的描述方法。
但WebService是现在最成熟最有体系最获得业界厂商支持的接口中立描述方法
** 服务的粒度
从函数到对象，增加了函数的关系和聚合，增加了数据的分离；
从对象到组件，增加了事件和属性，组件生存在容器中；
从组件到服务，增加了接口，增加了业务含义，增加了xxxxx

公司里面有各个层级，服务也有不同的粒度



** 服务的实现

从技术的角度，解决的是异构接口的互通互联问题。
不同技术实现的服务有着不同的接口，怎样方便地在一个服务内部调用另一个服务的接口，
或者调用已有多个服务的接口实现一个新的服务？ 
一个自然的想法就是定义一个统一的接口规范，新开发服务的接口遵循这个接口标准，
或者服务开发运行平台提供新接口到已有各种接口的转换。事实上，SOA就提供了这些功能，
*** 历史
函数和变量写多了，自然也就发现有些函数和变量互相粘在一起很高耦合，而与其它的一些却没多达关系，于是为了显性化让其他的开发人员知道哪些函数和变量确实关联性很紧密，于是创造了类。面向对象在80年代的国外代码开发界颇为流行。
但接口思想的风潮在90年代刮起了。起闹的原因就是类被滥用，子类不断继承，发现随着企业业务发展变化，父类中实现的功能已经无法适合新时代业务了，现今业务和过去业务差异很大。而因为万丈高楼不能动父类中的方法功能了，否则子类就都瘫痪了。为了避免这个问题，就不让父类负责功能了。所以大量出现虚方法的父类，只有一个空的函数申明，函数里什么也没有。到最后发现只需要申明一下就可以，连函数这个空壳也不需要了，于是正式提出接口。
到了90年代中期，IT软件开发公司越来越专业了，大量企业IT部门不再自己开发软件而转为购买专业软件公司的软件。这样企业IT部门的IT人员对编程对技术越来越远，渐渐偏向了业务。企业IT部门谈业务流程和业务输入输出，IT公司谈对象，这就接不上去。于是IT开发公司发明了面向组件的业务分析方法、设计方法、开发方法。不要谈对象识别、对象分解、对象继承、对象调用关系，只谈你需要什么功能。功能用接口来表明能干什么，但这些接口是在内部被哪些类实现的，类之间的关系到底怎么回事，都不用解释给企业IT部门。这是企业IT部门和专业软件公司第一次以业务视角来谈软件。
到了2000年以后，互联网兴起。XML从HTML中脱胎而出，HTML专门发展成为可视化界面展示技术，XML走向纯粹数据表示，但都是文本型，便于通过HTTP在互联网上传输。IT人员为了程序更灵活，于是让接口申明也不用代码表示了，直接用XML表示了。接口中需要的参数，如传入一个订单需要修改，那么这个订单数据也被XML表示。另外，这些接口方法怎么串联在一起执行一个完整的业务流程，也用XML表示了。至于XML怎么和代码动态绑定在一起，那就让底层技术去想吧。于是，IT公司和企业IT部门只要一起谈某个业务的处理流程、每步处理方法、处理的输入和输出就OK。把这些谈好的画出来，存储的时候保存成XML格式就OK，就如同咱们OFFICE2007就可以把EXCEL另存为XML格式一样。从这样来看，现在的IT软件开发公司和企业IT部门已经越来越一致的以业务来谈，而不是以技术来谈。一致面向业务来谈、XML式定义与动态绑定而不用去管用什么具体技术来实现这些功能，这是最关键的特征进步。这就是SOA。
从一步步来看，软件公司的开发人员的需求分析方式、软件设计方式、代码开发实现方式都已经变化很多了。面向业务流程和业务数据来谈，接口定义，内部实现具体编码类就OK。底层框架真正负责这些XML接口定义和具体组件的绑定、创建、销毁、内存回收、并发、池化、序列化、访问安全、事务保证。这个底层就是中间件。过去有EJB中间件服务器、COM+中间件服务器（MTS）、CORBA中间件服务器。现在加入了功能接口、业务数据的动态XML绑定以及业务流程的动态解释执行，就被升级命名为ESB，意思就是希望通过XML定义和传递，来达到不同技术的组件（EJB、COM+、CORBA）都能互通。这和XP升级到VISTA或WIN7一样的，都是继承性发展过来的。但就是叫不同的名字，就要把WIN6叫做VISTA，就要把WIN5叫做XP。
在10年前，很多人问过我：“你的软件是三层的吗？你的软件是面向组件的吗？”。好像意味着面向组件就可以灵活组装软件。现在又有人问我：“你的软件是面向SOA的吗？”。我在想，我的软件UI界面是XML描述的、Report是XML描述的、功能函数是XML申明的、业务处理流程也是XML定义的，数据也是XML定义的，而且也是工具来画出来保存成XML而无需手工直接编写XML。但就是这样也不是普通人员能够搞的，几千个业务数据定义、几千个功能函数、复杂的业务处理流程，不是熟练手天天搞是很难直接下手修改并且调试确保正确的。从本质来说，XML不就是把写死的代码换成有固定规格的文本了么？在程序员眼里，源代码也是ABCD的文本，XML也是ABCD的文本。



*** SCA，SDO
SOA是一个组件模型。组件模型我们知道，
COM+、EJB都是组件模型。组件有属性、方法、事件。组件运行在组件容器中。组件容器来保证组件的创建、并发、池化、日志、销毁。
组件是脱胎于对象的。看看各个语言实现的组件模型，其实现都是应用对象模型。
对象具有数据和方法，没有事件。而数据，也没有什么读写限制。这是组件和对象非常明显的区别。



有了SCA和SDO，SOA概念踏实多了，否则和过去的面向组件和现在微软鼓吹的webservice式的SOA很容易迷惑。
SCA是SOA的落地规范，否则SOA就是个概念。 


SDO是为了规范接口间的传输数据的格式和数据操作的规.否则，你传输的XML就自己瞎编格式了
SCA和SDO是OSOA组织制定的


* 消息的传递
* SOA vs EAI

ESB特点但用于区分相关EAI和ESB产品，一个是星形结构的，而另一个是总线结构的ESB产品。星型结构模型是一种集中式的架构，所有的数据交流都由中心点来处理。该星型结构模型可以被看作
继承的点对点模式 。而总线模型，采用分布式体系结构，其中的ESB 功能，可以由几个其他物理产品来实现其功能。 第二个用于区别的EAI和ESB产品是使用开放标准是什么。EAI的产品，如WebSphere的消息代理，TIBCO的BusinessWorks ，和Sonic XQ使用一个专利技术来实现信息功能及传送逻辑。而ESB产品是基于开放标准，如Java消息服务（ JMS的） ， XML和J2EE连接器架构（ JCA的） ，和Web服务标准。




* 有了服务，接口，实现，服务的规划，是否就是SOA？
是的，已经实现了SOA。
但可以做的更好。


但是这里面的每个概念都是含混不清的：

- 什么是“服务”？
- 如何“面向”？“面向”到什么程度？
- “架构”指的是方法、过程、风格还是结果？

一些扩展的问题：
** 路由功能：进一步松耦合
** 标准协议与格式转换
** 
   
** ESB，进一步松耦合
** ESB与消息中间件
** ESB与BPEL与工作流
BPEL强调基于服务的自动流程；
工作流更适合人工参与
BPEL调度业务服务；ESB调度和组装其他粒度的服务

BPEL是为了编排连接各个服务的，BPEL不是为了工作流审核审批的。根本就是两个目的两码事，不要混淆。用BPEL实现工作流，或者用工作流想实现BPEL，都是错误思路。
ESB是运行服务，并且驱动BPEL的。


* SOA是一种世界观
世界观：
方法论：
设计：
实现：
目标：有些定义将目标描述为SOA本身

从服务、基于服务开发和服务的结果来看，向服务是一种思考方式。


SOA架构样式
   * 基于服务的设计，这些服务代表的是组成企业业务流程的业务活动
   * 服务提供上下文描述（业务流程、目标、规则、策略、服务接口和服务组件），使用服务编排来实现服务
   * 对技术设施提出要求，建议采用开放标准，以便更好的实现可交互性和透明性
   * 实现是基于特定环境的，约束和使能都必须在上下文中进行描述
   * 服务描述和实现需要很好的治理
   * 需要进行验证式的测试之后才能决定这个服务是否好的服务



SOA
   * SOA并不会增大IT系统的内容，但是会提高它们的可交互性
   * IT系统执行一些被明确定义和描述业务活动上下文的服务
   * 之前的应用是那种大的、一整块的应用，只有很小的可交互接口，比较勉强的做集成，对交互也不提供保证。而SOA提供一些小的、模块化的服务，这些服务接口被清晰描述和约定。
Overview of SOA
SOA架构维度
   * 成功应用SOA需要具备丰富的知识和技能
   * SOA不能解决所有IT问题，IT架构师必须知道什么时候以及如何使用SOA
   * SOA将是一个大的投资，是从企业长期战略来考虑的
   * 有时候，技术可能会改变战略，但是业务需要和可能性仍旧是主要驱动力。这也是引入企业架构的原因，企业架构会依据企业的长期战略来设计IT战略。
SOA和无边界信息流（Boundaryless Information Flow）
   * The Open Group的愿景是Boundaryless Information Flow.


   * 因为SOA可以带来无边界信息流，所以SOA在The Open Group占据了重要地位
   * 使用服务来替代应用


SOA给企业带来敏捷有三个不同的方法来实现企业敏捷性

   * 服务组合
   * 模型驱动开发
   * 服务虚拟化
架构师能够把这些方法都应用到SOA上，但是它们需要不同的基础设施的支持，
你必须根据需求来选择合适的方案。



* 世界观并不能改变世界，它只存在于我们的意识中，对现实世界毫无影响。
要让世界观发生作用，要解决很多问题

服务的描述：让双方能够理解
webservice，SCA，


虽然，一再声称WebService（XML/SOAP/UDDI/WSDL）不是SOA唯一的可接口中立的描述方法。
但事实上，WebService是现在最成熟最有体系最获得业界厂商支持的接口中立描述方法。
所以，无论业界厂商怎么辟谣说WebService不是唯一方法，但大家都已经默认。


** WebService
** ESB
** BPEL
** EAI
在做SOA项目实施的时候，经常有客户问我SOA和EAI（Enterprise Application Integration）的联系和区别。
如果不考虑SOA在设计思想上倡导基于分布的可复用的服务集合来构建企业信息化系统，
单从技术的角度，SOA与EAI在提供统一的数据和接口定义，连接已有异构系统方面，他们的设计思想和实现方式是很相似的，
甚至可以说是相同的。

只是SOA使用开放的规范标准，EAI厂商都是使用自己私有的标准。 

于是乎我给SOA赋予一个新的名称：企业接口集成（Enterprise Interface Integration）, 

或者是企业组件接口集成（Enterprise Component Interface Integration）。

** SCA编程模型
服务组件框架
　　服务组件框架（SCA）提供了一套可构建基于面向服务的应用系统的编程模型。它的核心概念是服务及其相关实现。服务由接口定义，而接口包含一组操作。服务实现可以引用其他服务，称为引用。服务可以有一个或多个属性，这些属性是可以在外部配置的数据值。
　　SCA中的一个关键推动因素是Service Data Object（服务数据对象，SDO）。
　　SCA组件被组成为程序集。程序集是服务级的应用程序，它是服务的集合，这些服务被连接在一起，并进行了正确的配置。SCA程序集运行在两个级别：第一种情况，程序集是系统内的一组松散连接的组件；另一种情况，程序集是模块内的一组松散连接的组件。二者的区别在于，一般来说，模块是组件的集合，而系统是模块的集合。此外，系统对应于“大规模编程”（programming in the large或megaprogramming），而模块对应于“小规模编程”（programming in the small）
　　将组件连接到它所依赖的服务的方式就是服务网络“装配”的方式。程序集已经在许多技术和框架中广为应用，比如CORBA、J2EE、ATG Dynamo和Spring，也就是说，它并不是新出现的。从这些技术中我们可以知道，程序集提供了许多重要的优点，比如更轻松的迭代开发，以及避免使业务逻辑依赖于中间件容器。SCA使用程序集解决了许多SOA开发中的重要问题，包括：
　　业务逻辑与底层基础架构、服务质量和传输的分离。
　　“小规模编程”与“大规模编程”的联系。
　　为架构的设计、编码和操作性部署在自底向上（bottom-up）和自顶向下（top-down）两种方法中来回切换提供了一种统一的方式。

** M$
WCF+Webservice实现模型---SCA
LINQ+ADO.NET---SDO

不符合标准


* SOA的三个层次
1. 服务及接口定义
2. 平台
3. 平台+方法论


* 方法论

  SOA不仅仅是基础设施，它牵涉一组知识和最佳实践，一种一致的概念方法，一个企业蓝图，一个参考模型，
一个参考架构，业务流程建模，一种严格的和基于标准的方法。 
    一个服务架构需要在3个级别定义：

        规范架构
        实现规范
        部署架构

这些视图代表了CBDI SAE元模型的核心。其它支持它们的视图包括：业务建模、组织、策略、服务建模、软件建模和技术。 




SOA，不是面向组件升级到面向服务这么简单。是我们的软件分析方法、软件设计方法、软件开发方法的变革。是业界对过去这些理论和产品的反思。业界对世界的抽象方法变了。
SOA需要将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。但怎么联系起来。高内聚，低耦合是我们一贯的原则。像过去我们互相开放DLL的方式根本不合适，都是硬编码进自己的系统中。一旦接口改变，都需要修改。幸好，业界发现了有个工作流的东西，听说可以驱动业务流程。于是，满心欢喜的奔了过去。
真正一用才发现不对。工作流的规范世界早已固定。工作流产生的时候，还没有SOA呢。SOA需要的业务流程连接，工作流的原理类似，但并不是最适合软件服务的连接。于是，业界又集体联合起来研发了BPEL，业务流程处理语言。但有些工作流厂商也唯恐被称为落后时代脚步，于是强嘴说自己已经是SOA了。于是，业界李鬼李逵一堆。各有各的利益，各唱各的调。
SOA这种世界观也需要落地到一个可实现的框架。于是SCA和SDO出现。SCA是SOA的落地架构框架规范，SDO是数据结构规范和数据存取原理规范。而这些规范，用现有的开发语言和技术框架都可以实现。所以，对于现有系统，无须认为现有的系统落后了，不符合SOA了，需要重新上一套SOA软件了。
但是，我粗略阅读SCA规范，特别类似于我过去熟悉的组件模型体系。只不过SCA在组件模型基础上又提供了服务定义和服务Wire。组件模型是提供了个体的规范，而SCA不仅提供了个体，更提供了个体之间连接的规范。组件模型让我熟悉了接口与实现的分离，让我熟悉了容器运行保护，让我熟悉了元数据管理。没有经过面向组件时代的人，不会感受到SOA到来的必要性。
我们曾经用组件模型开发应用软件，其目的就是想像这些组件都是独立的个体，然后我们用一种脚本把这些组件穿在一起（过去我想到是VBA脚本，然后是Javascript脚本，然后是ASP脚本，然后又关注了工作流，均不满意，最后才落眼到BEPL）。而如今，SCA、SDO、BEPL、ESB给我们多年的设想提供了可落实的体系模型。我们需要这样灵活组合的应用软件，我们不需要一个上千个参数配置的航母软件（如SAP R/3）。
只有了解了SOA、BPEL、ESB的前生后世，我们才能平和的看待这些技术，看待和这些技术相关的技术，我们才能有的放矢的去学习它、利用它，为我们更快速的适应客户需求变化而有益。
最后一句话：
对于我个人从业经验，我经历过面向过程、面向对象和面向组件三个架构思想的产品开发历史，我们一直试图解决软件组件粒度灵活组合的问题，我学习技术也一直是抱着解决问题而研究，而不是怕赶不上潮流而学习。我个人片面的认为SOA的架构思想就是我们过去应用的面向组件思想的延伸，然后再套上WebService的外壳，我们过去开发COM+，为了跨防火墙为了异构连接CORBA可费死了劲。SOA还结合了业务灵活的BPEL思想，整合了中间件消息总线WebService治理的技术思路。SOA整合了这么多架构思想和企业产品技术，根本目标就是使我们的IT更加灵活。我们过去做面向组件也是为了这个根本目标。SOA就是通过面向业务的分析方法+WebService中立技术+BPEL脚本业务编排+ESB服务治理总线中间件来达到IT灵活的。
SOA是面向服务，OO是面向对象。就这么简单，一个问题领域。SOA不是EAI，不是系统集成的一种方式。那是业界某些公司为了达到自己的利益目的做的宣传，混淆大家的视听。怎么学习面向的时候，没有人提这些系统集成。到了面向服务，就牵扯到系统集成了？被人忽悠了？过去我做企业集成，用的是读取数据库，然后是DLL，然后是WEBSERVICE，但没有使用SOA。
过去业务设计使用的是一种思路，软件设计使用的是另一种思路，老对接不上去，SOA统一了。都必须从业务角度看问题，而不能一方是流程，一方却是类图和时序图。


给大家举一个例子。

有一个业务，是用户在网站上选择自己想买的车型，然后点一下计算，就显示自己购这台车的总费用。
那这个功能就是一个软件服务。SAAS，软件即服务。
业务设计员设计好这个业务。功能设计员就定义了一个软件服务接口，可能叫CalcTotalFee(CarType:XML)。
用户输入的数据，被程序员程序处理成SDO传入，调用服务接口，返回总费用。但接口里面是怎么计算的，用了哪些OO技术或组件技术，或干脆就是大流水帐代码，那是你程序员自己的事情。而业务设计员和功能设计员是统一认识的。
这就是业务设计、功能设计、功能开发三者的关系。



* SOA与SaaS

* SOA的功能和作用
| 功能                        | 作用                                                         | 基础设施                           |
|-----------------------------+--------------------------------------------------------------+------------------------------------|
| Service                     | 改善的信息流，对外公布的能力，功能组织的灵活性               |                                    |
| Service Re-use              | 低的软件开发和管理费用                                       | Service repository                 |
| Messaging                   | 配置灵活性                                                   | Messaging program                  |
| Message Monitoring          | 商业智能BI，绩效度量，安全攻击检测                           | Activity monitor                   |
| Message Control             | 应用管理策略，应用安全策略                                   | PDPs and PEPs                      |
| Message Transformation      | 数据转换                                                     | Data translator                    |
| Message Security            | 数据机密和集成                                               | Encryption engine                  |
| CEP                         | 简化软件结构,快速适配外部不同环境的能力,提高可管理性和安全性 | Event processor                    |
| Service Composition         | 快速开发新的功能组合                                         | Composition engine                 |
| Service Discovery           | 优化绩效、功能和成本的能力, 更容易的系统升级                 | Service registry                   |
| Asset Wrapping              | 集成现有资产的能力                                           |                                    |
| Virtualization              | 提高可靠性, 可以扩充满足不同要求级别                         |                                    |
| Model-driven Implementation | 快速开发新功能                                               | Model-implementation,  environment |


* 新的目录
** SOA：什么是服务
** 服务分组
** ESB: 服务的中介
** SOA之后是什么
整合，永远的战争

函数-->对象-->组件--> EAI ---> SOA-->MashUp? 云？

*** REST会是SOA的未来吗？
SOA可能会有很多种未来，但一定不是REST。

*** mashup？
*** 云？

下一盘更大的棋

SaaS：这里服务的对象是人

PaaS：原来的SOA中的服务

IaaS：将技术底层也放到“服务”这个筐里面
* 厂商的SOA参考
OpenGroup发布的SOA参考架构 https://www.opengroup.org/projects/soa-ref-arch/uploads/40/19713/soa-ra-public-050609.pdf

主流SOA供应商
IBM通过参考架构实施SOA解决方案 http://www.ibm.com/developerworks/library/ar-archtemp/
Oracle与F5的SOA参考架构http://www.f5.com/pdf/solution-center/f5-oracle-architecture.pdf
