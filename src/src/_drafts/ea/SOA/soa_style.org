|          | WebService         | RESTful       |  私有，如Thrift
|----------+--------------------+---------------|
| 业务分解 | 服务               | 资源          |
| 请求定义 | RPC, Message       | REST          |
| 接口描述 | WSDL               | 文档 or ?     |
| 通信协议 | HTTP,SMTP,JMS,XMPP | HTTP          |
| 消息格式 | XML                | Json,XML,YAML,Html  |
| 消息封装 | SOAP               | 无            |
|          |                    |               |

* WebService和RESTful
广义上讲，可以通过Web访问的API接口都可以叫做[[http://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1][Web service]]。严格的Web Service是指使用SOAP。。。
REST是代表性状态传输的名称首字母缩写，与其说它是标准，不如说是一种风格。

* 服务与资源
服务是一个动词，能够根据请求触发某种“动作”。
资源是一个名词，在IT领域代表特定的数据。

通常服务的粒度较粗，而资源的粒度更细。一个服务通常会访问多个资源。

WebService将一组动作绑定到特定的URL。
RESTful将一种资源绑定到特定的URL。

* RPC、Message和REST
对于服务的请求，可以使用RPC风格或Message风格定义。
RPC风格对不同的动作定义不同的入口，从而允许每个动作的调用可以使用不同的请求参数；
Message风格使用统一的格式定义所有动作的请求和响应，所有的动作只有一个“执行”的入口。
REST对资源定义了一组通用的操作入口，包括：
- GET：获取资源
- PUT：创建资源
- POST：更改资源
- DELETE:删除资源
- HEAD：获取资源元数据

REST允许针对不同资源的操作定义各自的参数。



* WSDL必要吗？
一个普遍的观点是REST要比SOAP简单得多。照这个观点，REST简单的根源基于一个事实：REST不需要WSDL或任何接口定义。至少可以认为这种论调有点天真。无论哪种用于服务消费者和提供者之间通信的技术，都必须在语法和其消息交互（接口）[13]的语义上达成一致。这意味着就REST而言，下面两个方法有一个是可能的：

   * 以文本方式定义一个接口，并基于接口文档描述中的通用接口定义来“手工地”编写数据的编码/解码。虽然这种方法常被REST拥趸所推崇，其接口包含的元素很少超过10到15个，但这不是典型的粗粒度REST服务。而且，这种方法很容易出错，所以，大部分可行的REST框架都遗弃该方法而使用下面的方法。
   * 在XSD的层次定义接口，基于流行框架（比如，面向XML的JAXB或Castor，面向JSON负载的Jackson）产生数据的编码/解码。这种方法效果上就是WSDL的简约版，并且需要的工作量和基于SOAP实现差不多一样。事实上，完全相同的方法经常被用于基于SOAP的实现，设计一个单独接口和服务执行的命令模式。WSDL2.0 和/或 WADL for REST就是对该方法的扩展。


* SOAP or NO SOAP
REST是直接实现于HTTP协议之上，而SOAP引人了一个抽象层（SOAP消息传递），这可以在任何传输协议之上实现。标准化SOAP绑定目前存在于HTTP、SMTP和JMS之上，而非标准化绑定已经在其他一些协议解决方案实现了。这层额外的抽象层（提供协议和基于SOAP实现之间的解耦）是造成SOAP和REST Web服务区别的根源。
对于这一抽象层的看法很大程度上取决于不同的人。REST阵营认为它是过度设计的产物，并声称没有提供任何实际价值。他们声称HTTP已经提供了服务交互实现必需的所有特点。而SOAP阵营，从另一方面，争辩道HTTP并不是服务交互（尤其在企业内部）通常所需的唯一协议，而设计一个方便的、可扩展[10]的抽象层对构建健壮的、功能丰富的服务交互是很有必要的。
虽然两种观点都有其可取之处，但我认为把SOA实现限制到单一协议，即HTTP，实际操作起来不太可行。诚然，HTTP是无处不在，并且其使用方法一般也无需投资额外的基础设施，但是HTTP是不可靠的（HTTP-R没有广泛被采用）、同步的（产生了瞬时的耦合）[11]、而且也没有事务语义等等。
再者，就算认为HTTP是在实现中使用的唯一协议，也可以非常方便的利用SOAP信封把业务信息（SOAP 消息体）和基础设施信息或附加信息（SOAP 消息头）从SOAP消息中隔离。总的来说，如果你本来的实现并不需要任何基础设施或附加数据，整个SOAP信封的开销是很少的——只需两个标签，而且对必要时添加数据提供了明确定义的方法。
所以，从各个方面来看，以数据信封的方式将业务信息和基础设施关注分离是很强大的模式，甚至REST Web服务实现也常常使用这种方法。至于是否使用标准的SOAP还是定制化信封[12]模式要根据具体实现而定。

另一个SOAP常常被抱怨的就是复杂的WS*标准集。虽然不存在一个单独的规范来罗列这些关键的WS*标准集以及其彼此的关系，但对大部分服务交互用例还是存在一个标准的。就算如此，选择一个适当的WS*标准和其用法可能也需要一些额外理解和实现时间，但是：
在REST和SOA之战中争论简单化还是标准化是荒唐的，因为没有标准支持的简单只能有害于成本和应用的可管理性。
所以，除了那些简单到极点的例子之外，如“温度转换器”，REST并不比SOAP简单多少。


另一个众多REST拥趸宣扬REST是SOAP的一种取代的原因是，实际上的REST请求和响应消息都较短。这主要基于两个原因：

   * SOAP需要一层XML包装器来包装所有的请求和响应消息，这会增加消息的大小。这话没错，但重点不是包装器增加了多少字节，而是它创建在整个负载中的比例。因为包装器的大小是固定的，其所占比例随着消息的不断变大而变小，最终可以忽略不计。考虑到一般服务都是相当粗粒度的，请求和回复消息的大小也是相当大的，所以SOAP信封的负载不太会成为大问题。
   * SOAP是基于XML的消息传输，而XML使用冗余的编码。REST，在这方面，提供了更轻量级的消息传输替代方案——JSON[14]。这话也对，但利用消息传输优化机制（MTOM），大部分SOAP框架都支持，可以把消息拆分成多个小的基于XML的SOAP信封/头/体部分，而附加的包含消息内容的部分可以编码为任何MIME类型，包括JSON和二进制流等。
虽然理论上讲，REST要比SOAP轻量级，但实际上，利用一些高级SOAP设计技术，真正使用中的SOAP和REST消息大小的差别是很小的。



* SOA风格

** 面向服务的REST风格？
REST不仅不是面向服务的，相反，面向服务和REST风马牛不相及

综上所述，不可能使用本真REST来构建SOA系统。构建系统可以，但一定不是SOA。两者都可以从与业务一致的分解入手，但是由于各自使用截然不同的分解方法，它们最终得到的也是基于不同组件和连接器的完全不同的架构风格

仅仅因为它们都试图解决同一个问题——业务与IT对齐，并且都基于业务驱动的分解，并不能表明最终的架构风格也是一样的。
另一个问题在于能否可能使用本真REST来构建一个完整的系统。鉴于上述理由，这个问题等价于能否可能只使用数据库或实体bean来构建一个完整的系统。当然你可以了，但是需要以存储过程（重写方法的本意）的方式增加处理代码，或者触发器（完成基于数据变化的后置处理）。这同样适用于本真REST实现—你只有通过改变modifyResource方法的本意（通常使用命令行模式）来实现不止数据更新这个方法。
因此，某个基于REST的实现和本真REST是大相径庭的；一般来说其包含了至少一些REST Web服务的元素。那么REST Web服务是什么呢？


* REST Web服务
REST Web服务方法是指单纯使用REST技术作为通信手段来构建SOA的一种方法。在这种情况下，服务由SOA风格的分解来定义，而基于REST的Web服务[9]作为通信。
虽然一般也被称为REST，这种方法其实和本真REST没有一点关系，倒是和POX（plain old XML over HTTP）很类似，不过与POX不同的是，它不仅支持XML，还支持其他数据类型，比如JSON（JavaScript Object Notation）、ATOM、二进制数据块。而且，它不像POX那样通常只基于GET和PUT，它基于更多的HTTP方法。
归功于Web的优势和Ajax技术的遍地开花，使用JSON逐渐变成主流的方法；大部分流行的浏览器都内置对JSON支持。由于在JavaScript中处理XML（尤其是带有很多命名空间）并不是一件容易的事，所以，Web实现使用基于JSON的REST Web服务要容易的多。面向Web交互的REST Web服务的扩增导致了这些技术的日益流行和广泛传播。


