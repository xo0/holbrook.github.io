JPA实践

经验：hibernate2，现实：JPA
* CRUD和DAO
 3、创建BaseDao
       在com.ajax.core包下面新建BaseDao抽象类，里面定义的是持久化操作方法，有一点特别要注意，一定要在增加、删除、修改这几个方法中加入事务控制，不管是在BaseDao基类方法中加，还是在业务方法中加，一定要加事务控制，大象觉得在基类中加会比较好一点，这样做代码显得更少更简洁。如果不加事务控制，那么增、删、改这些操作都不会产生效果，因为默认情况下，它不会进行自动提交。在做这个例子的时候，这个问题曾经困扰了我好长时间。因此，请大家记住不要再犯和大象一样的错误！贴出部分代码，详情请看源码，里面有很全面的注释。
/**
 * 抽象Dao类，用于持久化操作
 * @author 菠萝大象
 * @version 1.0
 */
public abstract class BaseDao<T> {
private static Log log = LogFactory.getLog(BaseDao.class);
/**
     * 获取Hibernate的Session对象
     */
    public Session getSession(){
        return HibernateSessionFactory.getSession();
    }
/**
     * 根据主键得到对象
     */
    public T getObject(Class clazz, Serializable id){
        return (T)getSession().get(clazz, id);
    }
/**
     * 保存对象
     */
    public void saveObject(T t) {
        Session session = getSession();
        Transaction tx = beginTransaction(session);
        try{
            session.saveOrUpdate(t);
            tx.commit();
        }catch(Exception e){
            tx.rollback();
            log.error("保存对象失败");
        }
    }
/**
     * 创建事务
     */
    private Transaction beginTransaction(Session session){
        return session.beginTransaction();
    }
}
    

public boolean addUser(User user) {  EntityManager em = getEntityManager();
   try{
     em.getTransaction().begin();
     em.persist(user); 
     em.getTransaction().commit();
   } finally {
    em.close();
    return false;
   }
}

   * Next  add the code to UserController to remove a record

public boolean removeUser(Users user) {
  EntityManager em = getEntityManager();
  try{
    em.getTransaction().begin();
    Users userx = em.find(Users.class, user.getUserId());
    em.remove(userx); 
    em.getTransaction().commit();
  } finally {
    em.close();
    return false;
  }
}

   * Finally add the code to UserController to update a record

public boolean updateUser(User user) {
  EntityManager em = getEntityManager();
  try{
    em.getTransaction().begin();
    User userx = em.find(User.class, user.getUserId());
    userx.setUserName(user.getUserName()); 
    userx.setPasswd(user.getPasswd());
    userx.setEmailAddress(user.getEmailAddress());
    em.getTransaction().commit();
  } finally {
    em.close();
    return false;
  } 
}
* JPA实现
JPA定义的是标准接口
目前的实现：hibernate，openJPA，Toplink（以前属于Oracle，现在是EclipseLink）

* ---JPA实践
* 开发工具的选择
maven
* 例子
企业通讯录


* annotion or xml
JPA支持annotion或xml两种形式描述对象-关系映射。
annotion直接在java代码中描述；XML元数据信息以 orm.xml命名，放置在类路径的META-INF目录下。
按照JPA的规范，如果你提供了XML元数据描述信息，它将覆盖实体类中的注解元数据信息。。


映射关系是对实体类的一种描述。对于类的描述要尽可能贴近类代码本身，而annotion是距离最近的选择。所以个人推荐使用annotion来描述映射关系。
XML描述只用于在无法修改源代码的情况下需要修改映射关系。

* JPA实现的选择
JPA是一个标准，有很多实现
| 实现         | 当前版本 | spring | 增强 |
|--------------+----------+--------+------|
| Hades        |          | 支持   |      |
| Hibernate    |          |        |      |
| OpenJPA      |          |        |      |
| EclipseLinks |          |        |      |
* 正确使用延迟加载
原理：
   * 在一个实体上调用persist()操作，将广播到和实体关联的其他实体上，执行相应的级联持久化操作；
   * 如果实体声明为级联删除(cascade=REMOVE 或者cascade=ALL )，被关联的实体也会被删除;



JPA声明了entity instance life cycle的几个callback方法：PrePersist、PostPersist、PreRemove、PostRemove、PreUpdate、PostUpdate、PostLoad，对其语义进行了比较详细的说明


既然现在已经知道了如何配置延迟加载以及它的工作方式，那么我们如何才能正确地使用它呢？
第一步是检查所有的关联，查看哪些应该被延迟加载而哪些应该被即时加载。我的经验法则是开始先把所有的*对一关联都保留为即时的（这是缺省情况），他们在通常情况下的查询数目的合计无论如何都很难达到一个很大的数量，如果数量真的很大的话，我可以修改这些关联。然后我会检查所有的*对多关联，任何它们中的关联如果其指向的实体总是被访问因而总是被加载的话，我就会把他们配置成即时加载的，有时候我会使用Hibernate特有的@CollectionOfElements注解来映射这种“值类型”的实体。
第二步是最重要的，为了防止所有的LazyInitializationException或者NullPointerException异常，你需要确保所有对领域对象的访问在同一个事务内部发生。当领域对象在事务完成之后被访问时，持久性上下文不能再被访问以加载持久对象，因此会导致这些问题的出现。有两种方法可用来化解这一矛盾：
1.         最纯粹的方式是在服务之前放置一个服务门面（Service Facade）（如果你喜欢的话远程门面（Remote Facade）也行），并通过传输对象（即Data Transfer Object，又名DTO）只与服务门面的客户通信。门面负责把所有适当的值从领域对象拷贝到数据传输对象中，包括引用和集合的深度拷贝。应用的事务范围应包括服务门面这样的工作模式，即给门面设定@Transactional注解，或者为它指定一个适当的@TransactionAttribute。
2.         如果你正在使用MVC框架来编写模型2（Model 2）web应用的话，另一种被广泛使用的办法是在视图模式中使用打开的EntityManager，在Spring中可配置一个Servlet过滤器或者Web MVC拦截器，这样当请求进来的时候，过滤器或者拦截器会打开实体管理器，并保持管理器的打开状态直到请求的处理完成。这意味着在控制器（controller）和视图（view）（JSP或者其他方式）中活动的是相同的事务。或者一些纯粹控会争辩说，这种做法会导致表现层依赖于领域对象，但对于简单的web应用来说，这是一种令人感兴趣的方式。
第三步是启用JPA提供程序的SQL日志功能来检查应用的一些用例。这对于了解实体被访问时哪些查询被执行很有启发作用。SQL日志还能够提供性能优化的输入，因此你能够重新审视在步骤一中所作的决定并对数据库进行调整。最终延迟加载都会与性能有关，所以不要忘记了本步骤。



* 是否需要DTO？
* JPQL的Date参数

如果你需要传递java.util.Date或java.util.Calendar参数进一个参数查询，你需要使用一个特殊的setParameter()方法，相关的setParameter方法定义如下：
public interface Query
//命名参数查询时使用，参数类型为java.util.Date
Query setParameter(String name, java.util.Date value, TemporalType temporalType);
//命名参数查询时使用，参数类型为java.util.Calendar
Query setParameter(String name, Calendar value, TemporalType temporalType);
//位置参数查询时使用，参数类型为java.util.Date
Query setParameter(int position, Date value, TemporalType temporalType);
//位置参数查询时使用，参数类型为java.util.Calendar
Query setParameter(int position, Calendar value, TemporalType temporalType);
因为一个Date或Calendar对象能够描述一个真实的日期、时间或时间戳.所以我们需要告诉Query对象怎么使用这些参数，我们把javax.persistence.TemporalType作为参数传递进setParameter方法，告诉查询接口在转换java.util.Date或java.util.Calendar参数到本地SQL时使用什么数据库类型。
下面通过实例来学习JPQL语句，例子的entity Bean有Person, Order, OrderItem，他们之间的关系是：一个Person有多个Order,一个Order有多个OrderItem。
JPQL语句的大小写敏感性：除了Java 类和属性名称外，查询都是大小写不敏感的。所以，SeLeCT和sELEct以及SELECT相同的，但是com.foshanshop.ejb3.bean.Person和com.foshanshop.ejb3.bean.PERSon是不同的，person.name和person.NAME也是不同的。
* 部分查询和查询构造器

查询部分属性
通常来说，都是针对Entity类的查询，返回的也是被查询的Entity类的实体。JPQL也允许我们直接查询返回我们需要的属性，而不是返回整个Entity。在一些Entity中属性特别多的情况，这样的查询可以提高性能
//只查询我们感兴趣的属性(列)
Query query=em.createQuery("select p.personid, p.name from Person p order by p.personid desc ");
//集合中的元素不再是Person,而是一个Object[]对象数组
List result = query.getResultList();
if (result!=null){
Iterator iterator = result.iterator();
while( iterator.hasNext() ){
Object[] row = ( Object[]) iterator.next();
int personid = Integer.parseInt(row[0].toString());
String PersonName = row[1].toString();
查询中使用构造器(Constructor)
JPQL支持将查询的属性结果直接作为一个java class的构造器参数，并产生实体作为结果返回。例如上面的例子只获取person entity bean的name and personid属性，我们不希望返回的集合的元素是object[]，而希望用一个类来包装它。就要用到使用构造器。
public class SimplePerson {
 private Integer personid;
private String name;
public SimplePerson() {
public SimplePerson(Integer personid, String name) {
this.name = name;
this. personid = personid;
查询代码为：
//我们把需要的两个属性作为SimplePerson的构造器参数，并使用new 函数。
Query query = em.createQuery("select new com.foshanshop.ejb3.bean.SimplePerson(p. personid, p.name) from Person p order by p.personid desc");
//集合中的元素是SimplePerson 对象
List result = query.getResultList();
if (result!=null){
Iterator iterator = result.iterator();
while( iterator.hasNext() ){
SimplePerson simpleperson = (SimplePerson) iterator.next();



* 环境和配置
** 选择JPA实现

** 基本配置
META-INF/persistence.xml
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence" version="1.0">
  <persistence-unit name="JPAService" transaction-type="RESOURCE_LOCAL">
    <properties>
      <property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/>
      <property name="hibernate.hbm2ddl.auto" value="update"/>
      <property name="hibernate.connection.driver_class" value="org.hsqldb.jdbcDriver"/>
      <property name="hibernate.connection.username" value="sa"/>
      <property name="hibernate.connection.password" value=""/>
      <property name="hibernate.connection.url" value="jdbc:hsqldb:data/tutorial"/>
    </properties>
  </persistence-unit>
</persistence>
** spring
 <?xml version="1.0" encoding="UTF-8"?>
2.    <persistence xmlns="http://java.sun.com/xml/ns/persistence"
3.        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
4.        version="1.0">
5.        <!—persistence-unit的name属性提供了创建EntityManagerFacotry时的
6.            关键字，transaction-type则指定了使用的事务管理类型，这里使
7.            用‘RESOURCE_LOCAL’参数表示使用本地事务 ?
8.        <persistence-unit name="mysql" transaction-type="RESOURCE_LOCAL">
9.            <!—JPA的提供类，OpenJPA的设置如下，如果使用其它的JPA实现，这里
10.                的内容需要修改成相应的提供类 ?
11.            <provider>
12.                org.apache.openjpa.persistence.PersistenceProviderImpl
13.            </provider>
14.            
15.            <!—OpenJPA容器中管理的实体类列表 ?
16.            <class>org.vivianj.openjpa.entity.Animal</class>
17.            <!—OpenJPA容器访问数据库的参数 ?
18.            <properties>
19.                <property name="openjpa.ConnectionURL" 20.                    value="jdbc:mysql://localhost/openjpa"/>
21.                <property name="openjpa.ConnectionDriverName" 22.                    value="com.mysql.jdbc.Driver"/>
23.                <property name="openjpa.ConnectionUserName" 24.                    value="openjpa"/>
25.                <property name="openjpa.ConnectionPassword" 26.                    value="openjpa"/>
27.            </properties>
28.        </persistence-unit>
29.    </persistence>

** 与容器结合
JNDI
容器的事务管理

* EntityManagerFactory的获取
** 直接创建
在非JEE容器环境中使用OpenJPA，所以事务类型无法采用JTA形式，我们需要手工进行事务管理

  1.         EntityManagerFactory factory = Persistence.createEntityManagerFactory(  
  2.                 "OpenJpaExample", System.getProperties());  
  3.         EntityManager em = factory.createEntityManager();  



** spring context

JTA在哪里？？？？

  1. <?xml version="1.0" encoding="UTF-8"?>  
  2. <beans xmlns="http://www.springframework.org/schema/beans"  
  3.     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
  4.     xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"]] >   
  5.     <bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"]] >   
  6.         <property name="persistenceUnitName" value="OpenJpaSpringExample"/>  
  7.     </bean]] >   
  8. </beans]] >   



  1.         ApplicationContext context = new ClassPathXmlApplicationContext(  
  2.                 new String[] { "applicationContext.xml" });  
  3.         EntityManagerFactory emf = (EntityManagerFactory)context.getBean("entityManagerFactory");  
  4.         EntityManager em = emf.createEntityManager();  




* 参考目录
http://openjpa.apache.org/builds/1.0.2/apache-openjpa-1.0.2/docs/manual/jpa_overview.html


Table of Contents

1. Introduction

    1. Intended Audience
    2. Lightweight Persistence 

2. Why JPA?
3. Java Persistence API Architecture

    1. JPA Exceptions 

4. Entity

    1. Restrictions on Persistent Classes

        1.1. Default or No-Arg Constructor
        1.2. Final
        1.3. Identity Fields
        1.4. Version Field
        1.5. Inheritance
        1.6. Persistent Fields
        1.7. Conclusions 

    2. Entity Identity

        2.1. Identity Class

            2.1.1. Identity Hierarchies 

    3. Lifecycle Callbacks

        3.1. Callback Methods
        3.2. Using Callback Methods
        3.3. Using Entity Listeners
        3.4. Entity Listeners Hierarchy 

    4. Conclusions 

5. Metadata

    1. Class Metadata

        1.1. Entity
        1.2. Id Class
        1.3. Mapped Superclass
        1.4. Embeddable
        1.5. EntityListeners
        1.6. Example 

    2. Field and Property Metadata

        2.1. Transient
        2.2. Id
        2.3. Generated Value
        2.4. Embedded Id
        2.5. Version
        2.6. Basic

            2.6.1. Fetch Type 

        2.7. Embedded
        2.8. Many To One

            2.8.1. Cascade Type 

        2.9. One To Many

            2.9.1. Bidirectional Relations 

        2.10. One To One
        2.11. Many To Many
        2.12. Order By
        2.13. Map Key
        2.14. Persistent Field Defaults 

    3. XML Schema
    4. Conclusion 

6. Persistence

    1. persistence.xml
    2. Non-EE Use 

7. EntityManagerFactory

    1. Obtaining an EntityManagerFactory
    2. Obtaining EntityManagers
    3. Persistence Context

        3.1. Transaction Persistence Context
        3.2. Extended Persistence Context 

    4. Closing the EntityManagerFactory 

8. EntityManager

    1. Transaction Association
    2. Entity Lifecycle Management
    3. Lifecycle Examples
    4. Entity Identity Management
    5. Cache Management
    6. Query Factory
    7. Closing 

9. Transaction

    1. Transaction Types
    2. The EntityTransaction Interface 

10. JPA Query

    1. JPQL API

        1.1. Query Basics
        1.2. Relation Traversal
        1.3. Fetch Joins
        1.4. JPQL Functions
        1.5. Polymorphic Queries
        1.6. Query Parameters
        1.7. Query Hints

            1.7.1. Locking Hints
            1.7.2. Result Set Size Hint
            1.7.3. Isolation Level Hint
            1.7.4. Other Fetchplan Hints
            1.7.5. Oracle Query Hints
            1.7.6. Named Query Hints 

        1.8. Ordering
        1.9. Aggregates
        1.10. Named Queries
        1.11. Delete By Query
        1.12. Update By Query 

    2. JPQL Language Reference

        2.1. JPQL Statement Types

            2.1.1. JPQL Select Statement
            2.1.2. JPQL Update and Delete Statements 

        2.2. JPQL Abstract Schema Types and Query Domains

            2.2.1. JPQL Entity Naming
            2.2.2. JPQL Schema Example 

        2.3. JPQL FROM Clause and Navigational Declarations

            2.3.1. JPQL FROM Identifiers
            2.3.2. JPQL Identification Variables
            2.3.3. JPQL Range Declarations
            2.3.4. JPQL Path Expressions
            2.3.5. JPQL Joins

                2.3.5.1. JPQL Inner Joins (Relationship Joins)
                2.3.5.2. JPQL Outer Joins
                2.3.5.3. JPQL Fetch Joins 

            2.3.6. JPQL Collection Member Declarations
            2.3.7. JPQL Polymorphism 

        2.4. JPQL WHERE Clause
        2.5. JPQL Conditional Expressions

            2.5.1. JPQL Literals
            2.5.2. JPQL Identification Variables
            2.5.3. JPQL Path Expressions
            2.5.4. JPQL Input Parameters

                2.5.4.1. JPQL Positional Parameters
                2.5.4.2. JPQL Named Parameters 

            2.5.5. JPQL Conditional Expression Composition
            2.5.6. JPQL Operators and Operator Precedence
            2.5.7. JPQL Between Expressions
            2.5.8. JPQL In Expressions
            2.5.9. JPQL Like Expressions
            2.5.10. JPQL Null Comparison Expressions
            2.5.11. JPQL Empty Collection Comparison Expressions
            2.5.12. JPQL Collection Member Expressions
            2.5.13. JPQL Exists Expressions
            2.5.14. JPQL All or Any Expressions
            2.5.15. JPQL Subqueries
            2.5.16. JPQL Functional Expressions

                2.5.16.1. JPQL String Functions
                2.5.16.2. JPQL Arithmetic Functions
                2.5.16.3. JPQL Datetime Functions 

        2.6. JPQL GROUP BY, HAVING
        2.7. JPQL SELECT Clause

            2.7.1. JPQL Result Type of the SELECT Clause
            2.7.2. JPQL Constructor Expressions
            2.7.3. JPQL Null Values in the Query Result
            2.7.4. JPQL Aggregate Functions

                2.7.4.1. JPQL Aggregate Examples 

        2.8. JPQL ORDER BY Clause
        2.9. JPQL Bulk Update and Delete
        2.10. JPQL Null Values
        2.11. JPQL Equality and Comparison Semantics
        2.12. JPQL BNF 

11. SQL Queries

    1. Creating SQL Queries
    2. Retrieving Persistent Objects with SQL 

12. Mapping Metadata

    1. Table
    2. Unique Constraints
    3. Column
    4. Identity Mapping
    5. Generators

        5.1. Sequence Generator
        5.2. TableGenerator
        5.3. Example 

    6. Inheritance

        6.1. Single Table

            6.1.1. Advantages
            6.1.2. Disadvantages 

        6.2. Joined

            6.2.1. Advantages
            6.2.2. Disadvantages 

        6.3. Table Per Class

            6.3.1. Advantages
            6.3.2. Disadvantages 

        6.4. Putting it All Together 

    7. Discriminator
    8. Field Mapping

        8.1. Basic Mapping

            8.1.1. LOBs
            8.1.2. Enumerated
            8.1.3. Temporal Types
            8.1.4. The Updated Mappings 

        8.2. Secondary Tables
        8.3. Embedded Mapping
        8.4. Direct Relations
        8.5. Join Table
        8.6. Bidirectional Mapping
        8.7. Map Mapping 

    9. The Complete Mappings 

13. Conclusion


http://openjpa.apache.org/builds/1.0.2/apache-openjpa-1.0.2/docs/manual/jpa_overview_em.html
Chapter 8.  EntityManager

Table of Contents

1. Transaction Association
2. Entity Lifecycle Management
3. Lifecycle Examples
4. Entity Identity Management
5. Cache Management
6. Query Factory
7. Closing 


