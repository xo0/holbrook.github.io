* JNI入门介绍
　学习了一下JNI，发表文章的时候不知道该选什么好了，不知道JNI应该属于那个范畴^_^。
　　
　　1．简介
　　
　　JNI是Java Native Interface的缩写，它的设计目的是：
　　
　　The standard Java class library may not support the platform-dependent features needed by your application.
　　
　　You may already have a library or application written in another programming language and you wish to make it accessible to Java applications
　　
　　You may want to implement a small portion of time-critical code in a lower-level programming language, such as assembly, and then have your Java application call these functions
　　
　　2．JNI的书写步骤
　　
　　编写带有native声明的方法的java类
　　
　　使用javac命令编译所编写的java类
　　
　　使用javah ?jni java类名生成扩展名为h的头文件
　　
　　使用C/C++实现本地方法
　　
　　将C/C++编写的文件生成动态连接库
　　
　　ok
　　
　　1) 编写java程序：
　　
　　这里以HelloWorld为例。
　　
　　代码1：
　　
　　class HelloWorld {
　　public native void displayHelloWorld();
　　
　　static {
　　System.loadLibrary("hello");
　　}
　　
　　public static void main(String[] args) {
　　new HelloWorld().displayHelloWorld();
　　}
　　}
　　
　　声明native方法：如果你想将一个方法做为一个本地方法的话，那么你就必须声明改方法为native的，并且不能实现。其中方法的参数和返回值在后面讲述。
　　
　　Load动态库：System.loadLibrary("hello");加载动态库（我们可以这样理解：我们的方法displayHelloWorld()没有实现，但是我们在下面就直接使用了，所以必须在使用之前对它进行初始化）这里一般是以static块进行加载的。同时需要注意的是System.loadLibrary();的参数“hello”是动态库的名字。
　　
　　main()方法
　　
　　2) 编译没有什么好说的了
　　
　　javac HelloWorld.java
　　
　　3) 生成扩展名为h的头文件
　　
　　javah ?jni HelloWorld
　　
　　头文件的内容：
　　/* DO NOT EDIT THIS FILE - it is machine generated */
　　#include <jni.h>
　　/* Header for class HelloWorld */
　　
　　#ifndef _Included_HelloWorld
　　#define _Included_HelloWorld
　　#ifdef __cplusplus
　　extern "C" {
　　#endif
　　/*
　　* Class:　　 HelloWorld
　　* Method:　　displayHelloWorld
　　* Signature: ()V
　　*/
　　JNIEXPORT void JNICALL Java_HelloWorld_displayHelloWorld
　　(JNIEnv *, jobject);
　　
　　#ifdef __cplusplus
　　}
　　#endif
　　#endif
　　
　　（这里我们可以这样理解：这个h文件相当于我们在java里面的接口，这里声明了一个Java_HelloWorld_displayHelloWorld (JNIEnv *, jobject);方法，然后在我们的本地方法里面实现这个方法，也就是说我们在编写C/C++程序的时候所使用的方法名必须和这里的一致）。
　　
　　4) 编写本地方法
　　
　　实现和由javah命令生成的头文件里面声明的方法名相同的方法。
　　
　　代码2：
　　
　　1 #include <jni.h>
　　2 #include "HelloWorld.h"
　　3 #include <stdio.h>
　　4 JNIEXPORT void JNICALL Java_HelloWorld_displayHelloWorld(JNIEnv *env, jobject obj)
　　{
　　printf("Hello world!\n");
　　return;
　　}
　　
　　注意代码2中的第1行，需要将jni.h（该文件可以在%JAVA_HOME%/include文件夹下面找到）文件引入，因为在程序中的JNIEnv、jobject等类型都是在该头文件中定义的；另外在第2行需要将HelloWorld.h头文件引入（我是这么理解的：相当于我们在编写java程序的时候，实现一个接口的话需要声明才可以，这里就是将HelloWorld.h头文件里面声明的方法加以实现。当然不一定是这样）。然后保存为HelloWorldImpl.c就ok了。
　　
　　5) 生成动态库
　　
　　这里以在Windows中为例，需要生成dll文件。在保存HelloWorldImpl.c文件夹下面，使用VC的编译器cl成。
　　
　　cl -I%java_home%\include -I%java_home%\include\win32 -LD HelloWorldImp.c -Fehello.dll
　　
　　注意：生成的dll文件名在选项-Fe后面配置，这里是hello，因为在HelloWorld.java文件中我们loadLibary的时候使用的名字是hello。当然这里修改之后那里也需要修改。另外需要将-I%java_home%\include -I%java_home%\include\win32参数加上，因为在第四步里面编写本地方法的时候引入了jni.h文件。
　　
　　6) 运行程序
　　
　　java HelloWorld就ok。^_^

* 将JNI的dll添加到jar包并发布和执行的方法
经常会有这种情况，需要用JNI来实现某些java不支持的操作（比如windows上操作智能卡），同时又对此操作实现一定的java层面的封装，并需要发布给第三方开发者进行使用。一般的处理方式是，提供一个jar包，同时提供一个dll，并要求第三方开发者将此dll拷贝到C:/windows/system32目录下。这种操作方式不够傻瓜，最爽的方式当然是和纯java一样，提供一个jar包就全部解决。
 
首先，Java加载JNI的动态库，有两种方式：
    System.load(String filename);  //指定加载的dll全路径文件名
    System.LoadLibrary(String dllname);  //指定加载的dll名（无path，无后缀）
 
很明显Load是绝对路径，LoadLibrary的方式和windows加载dll的方式一样，按当前目录和path系统目录的顺序查找文件。
但这两种显然都不适合动态的部署。因为每个系统的环境变量可能并不完全相同。所以好的方式，是在运行态的时候确定。
思路是：dll在jar包中，也就是属于类的资源，所以可以在类初始化的时候，从Resource里面获得。然后拷贝为一个临时文件，由System.load指定全路径进行加载。并利用临时文件的属性在退出的时候删除。
如此实现：
public class Test{
 static {
  try {
  InputStream in = Switch.class.getClass().getResource("/NTV.dll").openStream();
  File dll = File.createTempFile("NTV", ".dll");
  FileOutputStream out = new FileOutputStream(dll);
  int i;
  byte [] buf = new byte[1024];
  while((i=in.read(buf))!=-1) {
   out.write(buf,0,i);
  }
  
  in.close();
  out.close();
  dll.deleteOnExit();
  System.load(dll.toString());// 
  }catch (Exception e) {
   System.err.println("load jni error!");
  }
 }
 public native int func(String str);
 public static void main(String[] args) {
    func("hello");
 }
}
 
在eclipse的项目目录上建立dll目录，将NTV.dll拷贝进来，并将dll目录添加到ClassPath。即能进行调试。在调试OK后，建立ant工程
<project name="native_method" default="jarop" basedir=".">
 <target name="build_javah">
 <delete dir="bin" />
  <mkdir dir="bin"/>
  <javac scrdir="src" dstdir="bin"/>
  <javah destdir="jni" classpath="bin" force="yes">
   <class name="Test"/>
  </javah>
 </target>
 <target name="jarop">
  <jar destfile="Test.jar" >
   <fileset dir="bin" includes="**/*.class" />
   <fileset dir="dll" includes="NTV.dll" />
   <manifest>
    <attribute name="Class-Path" value="."/>
    <attribute name="Main-Class" value="Test"/>
   </manifest>
  </jar>
 </target>
</project>
 
此时dll被添加到jar包的根上，尝试着在任何位置 java -jar */Test.jar 都可以正确的执行。

* java jni dll三的結合
剛到新公司，就接到一個棘手的任務。想了很多辦法，最後想使用JavaCOM橋來解決。JACOB是一個較成熟的開源項目，可以很方便的調用COM組件。搞過JNI的都知道，本地庫要放到系統path中，這樣，Java進程在運行中才能找到本地庫並動態加載。我們可以通過環境變量System.getProperty("java.library.path")來查看當前JVM搜索本地庫的路徑。
這時，就會遇到一個問題，部署應用的時候要記住將本地庫拷貝到環境變量path指定的路徑中。一般在windows平台上直接copy到C:WINDOWSSystem32目錄下了事。但要換一台機器部署怎麼辦？除了要把Java程序拿過去，還要記的把本地庫也copy到正確的目錄，真麻煩。於是想看看有什麼好辦法來解決這個問題。
首先，最容易想到的是，把本地庫和class文件放在一起，利用Class.getResource(str)找到路徑，然後加到環境java.library.path中：
[code:1]URL url =Foo.class.getResource("Foo.class");
String path = (new File(url.getPath())).getParent();
System.setProperty("java.library.path",path);[/code:1]
看上去很好，但卻不能工作。查了一下ClassLoader的源代碼，原來它把搜索路徑定義為靜態變量並只初始化一次，後面再設置java.library.path就沒有用了。ClassLoader代碼片斷：
[code:1]// The paths searched for libraries
static private String usr_paths[];
static private String sys_paths[];
...
if (sys_paths == null) {
usr_paths = initializePath("java.library.path");
sys_paths = initializePath("sun.boot.library.path");
}[/code:1]
正在一籌莫展是，翻看JACOB的源代碼，忽然有了驚喜的發現。
[code:1]try
{
//Finds a stream to the dll. Change path/class if necessary
InputStream inputStream =getClass().getResource("/jacob.dll").openStream();
//Change name if necessary
File temporaryDll = File.createTempFile("jacob", ".dll");
FileOutputStream outputStream = newFileOutputStream(temporaryDll);
byte[] array = new byte[8192];
for (int i = inputStream.read(array); i != -1; i =inputStream.read(array)) {
outputStream.write(array, 0, i);
}
outputStream.close();
temporaryDll.deleteOnExit();
System.load(temporaryDll.getPath());
return true;
}
catch(Throwable e)
{
e.printStackTrace();
return false;
}[/code:1]
高，真是好辦法。和我一樣，把dll放在classpath中，用Class.getResource(str).openStream()讀取這個dll，然後寫到temp目錄中，最後用System.load(path)來動態加載。多說一句，為什麼得到了jacob.dll的URL不直接去加載呢？想想看，如果把dll和class一起打成Jar包，ClassLoader還是不能加載本地庫，因為System.load(path)需要的是dll的完整路徑，但並不支持jar協議。還不明白，看看下面的代碼：
[code:1]URL url =Foo.class.getResource("/java/lang/String.class");
System.out.println(url.toExternalForm());
System.out.println(url.getFile());[/code:1]
在我的機器上的運行結果是：
[code:1]jar:file:/D:/jdk1.5.0_06/jre/lib/rt.jar!/java/lang/String.class
file:/D:/jdk1.5.0_06/jre/lib/rt.jar!/java/lang/String.class[/code:1]
ClassLoader中用newFile(name)，當然會找不到文件。同時，看看我的第一種方法，就算能設置成功環境java.library.path，如果dll是在jar包中，還是加載不了。
到現在，你是不是覺得問題已經解決了？還沒呢！jacob的很多源文件中已經寫了下面的代碼：
[code:1]static {
System.loadLibrary("jacob");
}[/code:1]
除非我去掉這一句重新編譯jacob的源代碼，否則系統還是會報錯。不過，既然有了上面的想法，稍微變通一下，就可以巧妙的解決。首先找到環境java.library.path，然後把dll拷貝到其中一個路徑中就行了。
[code:1]static {
try {
String libpath = System.getProperty("java.library.path");
if ( libpath==null || libpath.length() == 0 ){
throw new RuntimeException("java.library.path is null");
}
String path = null;
StringTokenizer st = new StringTokenizer(libpath,System.getProperty("path.separator"));
if ( st.hasMoreElements() ) {
path = st.nextToken();
} else {
throw new RuntimeException("can not split librarypath:" + libpath);
}
InputStream inputStream =Foo.class.getResource("jacob.dll").openStream();
final File dllFile = new File(new File(path), "jacob.dll");
if (!dllFile.exists()) {
FileOutputStream outputStream = newFileOutputStream(dllFile);
byte[] array = new byte[8192];
for (int i = inputStream.read(array); i != -1; i =inputStream.read(array)) {
outputStream.write(array, 0, i);
}
outputStream.close();
}
//dllFile.deleteOnExit();
Runtime.getRuntime().addShutdownHook(newThread(){
public void run() {
if ( dllFile.exists() ) {
boolean delete = dllFile.delete();
System.out.println("delete : " + delete);
}
}
});
} catch (Throwable e) {
throw new RuntimeException("load jacob.dll error!", e);
}
}[/code:1]
唯一的美中不足，在系統關閉的時候刪除dll總是不能成功，試了兩種辦法都不行。想想也對，dll正被程序使用，當然不能刪除。翻了一下API，Java好像沒用提供unload本地庫的功能，只好做罷。
解決了這麼個小問題，羅羅嗦嗦一大篇，罪過罪過。後來這個項目又沒有使用jacob，真對不起各位觀眾。
