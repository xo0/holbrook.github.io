* python的命名空间
python 的每个.py文件都是一个命名空间。 在命名空间中可以定义局部的函数和变量（也包括类），从而避免命名冲突的问题。如果要使用命名空间中的函数或对象，需要导入（import）。

导入的行为类似脚本语言的"include"，如果某个.py文件中有语句，则导入时这些语句也会执行。

python 的文件夹可以定义为模块。只需要在文件夹中增加一个__init__.py文件。此时如果导入文件夹对应的路径，则相当于导入 __init__.py文件。
通常，__init__.py会当中模块的入口，比如一些需要对外公开（public)的对象，会在__init__.py中导入，这样外部只需要导入模块，就可以使用模块内部的相关对象和函数。


如果__init__.py中包含脚本，模块还可以独立运行。

* Python学习笔记-模块介绍（二）-模块导入和执行 
http://www.mzone.cc/article/436.html


    # -*- encoding:utf-8 -*-
    '''module_2.py模块的内容'''
     
    print(__name__)
     
    def sum(a,b):
    return a+b
     
    if __name__ == "__main__":
    import sys
    print(sys.argv[0])
    a = int(sys.argv[1])
    b = int(sys.argv[2])
    print(sum(a,b))

      上面的这段代码基本上就包含了本篇文章要说的内容了：
** 一、__name__变量说明

      __name__是一个全局变量，在模块内部是用来标识模块的名称的。上面的例子中有一个打印__name__变量的语句，比如我们在python的交互模式下执行导入可以看到如下结果：

    >>>import module_2
    module_2

      可以看到，通过使用import的方式导入模块后，打印的__name__值就是我们刚才说的模块的名称。另外，如果是通过python解释器直接执行模块，则__name__会被设置为__main__这个字符串值，如下：

    D:\temp>python module_2.py 2 3
    __main__
    module_2.py
    5

      我们通过windows命令行直接执行module_2这个模块文件，可以看到的结果输入如上，打印的__name__值为__main__。通过这个特性我们可以将一个模块文件既当做普通的lib库供其他模块使用，又可以当做一个顶层执行文件进行执行，只是使用方式不一样而已。

      1、当成lib库使用时只需要在其他模块中使用import导入该模块即可；

      2、当成执行模块时通过python解释器直接运行该模块，然后在模块文件中最后写上上面例子中的if判断语句段即可。

      通过__name__变量来区分是执行模块还是导入模块其实就非常类似java中的main函数了，不同的是java中是约定的方法名称，而python中约定是变量名称，异曲同工之效。
** 二、参数传递

      参数传递主要是指作为执行模块时需要传递的参数，通过python解释器执行某一个执行模块传递参数的使用如下：

    D:\temp>python 模块名称(包含.py后缀) 参数1 参数2 参数3 ....

      对于上面给定的例子执行就是：

    D:\temp>python module_2.py 2 3
    __main__
    module_2.py
    5

      python解释器会将所有传递的参数存储在sys.argv这个列表中，所有的参数都被当成字符串进行处理。同时，即使不传递任何参数，也会有一个默认的参数sys.argv[0]标识当前模块的名称。所以我们自己使用的参数都是从sys.argv[1]开始的，下标1表示第一个传递的参数，依次类推。   
*     Python学习笔记-模块介绍（三）-模块包和搜索路径 
http://www.mzone.cc/article/438.html
     一个python文件就是一个模块，使用独立的命名空间，但实际使用过程中单单用模块来定义python功能显然还不够。因为一个大型的系统几千上万个模块是很正常的事情，如果都聚集在一起显然不好管理并且有命名冲突的可能，因此python中也出现了一个包的概念。
一、python中的包介绍

      包是通过使用“点模块名称”创建Python模块命名空间的一种方法。列如，模块名称 A.B 表示一个在名为 A的包下的名为B的子模块。就像使用模块让不同模块的作者无需担心彼此全局变量名称（冲突）一样，点模块名称让多模块包的作者无需担心彼此的模块名称（冲突）。模块包在文件系统中的表示就是一系列目录的集合，通过目录的层级结构形成模块包的层级结构，最终的模块文件就位于最后的目录中。比如定义一个简单的模块在包pkg下，那么执行如下步骤：

1、在D:\temp目录下建立一个目录，名称是pkg

2、在pkg下建立一个__init__.py的模块，内容为空即可

3、在pkg目录下建立一个python模块module_3.py，内容如下：

    # -*- encoding:utf-8 -*-
    '''pkg.module_3.py模块的内容'''
     
    print("Hello World")
     
    def func1():
    print("This is funciton one")

      注意第2步，必须要在每一个包目录下建立一个__init__.py的模块，这个是python的规定，用来告诉python解释器将该目录当成一个内容包，即该目录是一个包，里面包含了python模块的。这个是必须的，如果不指定，则我们在python的交互模式下导入module_3.py这个模块时会报如下错误：

    >>> import pkg.module_3
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ImportError: No module named pkg.module_3

      因此包目录下的__init__.py模块是必须的，但内容是可选的，可以为空内容，也可以写一些代码或作其他用途。PVM在导入某个包下的模块时会先导入这个包下的__init__.py模块，比如我们将__init__.py模块的内容指定如下：

    print("This is __init__ module")

      然后在交互模式下重新导入这个包，则效果如下：

    >>> import pkg.module_3
    This is __init__ module
    Hello World
    >>>

      可见，PVM首先加载的是__init__.py模块，然后才是找该目录下的其他模块并进行加载。
二、python中的模块搜索路径

      在一个模块被导入时，PVM会在后台从一系列路径中搜索该模块，其搜索过程如下：

1、在当前目录下搜索该模块；

2、在环境变量PYTHONPATH中指定的路径列表中依次搜索；

3、在python安装路径中搜索

      事实上，PVM通过变量sys.path中包含的路径来搜索，这个变量里面包含的路径列表就是上面提到的这些路径信息，我们可以打印看下sys.pth都包含些哪些路径：

    >>> import sys
    >>> print(sys.path)
    ['', 'C:\\Windows\\system32\\python27.zip', 'D:\\tools\\Python27\\DLLs', 'D:\\to
    ols\\Python27\\lib', 'D:\\tools\\Python27\\lib\\plat-win', 'D:\\tools\\Python27\
    \lib\\lib-tk', 'D:\\tools\\Python27', 'D:\\tools\\Python27\\lib\\site-packages',
    'D:\\tools\\Python27\\lib\\site-packages\\wx-2.8-msw-unicode']

      不同的机器上显示的路径信息可能不一样，但至少都包含上面提到的3点。知道了这个路径搜索规律后，我们就可以很方便的将某些目录动态的增加到搜索路径中去，比如在E盘下建立一个python模块module_4.py，内容如下：

    print("Hello world")
    print 2 ** 2

      然后在交互模式下执行导入：

    >>> import module_4
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ImportError: No module named module_4

      报错是预料中的，因为E盘并不在python模块的搜索路径中，然后我们动态的增加这个路径到搜索模块中，再执行导入：

    >>> sys.path.append("E:\\")
    >>> print(sys.path)
    ['', 'C:\\Windows\\system32\\python27.zip', 'D:\\tools\\Python27\\DLLs', 'D:\\to
    ols\\Python27\\lib', 'D:\\tools\\Python27\\lib\\plat-win', 'D:\\tools\\Python27\
    \lib\\lib-tk', 'D:\\tools\\Python27', 'D:\\tools\\Python27\\lib\\site-packages',
    'D:\\tools\\Python27\\lib\\site-packages\\wx-2.8-msw-unicode', 'E:\\']
    >>> import module_4
    Hello world
    4

      首先是在sys.path中增加了E盘根目录作为搜索路径，随后的打印中可以看到确实已经被添加到sys.path中去了，然后再执行导入就会正常导入模块并执行模块中的语句了。当然，我们通过交互模式新增加的搜索路径也仅仅是在当前交互模式下有效，一旦退出了那么就就失效了。因此，我们可以根据搜索路径规则的第2步中说的来设置PYTHONPATH环境变量就可以满足不同使用情况下都可以找到模块了。
P&P python, 包, 模块
上一篇：Python学习笔记-模块介绍（二）-模块导入和执行
下一篇：Maven2编译时“是 Sun 的专用 API，可能会在未来版本中删除”错误解决
我猜你也在找这些

    Python学习笔记-模块介绍（二）-模块导入和执行
    Python学习笔记-模块介绍（一）-模块概念和基本使用
    Python学习笔记-初涉python
    Python学习笔记-了解Python
    初涉python，感叹python原来也是这么的强大！

顺便看看推荐文章

    mupload大文件上传组件配置详解
    java中的Timer类和线程问题
    Android2.2中文文档-Installing the SDK（SDK安装）
    SAE——新浪云计算平台初探
    您浏览的页面或提交的数据包含敏感关键词信息,该关键词已经被过滤
    WampServer介绍



* World Hello - python egg学习笔记
http://www.worldhello.net/2010/12/08/2178.html
经常接触Python的同学可能会注意到，当需要安装第三方python包时，可能会用到easy_install命令。easy_install是由PEAK(Python Enterprise Application Kit)开发的setuptools包里带的一个命令，它用来安装egg包。egg包是目前最流行的python应用打包部署方式。如何制作和安装egg包？下面我就简单的分析了一下。
1.1   安装setuptools
首先要安装setuptools工具。Debian/Ubuntu下可以直接使用apt安装：:

$ sudo apt-get install python-setuptools

手工安装的话，有两种方式：

    通过引导程序 ez_setup.py 来安装。这个引导程序会联网下载最新版本setuptools来安装，同时也可以更新本地的setuptools。

    $ wget http://peak.telecommunity.com/dist/ez_setup.py
    $ sudo python ez_setup.py

    更新setuptools：:

    $ sudo python ez_setup.py -U setuptools

    或者下载setuptools的egg包来安装。可以在 这里 查看最新版本下载。下载完毕以后通过sh安装。

    $ wget http://pypi.python.org/packages/2.6/s/setuptools/setuptools-0.6c11-py2.6.egg
    $ sudo sh setuptools-0.6c11-py2.6.egg

现在就可以使用easy_install命令来安装其他的egg包了。
1.2   制作自己的egg包
总是安装别人的egg包，是不是也想制作自己的egg包呢？好，接下来我们就自己制作一个简单的egg包。 首先建立工程目录egg-demo,初始化一个setup.py文件：

$ mkdir egg-demo
$ cd egg-demo
$ touch setup.py
$ ls
setup.py

下面主要就是填充setup.py。setup.py其实是python工具包distutils的配置文件，setuptools就是基于distutils来做的。 在setup.py中通过setup函数来配置打包信息。首先要引入setuptools的函数setup。setuptools的setup其实就是distutils的setup函数，填写setup.py为以下内容：

$ cat setup.py
#!/usr/bin/env python
#-*- coding:utf-8 -*-

from setuptools import setup

setup()

写到这里，一个空的egg配置文件就写好了。我们可以使用下面命令生成egg包：

$ python setup.py bdist_egg

下面看看究竟生成了什么：

$ ls -F
build/ dist/ setup.py UNKNOWN.egg-info/

可以看到多了三个文件夹。而在dist文件夹下，有一个egg文件：UNKNOWN-0.0.0-py2.6.egg。 产蛋成功！先看看这个egg文件是什么格式的：

$ file dist/UNKNOWN-0.0.0-py2.6.egg
dist/UNKNOWN-0.0.0-py2.6.egg: Zip archive data, at least v2.0 to extract

噢，原来就是一个zip压缩包呀！好，再来看看内部构造：

$ unzip -l dist/UNKNOWN-0.0.0-py2.6.egg
Archive:  dist/KNOWN-0.0.0-py2.6.egg
  Length      Date    Time    Name
---------  ---------- -----   ----
      120  2010-12-06 17:04   EGG-INFO/SOURCES.txt
        1  2010-12-06 17:04   EGG-INFO/top_level.txt
        1  2010-12-06 17:04   EGG-INFO/zip-safe
        1  2010-12-06 17:04   EGG-INFO/dependency_links.txt
      227  2010-12-06 17:04   EGG-INFO/PKG-INFO
---------                     -------
      350                     5 files

只有一个EGG-INFO文件夹，内含五个egg信息文件，没了。 这个egg名称未知，版本0.0.0。这是因为我们在setup里什么也没有设置。 显然，这个egg什么也不能做。 下面给它加点料。 在setup.py中，setup函数接收一系列属性作为配置参数。

    name name是egg包的名称，也是寻找要打包的文件夹的名称，默认是UNKNOWN。
    version 版本号，默认0.0.0
    packages 这里要用到setuptools的另一个函数find_packages，顾名思义，find_packages用来将指定目录下的文件打包。
    zip_safe 默认是False，这样在每次生成egg包时都会检查项目文件的内容，确保无误。

还有一些描述性的属性，如description，long_description，author，author_email，license，keywords，platform，url等。 填充setup.py文件如下：:

$ cat setup.py
#!/usr/bin/env python
#-*- coding:utf-8 -*-

from setuptools import setup, find_packages

setup(
        name = "demo",
        version="0.1.0",
        packages = find_packages(),
        zip_safe = False,

        description = "egg test demo.",
        long_description = "egg test demo, haha.",
        author = "amoblin",
        author_email = "amoblin@ossxp.com",

        license = "GPL",
        keywords = ("test", "egg"),
        platforms = "Independant",
        url = "",
        )

在egg-demo目录下建立和上述name名称相同的目录demo，demo目录下写__init__.py文件：

$ mkdir demo
$ cat demo/__init__.py
#!/usr/bin/env python
#-*- coding:utf-8 -*-

def test():
    print "Hello, I'm amoblin."

if __name__ == '__main__':
    test()

再次生成egg包以后查看egg包信息：

$ python setup.py bdist_egg
$ unzip -l dist/demo-0.1.0-py2.6.egg
Archive:  dist/demo-0.1.0-py2.6.egg
  Length      Date    Time    Name
---------  ---------- -----   ----
      121  2010-12-06 17:30   demo/__init__.py
      344  2010-12-06 17:46   demo/__init__.pyc
      137  2010-12-06 17:46   EGG-INFO/SOURCES.txt
        5  2010-12-06 17:46   EGG-INFO/top_level.txt
        1  2010-12-06 17:46   EGG-INFO/zip-safe
        1  2010-12-06 17:46   EGG-INFO/dependency_links.txt
      227  2010-12-06 17:46   EGG-INFO/PKG-INFO
---------                     -------
      836                     7 files

可以看到，多了一个文件夹demo，里面有我们写的__init__.py。 奉行敏捷原则，先安装了体验一下再说：

$ sudo python setup.py install
running install
install_dir /usr/local/lib/python2.6/dist-packages/
...
creating /usr/local/lib/python2.6/dist-packages/demo-0.1.0-py2.6.egg
Extracting demo-0.1.0-py2.6.egg to /usr/local/lib/python2.6/dist-packages
demo 0.1.0 is already the active version in easy-install.pth

Installed /usr/local/lib/python2.6/dist-packages/demo-0.1.0-py2.6.egg
Processing dependencies for demo==0.1.0
Finished processing dependencies for demo==0.1.0

OK!安装完毕！接下来我们就可以直接通过import来使用啦！

$ python -c "from demo import test;test()"
Hello, I'm amoblin.

成功输出！这说明安装正确。我们的一个egg包诞生了。 一般情况下，我们的源程序都放在src目录下，所以接下来将demo文件夹移动到src里。但这样也要修改setup.py文件，修改find_packages函数中参数为'src'，同时增加package_dir参数：

packages=find_packages('src'),
package_dir = {'':'src'}

这样告诉setuptools在src目录下找包，而不是原来默认的工程根目录。
1.3   egg文件卸载
以python2.6版本为例，egg文件一般安装在/usr/local/lib/python2.6/dist-packages/目录下，该目录下还有一个easy-install.pth文件，用于存放安装的egg信息。:

$ cd /usr/local/lib/python2.6/dist-packages
$ cat easy-install.pth|grep demo
./demo-0.1.0-py2.6.egg
$ ls -F|grep demo
demo-0.1.0-py2.6.egg/

卸载egg文件很简单，首先将包含此egg的行从easy-install.pth中删除，然后删除egg文件夹即可。 


请问打包后源文件能保留么?
还有就是依赖关系如何处理?


* 制作python模块安装包(转)
http://hi.baidu.com/gylxue/blog/item/1d62482aa082123cd52af1ed.html

python的第三方模块越来越丰富，涉及的领域也非常广，如科学计算、图片处理、web应用、GUI开发等。当然也可以将自己写的模块进行打包或发布。一简单的方法是将你的类包直接copy到python的lib目录，但此方式不便于管理与维护，存在多个python版本时会非常混乱。现介绍如何编写setup.py来对一个简单的python模块进行打包。

一、编写模块
进入项目目录
#cd /home/pysetup
#vi foo.py
#! /usr/bin/env python

#coding=utf-8

class MyLib():

    def __init__(self):

        self.str = "hello!"

   

    def print_log(self):

        print self.str

       

    def printBlog(self):

        print self.str.swapcase();
二、编写setup.py
#vi setup.py
#! /usr/bin/env python

#coding=utf-8

from distutils.core import setup

setup(

    name='MyLib',

    version='1.0',

    description='My Lib disribution Utility',

    author='Edison',

    author_email='eddy.wd5@gmail.com',

    url='http://hi.baidu.com/gylxue',

    py_modules=['mylib'],

   

)

更多参数说明见表：



三、setup.py参数说明


#python setup.py build     # 编译
#python setup.py install     #安装
#python setup.py sdist       #生成压缩包(zip/tar.gz)
#python setup.py bdist_wininst   #生成NT平台安装包(.exe)
#python setup.py bdist_rpm #生成rpm包


或者直接"bdist 包格式"，格式如下：


#python setup.py bdist --help-formats
   --formats=rpm       RPM distribution
   --formats=gztar     gzip'ed tar file
   --formats=bztar     bzip2'ed tar file
   --formats=ztar     compressed tar file
   --formats=tar       tar file
   --formats=wininst   Windows executable installer
   --formats=zip       ZIP file


四、打包
#python setup.py sdist


running sdist

warning: sdist: manifest template 'MANIFEST.in' does not exist (using default file list)
warning: sdist: standard file not found: should have one of README, README.txt

writing manifest file 'MANIFEST'
creating MyLib -1.0
making hard links in MyLib -1.0...
hard linking foo.py -> MyLib -1.0
hard linking setup.py -> MyLib -1.0
creating dist
tar -cf dist/ MyLib -1.0.tar MyLib -1.0
gzip -f9 dist/MyLib -1.0.tar
removing ‘MyLib -1.0' (and everything under it)


提示两条warning可以忽略，不影响打包，当然一个完善的项目必须有README及MANIFEST.in(项目文件清单)文件。
#ls dist

MyLib -1.0.tar.gz

五、安装
#tar -zxvf MyLib -1.0.tar.gz
#cd MyLib -1.0.tar.gz
#python setup.py install (此命令大家再熟悉不过了)


running install
running build
running build_py
creating build/lib.linux-x86_64-2.6
copying mylib.py -> build/lib.linux-x86_64-2.6
running install_lib
copying build/lib.linux-x86_64-2.6/ mylib.py -> /usr/local/lib/python2.6/dist-packages
byte-compiling /usr/local/lib/python2.6/dist-packages/ mylib.py to mylib.pyc
running install_egg_info
Writing /usr/local/lib/python2.6/dist-packages/ mylib -1.0.egg-info


六、测试

>>> from mylib import MyLib
>>> app= MyLib ()
>>> app.

If your package provider didn't produce a setup.py uninstall method then, more often than not,

you can just manually remove the package from your Python's site-packages directory.

This will be located at /usr/lib/python2.5/site-packages or equivalent for your distro and version of Python.

Within that there will be either a directory or a .egg file corresponding to the package's name.

Simply delete that.There are some instances where packages will install stuff elsewhere.

Django for instance installs django-admin.py to /usr/sbin. Y

一些插件(例如 SpamFilter)可以作为.egg文件进行下载, 可以和easy_install程序一起安装:
easy_install TracSpamFilter

如果easy_install不在你的系统上, 请参考上节中的要求来安装. Windows用户还需要将Python安装包的Scripts目录, 例如C:\Python23\Scripts, 添加到PATH环境变量中. 更多信息, 请参考 easy_install Windows说明.

如果安装完一个egg后, Trac报告权限错误, 而你不想为Web服务器提供一个可写的egg缓存目录, 你只需解压这个egg来绕开这个问题. 使用--always-unzip选项:
easy_install --always-unzip TracSpamFilter-0.2.1dev_r5943-py2.4.egg

你应该用与egg相同的名字作为目录名(包括结尾的.egg), 目录中是解压后的内容.

Trac也会搜索全局安装的插件(自0.10版本后), 参见 TracIni#GlobalConfiguration.
从源代码

easy_install从源代码的快照安装. 只需要Subversion的URL或者源代码的压缩包(tarball/zip):
easy_install http://svn.edgewall.com/repos/trac/sandbox/spam-filter
启用插件

不像只安装在环境目录中的那些插件, 你需要通过trac.ini来启用全局安装的插件. 这是在配置文件的[components]段中完成的, 例如:
[components]tracspamfilter.* = enabled

选项名是插件的Python安装包. 插件的相应文档中应该明确指定, 但通过查看源代码轻易找到(找包含__init__.py的顶级目录).

注意:安装完插件后, 你还需要重启Apache.
卸载

easy_install 或 python setup.py 还没有卸载功能. 然而, 删除全局安装插件egg的方法通常是:
运行

如果你对egg的位置不确定, 这里有一个小技巧来定位egg(或任意包) - 用插件使用的名字空间(跟启用插件一样)替换:
>>> import myplugin>>> print myplugin.__file__/opt/local/python24/lib/site-packages/myplugin-0.4.2-py2.4.egg/myplugin/__init__.pyc


* Python模块安装
http://icereality.blog.china.com/201010/7121825.html

Python模块安装

1. 单文件模块

直接把文件拷贝到$python_dir/lib

2. 多文件模块，带setup.py

python setup.py install

3. egg文件

1) 下载ez_setup.py,运行python ez_setup

2) easy_install *.egg

虽然Python的模块可以拷贝安装，但是一般情况下推荐制作一个安装包，即写一个setup.py文件来安装。

setup.py文件的使用:

% python setup.py build #编译 

% python setup.py install    #安装 

% python setup.py sdist     #制作分发包 

% python setup.py bdist_wininst #制作windows下的分发包 

% python setup.py bdist_rpm 

setup.py文件的编写 

setup.py中主要执行一个 setup函数，该函数中大部分是描述性东西，最主要的是packages参数，列出所有的package，可以用自带的find_packages来动态获取package。所以setup.py文件的编写实际是很简单的。

简单的例子: 

setup.py文件

 from setuptools import setup, find_packages

 setup(

        name = " mytest " ,

        version = " 0.10 " ,

        description = " My test module " ,

        author = " Robin Hood " ,

        url = " http://www.csdn.net " ,

        license = " LGPL " ,

        packages = find_packages(),

        scripts = [ " scripts/test.py " ],

        )

mytest.py

import sys

 def get():

      return sys.path 

scripts/test.py

import os 

 print os.environ.keys()  

setup中的scripts表示将该文件放到 Python的Scripts目录下，可以直接用。 

OK，简单的安装成功，可以运行所列举的命令生成安装包，或者安装该python包。

本机测试成功(win32-python25)！

==============================================================

setuptools它可以自动的安装模块，只需要你提供给它一个模块名字就可以，并且自动帮你解决模块的依赖问题。一般情况下用setuptools给安装的模块会自动放到一个后缀是.egg的目录里。

首先，安装setuptools这个东西，先去下载一个脚本：　http://peak.telecommunity.com/dist/ez_setup.py　下载完后直接执行它就会帮你把setuptools给装好。

之后，安装模块的使用方法就是使用一个叫easy_install的命令，在Windows里，这个命令在python安装目录下的scripts里面，所以需要把scripts加到环境变量的PATH里，这样用起来就更方便，linux下不需要注意这个问题。

安装软件只需要执行：easy_install 模块名

===================================================

pyinstaller 来建立linux下的python独立执行文件

以下内容假定已安装好Python 2.4/2.5 

一、下载并编译pyinstaller（只需做一次，以后可直接做第二步） 

1.下载pyinstaller,现在的版本是1.3 

(1)wget http://pyinstaller.hpcf.upr.edu/source/1.3/pyinstaller_1.3.tar.gz 

2.解包进入源码目录 

(1)tar zxv pyinstaller_1.3.tar.gz 

(2)cd pyinstaller-1.3/source/linux 

3.编译源代码 

(1)python Make.py  生成python的 .pyc文件 

如无错误，则出现如下提示（只有一行）： 

Now run "make" to build the targets: ../../support/loader/run ../../support/loader/run_d 

(2)make 连接生成linux的 .o 文件 

4.生成编译配置文件 

(1)python Configure.py  生成config.dat配置文件 

二、编译独立运行的python可执行文件 

1.生成spec文件 

python pyinstaller-1.3/Makespec.py --onefile --upx linuxlaptop.py 

参数说明： 

--onefile 生成单文件 

--upx          生成压缩的文件（可减小执行文件体积，需先安装upx软件包） 

2.生成最终的可执行文件 

python pyinstaller-1.3/Build.py linuxlaptop.spec 

执行完成后将在当前目录生成可执行的linuxlaptop文件，如有问题欢迎与我交流：linuxlaptop.cn。

========================================================================

用cx_Freeze把python打包成exe可执行文件 

以前从来没有试过把Python打包,昨天试了试,发现打包也是一件挺容易的事情.Python打包有很多种选择.cx_Freeze是一种, py2exe也可以,还有一个pyinstaller.我用的是cx_Freeze,而py2exe因为sf实在太慢连不上.所以没办法,只好先用可以下载的.cx_Freeze的资料比较少,不过不是太痛苦,因为好像cx会比py2exe简便易用,而且好像是跨平台的,不错不错.

    cx_Freeze的用法就一个命令FreezePython.exe,打包也很快捷:

    FreezePython.exe  --install-dir="/your/path/to/install" app.py 

    然后就会把app.py以及其依赖的所有模块,包和库全部归整后放到--install-dir 所指的路径下.

    碰到两个问题,一个是文件编码,一开始总是说找不到gb2312的编码,后面google了一下,发现要这么做:     

在app.py中添加from encodings import gbk 一句,然后就可以了.    

如果用到了gettext,要注意po文件中的

    "Content-Type: text/plain; charset=gbk "

    "Content-Transfer-Encoding: cp936 "     

这两句要这样写,字符集要用gbk,不要用gb2312.

    另一个问题是控制台隐藏:   

默认cx_Freeze打包后都是控制台程序,就算你打包一个wxPython程序,也会有一个黑黑的控制台在后面做背景,要去掉控制台就要这样:

    FreezePython.exe --install-dir="yourinstallpath" --base-binary=Win32GUI.exe app.py 

    加了--bash-binary 后就可以只运行前台的界面了,不过如果程序出错,会弹出一个错误对话框,说找不到traceback模块.

    这就要在app.py文件中加一句:

    import traceback

    把错误反馈以对话框形式弹出.


