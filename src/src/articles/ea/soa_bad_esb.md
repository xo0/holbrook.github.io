---
layout: post
title: "糟糕的ESB"
date: 2013-07-11
update: 2013-07-11
description: "技术领域又出现了无奈的一幕：最糟糕的技术被贴上最耀眼的标签，被推送到用户面前，免费赠送的还有厂商滔滔不绝的口水，让用户相信这才是最好的。"
category: 企业架构
tags: [SOA, ESB]
---


# ESB的定位

不存在“ESB是什么”这样的问题，只存在“需要把什么样的职责放到ESB中”，也就是“ESB的定位”问题。

在IBM的[SOA Foundation 参考模型](http://www.ibm.com/developerworks/cn/webservices/ws-soa-term1/#N100F7)中，

企业中的服务(Service)被分组为多个功能区，而ESB能够联通各个功能区中的服务，如下图所示：

![IBM-SOA-foundation-model](images/2013/soa/soa_foundation_model.png)


联通性很重要。就像企业内部如果沟通不畅，小则降低效率增加成本，大则导致企业分裂或死亡。

很荣幸，ESB承担了这项伟大的责任；同样也很不幸，由于ESB位高权重，很多厂商通过贿赂ESB上马了很多稀奇古怪的功能，他们希望你购买类似让员工与火星人沟通这样的功能！

不明真相的IT部门被厂商的顾问反复洗脑，花大价钱购买了ESB产品，开始满怀希望的尝试用ESB捆绑各种有用的没用的功能的解决各种稀奇古怪的问题——

终于，ESB被滥用了。在厂商成功的兜售下一个概念（比如私有云？）之前，ESB可能已经成为IT部门永远的痛。

是时候回归本质了。ESB最初的定位，就是要解决企业中服务的联通问题！


# 拼凑ESB


最初，服务的生产者和消费者可以自由交换：大家约定好交易地点（比如socket, http)，交易方式（如二进制，xml, json)以及交易内容（具体的服务）就可以了。在一个较小的范围内，每个参与者都能得到满足，而且交易成本很低。
如果一定要给出zhuangbility的名字，可以把三个方面分别叫做传输层，协议层和接口层。

由于服务的双方可能使用不同的语言，所以关于服务的内容通常用一种第三方的中立语言来定义。
这种中立的语言叫做[IDL(Interface description language,接口描述语言)](http://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80)。
常见的IDL如CORBA、SOAP，以及最近出现的[ThriftIDL](http://thrift.apache.org/docs/idl/)等。

让服务的双方理解IDL有两种方式：

1. 代码生成。针对每个具体的服务定义，通过工具生成服务端和客户端的原生语言包。这种方式通常也生成了协议层和传输层的代码。
2. 解析。通过每种语言通用的传输层和协议层API,可以获取到描述了服务内容的数据包。再通过通用的API可以解析获取数据包中的数据。

至此，服务的联通问题已经解决，一个自由市场形成了。


一天，至高无上的“神”瞥了一眼人世间的繁华，发现竟然无法一眼掌握所有的服务交换。于是，神说：“点对点是不好的，需要一个星形结构的拓扑来连接所有的服务生产者和消费者。”。然后噩梦就开始了。。。

神的仆从们仿照以太网设计了一种结构，将中心节点叫做ESB。然后开始将各种各样的东西塞入ESB。

开始的时候，ESB只是类似一个交换机。可是很快发现[MOM(Message-Oriented Middleware，面向消息的中间件)已经具备这样的功能，而且做得更多，甚至能够将消息持久化；

好吧，那么ESB可以是一个路由器。为了让ESB有必要称为一个路由器，必须假设服务请求者根本不知道是谁提供的服务。事实是否如此并不重要，就假设不知道吧。这个假设引起了两个个麻烦：


1. 如果不知道谁在提供服务，也就不知道提供了哪些服务。这个也不重要，刚好可以再引入一个新的玩意儿登记所有的“服务目录”。唔~，就叫[UDDI(Universal Description, Discovery, and Integration, 统一描述、发现和集成)](http://zh.wikipedia.org/wiki/UDDI)好了，名字越长越显得功能强大；


2. 如果不知道提供了哪些服务，也就不知道以什么样的协议和方式传输数据。这实在是太好了，ESB中还可以加上协议转换和传输适配的功能。


也许这时候神已经满足了，但是神的仆从们仍不满足。既然所有的请求都经过ESB，为何不增加一些管控的功能？再为ESB加上可靠性保证，负载均衡，流量控制，缓存，事务控制，加密传输，异常处理，服务调用及消息数据记录，系统及服务的状态监控，甚至统一安全管理。ESB又变成了防火墙。


既然ESB已经够复杂了，再复杂一些又何妨？我们还可以将ESB当做应用服务器：把挂载到ESB上的服务简单（只能是简单）拼凑一下就可以当做新的服务了！还要起一个好听的名字，叫做服务编排如何？

够了够了，已经够多了，看起来ESB的性能不会太好。而且那个叫BPM的家伙开始抱怨ESB的服务编排抢了它的生意，算了，就这样吧。




# ESB的实现

如上所述，一个组合了交换机、路由器、防火墙和应用服务器的东西，真的很难实现。不过什么都难不倒神的仆从，我们还是有办法去愚弄那些愚蠢的人类：

1. 绑定Web Service
   web service是 IBM 和 M$ 媾合的产物。性能低下，标准混乱，正好可以掩盖ESB本身的复杂和无序。我们可以鼓吹Web Service是最通用的——J2EE 和 .Net 可以无缝连接！

2. 使用中间件的方式

   中间件“就好比是不断将新思想一股脑儿浇在老方法上的一碗意大利面条”， 用来实现ESB再好不过了。可以让愚蠢的人类再也分不清什么是好的，什么是坏的；什么是新的，什么是旧的。

可能还有一些不为人知的内幕，怎奈肉眼凡胎无法识别。只好就此打住。

最终，厂商们在一个糟糕的框架之下对一些细枝末节进行了“标准之争”，给出一打"WS*"规范。之后心满意足的去制造各自的ESB了。于是技术领域又出现了无奈的一幕：最糟糕的技术被贴上最耀眼的标签，被推送到用户面前，免费赠送的还有厂商滔滔不绝的口水，让用户相信这才是最好的。


# 后记

先别急着喷口水，本文只是关于ESB的反面，另一篇文章会说说正面。
